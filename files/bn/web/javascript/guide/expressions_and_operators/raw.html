<div>{{jsSidebar("JavaScript Guide")}} {{PreviousNext("Web/JavaScript/Guide/Functions", "Web/JavaScript/Guide/Numbers_and_dates")}}</div>

<p><strong>এই অধ্যায়ে জাভাস্ক্রিপ্ট এক্সপ্রেশন এবং অপারেটর নিয়ে আলোচনা করা হয়েছে, যার মধ্যে রয়েছে {{Glossary('assignment','এসাইনমেন্ট')}}, তুলনা করার, গানিতিক, বিট সম্পর্কিত , লজিক সংক্রান্ত, স্ট্রিং এবং আরও কিছু বিশেষ ধরনের অপারেটর।</strong></p>

<h2 id="এক্সপ্রেশন">এক্সপ্রেশন</h2>

<p><em>এক্সপ্রেশন</em> হলো এক টুকরো কোড যা আপনাকে কোন মান দিতে পারবে।</p>

<p>সাধারণত, এক্সপ্রেশন দুই ধরনেরঃ প্রথমটিতে কোন {{Glossary('variable', 'চলককে')}} মান দেওয়া হয় এবং, দ্বিতীয়টিতে এমন কোন কোড যা থেকে স্বাভাবিকভাবেই, কোন মান পাওয়া যায়।</p>

<p><code>x = 7</code>, এই এক্সপ্রেশনটি হল প্রথম ধরনের। এখানে, = চিহ্নের মাধ্যমে নির্দেশ করা হয়েছে x চলকের মান সাত। এক্ষেত্রে, এক্সপ্রেশনটির মাধ্যমে x চলকের মান নির্দিষ্ট করা হয়েছে।</p>

<p>আর দ্বিতীয় পদ্ধতি'র উদাহরণ হল <code>3 + 4</code> । এখানে <code>+</code> অপারেটর ব্যবহার করে তিন এর সাথে চার যোগ করা হয়েছে, কিন্তু ফলাফল কোথাও বসিয়ে দেওয়া হয়নি।<br>
 <br>
 জাভাস্ক্রিপ্টে নিম্নোক্ত ধরনের এক্সপ্রেশন রয়েছেঃ</p>

<ul>
 <li>গাণিতিক (Arithmetic) : এটি সংখ্যার সাথে সম্পর্কিত, উদাহরণস্বরূপ 3.14159। (প্রয়োজনীয় {{ web.link("#Arithmetic_operators", "গাণিতিক অপারেটরসমূহ") }}।)</li>
 <li>স্ট্রিং : এটি বর্ণের সাথে সম্পর্কিত, উদাহরণস্বরূপ "Fred" বা "234"। (প্রয়োজনীয় {{ web.link("#String_operators", "স্ট্রিং অপারেটরসমূহ") }}।)</li>
 <li>লজিক্যাল : এটি true বা false -এর সাথে সম্পর্কিত. (প্রয়োজনীয় {{ web.link("#Logical_operators", "লজিক্যাল অপারেটরসমূহ") }}।)</li>
 <li>অবজেক্ট: এটি {{Glossary('object','অবজেক্টের')}} সাথে সম্পর্কিত। (দেখুন {{ web.link("#Special_operators", "বিশেষ অপারেটরসমূহ") }} যেগুলো অবজেক্টের সাথে সম্পর্কিত।)</li>
</ul>

<h2 id="অপারেটর">অপারেটর</h2>

<p>জাভাস্ক্রিপ্টে বিভিন্ন ধরনের অপারেটর রয়েছে। এই অংশে প্রাধান্যের ভিত্তিতে অপারেটরগুলো নিয়ে প্রয়োজনীয় আলোচনা করা হয়েছে।</p>

<ul>
 <li>{{ web.link("#Assignment_operators", "এসানমেন্ট বা মান বসানোর অপারেটরসমূহ") }}</li>
 <li>{{ web.link("#Comparison_operators", "তুলনা করার অপারেটরসমূহ") }}</li>
 <li>{{ web.link("#Arithmetic_operators", "গাণিতিক অপারেটরসমূহ") }}</li>
 <li>{{ web.link("#Bitwise_operators", "বিট সম্পর্কিত অপারেটরসমূহ") }}</li>
 <li>{{ web.link("#Logical_operators", "লজিক সংক্রান্ত অপারেটরসমূহ") }}</li>
 <li>{{ web.link("#String_operators", "স্ট্রিং অপারেটরসমূহ") }}</li>
 <li>{{ web.link("#Special_operators", "বিশেষ অপারেটরসমূহ") }}</li>
</ul>

<p>জাভাস্কিরপ্টে দ্বিমিক বা বাইনারী (binary) এবং একক (unary) উভয় ধরনের অপারেটর রয়েছে। এছাড়া রয়েছে একটি কন্ডিশনাল অপারেটর, যার তিনটি অপারেন্ড(যার উপর ভিত্তি করে কোন কিছু সম্পন্ন করা হয়) প্রয়োজন হয়।</p>

<p>একটি বাইনারী অপারেটরে দুইটি অপারেন্ডের প্রয়োজন হয়। এক্ষেত্রে একটি অপারেটরের আগে এবং অপরটি পরে বসে:</p>

<pre><em>operand1</em> <em>operator</em> <em>operand2</em>
</pre>

<p>উদাহরণস্বরূপ <code>3+4</code> বা <code>x*y</code>।</p>

<p>একক অপারেটরের ক্ষেত্রে শুধুমাত্র একটি অপারেটরের প্রয়োজন হয় এবং সেটি অপারেটরের আগে বা পরে বসতে পারে:</p>

<pre><em>operator</em> <em>operand</em>
</pre>

<p>অথবা,</p>

<pre><em>operand</em> <em>operator</em>
</pre>

<p>উদাহরণস্বরূপ : <code>x++</code> বা <code>++x</code>।</p>

<h3 id="এসানমেন্ট_অপারেটর">এসানমেন্ট অপারেটর</h3>

<p>এসাইনমেন্ট অপারেটর আগের অপারেন্ডের সাথে তার পরের অপারেন্ডের উপর ভিত্তি করে, কোন মান নির্দিষ্ট করে। প্রাথমিক এসানমেন্ট অপারেটর হিসেবে = ব্যবহৃত হয়, যা তার আগের অপারেন্ডের সাথে পরের অপারেন্ডের মান নির্দিষ্ট করে। যেমন, x = y, x এর মান হিসেবে y কে নির্দেশ করে।</p>

<p>এছাড়া আরও যেসব এসানমেন্ট অপারেটর রয়েছে সেগুলো নিচের ছকে দেখানো হল:</p>

<table class="standard-table">
 <caption>Table 3.1 Assignment operators</caption>
 <thead>
  <tr>
   <th scope="col">Shorthand operator</th>
   <th scope="col">Meaning</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>x += y</code></td>
   <td><code>x = x + y</code></td>
  </tr>
  <tr>
   <td><code>x -= y</code></td>
   <td><code>x = x - y</code></td>
  </tr>
  <tr>
   <td><code>x *= y</code></td>
   <td><code>x = x * y</code></td>
  </tr>
  <tr>
   <td><code>x /= y</code></td>
   <td><code>x = x / y</code></td>
  </tr>
  <tr>
   <td><code>x %= y</code></td>
   <td><code>x = x % y</code></td>
  </tr>
  <tr>
   <td><code>x &lt;&lt;= y</code></td>
   <td><code>x = x &lt;&lt; y</code></td>
  </tr>
  <tr>
   <td><code>x &gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><code>x &gt;&gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><code>x &amp;= y</code></td>
   <td><code>x = x &amp; y</code></td>
  </tr>
  <tr>
   <td><code>x ^= y</code></td>
   <td><code>x = x ^ y</code></td>
  </tr>
  <tr>
   <td><code>x |= y</code></td>
   <td><code>x = x | y</code></td>
  </tr>
 </tbody>
</table>

<h3 id="কম্পারিজনাল_অপারেটর">কম্পারিজনাল অপারেটর</h3>

<p><span class="comment">This seems to me kind of poorly explained, mostly the difference betwen "==" and "==="...</span> কম্পারিজনাল অপারেটর তার অপারেন্ডগুলোকে তুলনা করে, সেটি সঠিক কিনা তার উপর ভিত্তি করে একটি লজিক্যাল মান ফেরত দেয়। অপারেন্ড হিসেবে সংখ্যা, স্ট্রিং, লজিক্যাল অথবা অবজেক্ট ব্যবহার করা যায়। স্ট্রিংকে ইউনিকোড মান ব্যবহার করে লেক্সিকোগ্রাফিক্যাল স্ট্যান্ডার্ডের উপর ভিত্তি করে তুলনা করা হয়। বেশিরভাগক্ষেত্রে, যদি দুইটি অপারেন্ড একই ধরনের(Type) না হয়, তাহলে জাভাস্ক্রিপ্ট তাদেরকে পরিবর্তন করে একই করার চেষ্টা করে। এক্ষেত্রে সাধারণত ক্রমের উপর ভিত্তি করে তুলনা করা হয়। === এবং !== অপারেটর দুটি যথাক্রমে  নির্ণয় করে অপারেন্ড দুটি সম্পূর্ণ এক এবং সম্পূর্ণ এক নয় কিনা। এই অপারেটরগুলো অপারেন্ডদের টাইপ পরিবর্তন না করে প্রথমে দেখে তারা একই কিনা। নিচের ছকে কম্পারিজন অপারেটর :</p>

<pre class="brush: js">var var1 = 3, var2 = 4;
</pre>

<table class="standard-table">
 <caption>Table 3.2 Comparison operators</caption>
 <thead>
  <tr>
   <th scope="col">Operator</th>
   <th scope="col">Description</th>
   <th scope="col">Examples returning true</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>সমান (<code>==</code>)</td>
   <td>অপারেন্ডগুলো সমান হলে true ফেরত পাঠায়।</td>
   <td><code>3 == var1</code>
    <p><code>"3" == var1</code></p>
    <code>3 == '3'</code></td>
  </tr>
  <tr>
   <td>সমান নয় (<code>!=</code>)</td>
   <td>অপারেন্ডগুলো সমান না হলে true ফেরত পাঠায়।</td>
   <td><code>var1 != 4<br>
    var2 != "3"</code></td>
  </tr>
  <tr>
   <td>সম্পূর্ণ একই (<code>===</code>)</td>
   <td>অপারেন্ডগুলো সমান এবং একই ধরনের হলে true ফেরত পাঠায়। আরও দেখুন <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> এবং <a href="/en-US/docs/Web/JavaScript/Guide/Sameness" title="/en-US/docs/Web/JavaScript/Guide/Sameness">sameness in JS</a>।</td>
   <td><code>3 === var1</code></td>
  </tr>
  <tr>
   <td>সম্পূর্ণ একই নয় (<code>!==</code>)</td>
   <td>অপারেন্ডগুলো অসমান এবং/বা একই ধরনের না  হলে true ফেরত পাঠায়।</td>
   <td><code>var1 !== "3"<br>
    3 !== '3'</code></td>
  </tr>
  <tr>
   <td>বড় (<code>&gt;</code>)</td>
   <td>আগের অপারেন্ড পরের অপারেন্ডের চেয়ে বড় হলে true ফেরত পাঠায়।</td>
   <td><code>var2 &gt; var1<br>
    "12" &gt; 2</code></td>
  </tr>
  <tr>
   <td>বড় বা সমান (<code>&gt;=</code>)</td>
   <td>আগের অপারেন্ড পরের অপারেন্ডের সমান বা তার চেয়ে বড় হলে true ফেরত পাঠায়।</td>
   <td><code>var2 &gt;= var1<br>
    var1 &gt;= 3</code></td>
  </tr>
  <tr>
   <td>ছোট (<code>&lt;</code>)</td>
   <td>আগের অপারেন্ড পরের অপারেন্ডের চেয়ে ছোট হলে true ফেরত পাঠায়।</td>
   <td><code>var1 &lt; var2<br>
    "2" &lt; "12"</code></td>
  </tr>
  <tr>
   <td>ছোট বা সমান (<code>&lt;=</code>)</td>
   <td>আগের অপারেন্ড পরের অপারেন্ডের সমান বা তার চেয়ে ছোট হলে true ফেরত পাঠায়।</td>
   <td><code>var1 &lt;= var2<br>
    var2 &lt;= 5</code></td>
  </tr>
 </tbody>
</table>

<h3 id="গাণিতিক_অপারেটর">গাণিতিক অপারেটর</h3>

<p>Arithmetic operators take numerical values (either literals or variables) as their operands and return a single numerical value. The standard arithmetic operators are addition (+), subtraction (-), multiplication (*), and division (/). These operators work as they do in most other programming languages when used with floating point numbers (in particular, note that division by zero produces <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity"><code>Infinity</code></a>). For example:</p>

<pre class="brush: js">console.log(1 / 2); /* prints 0.5 */
console.log(1 / 2 == 1.0 / 2.0); /* also this is true */
</pre>

<p>In addition, JavaScript provides the arithmetic operators listed in the following table.</p>

<table class="fullwidth-table">
 <caption>Table 3.3 Arithmetic operators</caption>
 <thead>
  <tr>
   <th scope="col">Operator</th>
   <th scope="col">Description</th>
   <th scope="col">Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>%</code><br>
    (Modulus)</td>
   <td>Binary operator. Returns the integer remainder of dividing the two operands.</td>
   <td>12 % 5 returns 2.</td>
  </tr>
  <tr>
   <td><code>++</code><br>
    (Increment)</td>
   <td>Unary operator. Adds one to its operand. If used as a prefix operator (<code>++x</code>), returns the value of its operand after adding one; if used as a postfix operator (<code>x++</code>), returns the value of its operand before adding one.</td>
   <td>If <code>x</code> is 3, then <code>++x</code> sets <code>x</code> to 4 and returns 4, whereas <code>x++</code> returns 3 and, only then, sets <code>x</code> to 4.</td>
  </tr>
  <tr>
   <td><code>--</code><br>
    (Decrement)</td>
   <td>Unary operator. Subtracts one from its operand. The return value is analogous to that for the increment operator.</td>
   <td>If <code>x</code> is 3, then <code>--x</code> sets <code>x</code> to 2 and returns 2, whereas <code>x--</code> returns 3 and, only then, sets <code>x</code> to 2.</td>
  </tr>
  <tr>
   <td><code>-</code><br>
    (Unary negation)</td>
   <td>Unary operator. Returns the negation of its operand.</td>
   <td>If <code>x</code> is 3, then <code>-x</code> returns -3.</td>
  </tr>
 </tbody>
</table>

<h3 id="বিট_সম্পর্কিত_অপারেটর">বিট সম্পর্কিত অপারেটর</h3>

<p>Bitwise operators treat their operands as a set of 32 bits (zeros and ones), rather than as decimal, hexadecimal, or octal numbers. For example, the decimal number nine has a binary representation of 1001. Bitwise operators perform their operations on such binary representations, but they return standard JavaScript numerical values.</p>

<p>The following table summarizes JavaScript's bitwise operators.</p>

<table class="standard-table">
 <caption>Table 3.4 Bitwise operators</caption>
 <thead>
  <tr>
   <th scope="col">Operator</th>
   <th scope="col">Usage</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Bitwise AND</td>
   <td><code>a &amp; b</code></td>
   <td>Returns a one in each bit position for which the corresponding bits of both operands are ones.</td>
  </tr>
  <tr>
   <td>Bitwise OR</td>
   <td><code>a | b</code></td>
   <td>Returns a one in each bit position for which the corresponding bits of either or both operands are ones.</td>
  </tr>
  <tr>
   <td>Bitwise XOR</td>
   <td><code>a ^ b</code></td>
   <td>Returns a one in each bit position for which the corresponding bits of either but not both operands are ones.</td>
  </tr>
  <tr>
   <td>Bitwise NOT</td>
   <td><code>~ a</code></td>
   <td>Inverts the bits of its operand.</td>
  </tr>
  <tr>
   <td>Left shift</td>
   <td><code>a &lt;&lt; b</code></td>
   <td>Shifts <code>a</code> in binary representation <code>b</code> bits to the left, shifting in zeros from the right.</td>
  </tr>
  <tr>
   <td>Sign-propagating right shift</td>
   <td><code>a &gt;&gt; b</code></td>
   <td>Shifts <code>a</code> in binary representation <code>b</code> bits to the right, discarding bits shifted off.</td>
  </tr>
  <tr>
   <td>Zero-fill right shift</td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>Shifts <code>a</code> in binary representation <code>b</code> bits to the right, discarding bits shifted off, and shifting in zeros from the left.</td>
  </tr>
 </tbody>
</table>

<h4 id="Bitwise_Logical_Operators" name="Bitwise_Logical_Operators">Bitwise logical operators</h4>

<p>Conceptually, the bitwise logical operators work as follows:</p>

<ul>
 <li>The operands are converted to thirty-two-bit integers and expressed by a series of bits (zeros and ones).</li>
 <li>Each bit in the first operand is paired with the corresponding bit in the second operand: first bit to first bit, second bit to second bit, and so on.</li>
 <li>The operator is applied to each pair of bits, and the result is constructed bitwise.</li>
</ul>

<p>For example, the binary representation of nine is 1001, and the binary representation of fifteen is 1111. So, when the bitwise operators are applied to these values, the results are as follows:</p>

<table class="standard-table">
 <caption>Table 3.5 Bitwise operator examples</caption>
 <thead>
  <tr>
   <th scope="col">Expression</th>
   <th scope="col">Result</th>
   <th scope="col">Binary Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>15 &amp; 9</code></td>
   <td><code>9</code></td>
   <td><code>1111 &amp; 1001 = 1001</code></td>
  </tr>
  <tr>
   <td><code>15 | 9</code></td>
   <td><code>15</code></td>
   <td><code>1111 | 1001 = 1111</code></td>
  </tr>
  <tr>
   <td><code>15 ^ 9</code></td>
   <td><code>6</code></td>
   <td><code>1111 ^ 1001 = 0110</code></td>
  </tr>
  <tr>
   <td><code>~15</code></td>
   <td><code>-16</code></td>
   <td><code>~</code><code>00000000...</code><code>00001111 = </code><code>1111</code><code>1111</code><code>...</code><code>11110000</code></td>
  </tr>
  <tr>
   <td><code>~9</code></td>
   <td><code>-10</code></td>
   <td><code>~</code><code>00000000</code><code>...</code><code>0000</code><code>1001 = </code><code>1111</code><code>1111</code><code>...</code><code>1111</code><code>0110</code></td>
  </tr>
 </tbody>
</table>

<p>Note that all 32 bits are inverted using the Bitwise NOT operator, and that values with the most significant (left-most) bit set to 1 represent negative numbers (two's-complement representation).</p>

<h4 id="Bitwise_Shift_Operators" name="Bitwise_Shift_Operators">Bitwise shift operators</h4>

<p>The bitwise shift operators take two operands: the first is a quantity to be shifted, and the second specifies the number of bit positions by which the first operand is to be shifted. The direction of the shift operation is controlled by the operator used.</p>

<p>Shift operators convert their operands to thirty-two-bit integers and return a result of the same type as the left operand.</p>

<p>The shift operators are listed in the following table.</p>

<table class="fullwidth-table">
 <caption>Table 3.6 Bitwise shift operators</caption>
 <thead>
  <tr>
   <th scope="col">Operator</th>
   <th scope="col">Description</th>
   <th scope="col">Example</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&lt;&lt;</code><br>
    (Left shift)</td>
   <td>This operator shifts the first operand the specified number of bits to the left. Excess bits shifted off to the left are discarded. Zero bits are shifted in from the right.</td>
   <td><code>9&lt;&lt;2</code> yields 36, because 1001 shifted 2 bits to the left becomes 100100, which is 36.</td>
  </tr>
  <tr>
   <td><code>&gt;&gt;</code><br>
    (Sign-propagating right shift)</td>
   <td>This operator shifts the first operand the specified number of bits to the right. Excess bits shifted off to the right are discarded. Copies of the leftmost bit are shifted in from the left.</td>
   <td><code>9&gt;&gt;2</code> yields 2, because 1001 shifted 2 bits to the right becomes 10, which is 2. Likewise, <code>-9&gt;&gt;2</code> yields -3, because the sign is preserved.</td>
  </tr>
  <tr>
   <td><code>&gt;&gt;&gt;</code><br>
    (Zero-fill right shift)</td>
   <td>This operator shifts the first operand the specified number of bits to the right. Excess bits shifted off to the right are discarded. Zero bits are shifted in from the left.</td>
   <td><code>19&gt;&gt;&gt;2</code> yields 4, because 10011 shifted 2 bits to the right becomes 100, which is 4. For non-negative numbers, zero-fill right shift and sign-propagating right shift yield the same result.</td>
  </tr>
 </tbody>
</table>

<h3 id="লজিক্যাল_অপারেটর">লজিক্যাল অপারেটর</h3>

<p>Logical operators are typically used with Boolean (logical) values; when they are, they return a Boolean value. However, the &amp;&amp; and || operators actually return the value of one of the specified operands, so if these operators are used with non-Boolean values, they may return a non-Boolean value. The logical operators are described in the following table.</p>

<table class="fullwidth-table">
 <caption>Table 3.6 Logical operators</caption>
 <thead>
  <tr>
   <th scope="col">Operator</th>
   <th scope="col">Usage</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&amp;&amp;</code></td>
   <td><code>expr1 &amp;&amp; expr2</code></td>
   <td>(Logical AND) Returns <code>expr1</code> if it can be converted to false; otherwise, returns <code>expr2</code>. Thus, when used with Boolean values, <code>&amp;&amp;</code> returns true if both operands are true; otherwise, returns false.</td>
  </tr>
  <tr>
   <td><code>||</code></td>
   <td><code>expr1 || expr2</code></td>
   <td>(Logical OR) Returns <code>expr1</code> if it can be converted to true; otherwise, returns <code>expr2</code>. Thus, when used with Boolean values, <code>||</code> returns true if either operand is true; if both are false, returns false.</td>
  </tr>
  <tr>
   <td><code>!</code></td>
   <td><code>!expr</code></td>
   <td>(Logical NOT) Returns false if its single operand can be converted to true; otherwise, returns true.</td>
  </tr>
 </tbody>
</table>

<p>Examples of expressions that can be converted to false are those that evaluate to null, 0, NaN, the empty string (""), or undefined.</p>

<p>The following code shows examples of the &amp;&amp; (logical AND) operator.</p>

<pre class="brush: js">var a1 =  true &amp;&amp; true;     // t &amp;&amp; t returns true
var a2 =  true &amp;&amp; false;    // t &amp;&amp; f returns false
var a3 = false &amp;&amp; true;     // f &amp;&amp; t returns false
var a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f returns false
var a5 = "Cat" &amp;&amp; "Dog";    // t &amp;&amp; t returns Dog
var a6 = false &amp;&amp; "Cat";    // f &amp;&amp; t returns false
var a7 = "Cat" &amp;&amp; false;    // t &amp;&amp; f returns false
</pre>

<p>The following code shows examples of the || (logical OR) operator.</p>

<pre class="brush: js">var o1 =  true || true;     // t || t returns true
var o2 = false || true;     // f || t returns true
var o3 =  true || false;    // t || f returns true
var o4 = false || (3 == 4); // f || f returns false
var o5 = "Cat" || "Dog";    // t || t returns Cat
var o6 = false || "Cat";    // f || t returns Cat
var o7 = "Cat" || false;    // t || f returns Cat
</pre>

<p>The following code shows examples of the ! (logical NOT) operator.</p>

<pre class="brush: js">var n1 = !true;  // !t returns false
var n2 = !false; // !f returns true
var n3 = !"Cat"; // !t returns false
</pre>

<h4 id="Short-Circuit_Evaluation" name="Short-Circuit_Evaluation">Short-circuit evaluation</h4>

<p>As logical expressions are evaluated left to right, they are tested for possible "short-circuit" evaluation using the following rules:</p>

<ul>
 <li><code>false</code> &amp;&amp; <em>anything</em> is short-circuit evaluated to false.</li>
 <li><code>true</code> || <em>anything</em> is short-circuit evaluated to true.</li>
 <li>Imagine a short-circuit evaluation as an if-else condition:
  <ul>
   <li><code style="font-size: 13.63636302947998px;">boolean expression</code> &amp;&amp; <em>expression to be executed if the former is <strong>true </strong></em><strong> </strong>|| <em>expression to be executed if the former is <strong>false</strong></em></li>
  </ul>
 </li>
</ul>

<p>The rules of logic guarantee that these evaluations are always correct. Note that the <em>anything</em> part of the above expressions is not evaluated, so any side effects of doing so do not take effect.</p>

<h3 id="স্ট্রিং_অপারেটর">স্ট্রিং অপারেটর</h3>

<p>In addition to the comparison operators, which can be used on string values, the concatenation operator (+) concatenates two string values together, returning another string that is the union of the two operand strings. For example, <code>"my " + "string"</code> returns the string <code>"my string"</code>.</p>

<p>The shorthand assignment operator += can also be used to concatenate strings. For example, if the variable <code>mystring</code> has the value "alpha", then the expression <code>mystring += "bet"</code> evaluates to "alphabet" and assigns this value to <code>mystring</code>.</p>

<h3 id="বিশেষ_অপারেটর">বিশেষ অপারেটর</h3>

<p>JavaScript provides the following special operators:</p>

<ul>
 <li>{{ web.link("#Conditional_operator", "Conditional operator") }}</li>
 <li>{{ web.link("#Comma_operator", "Comma operator") }}</li>
 <li><code>{{ web.link("#delete", "delete") }}</code></li>
 <li><code>{{ web.link("#in", "in") }}</code></li>
 <li><code>{{ web.link("#instanceof", "instanceof") }}</code></li>
 <li><code>{{ web.link("#new", "new") }}</code></li>
 <li><code>{{ web.link("#this", "this") }}</code></li>
 <li><code>{{ web.link("#typeof", "typeof") }}</code></li>
 <li><code>{{ web.link("#void", "void") }}</code></li>
</ul>

<h4 id="conditional_operator" name="conditional_operator">কন্ডিশনাল অপারেটর</h4>

<p>The conditional operator is the only JavaScript operator that takes three operands. The operator can have one of two values based on a condition. The syntax is:</p>

<pre><em>condition</em> ? <em>val1</em> : <em>val2</em>
</pre>

<p>If <code>condition</code> is true, the operator has the value of <code>val1</code>. Otherwise it has the value of <code>val2</code>. You can use the conditional operator anywhere you would use a standard operator.</p>

<p>For example,</p>

<pre class="brush: js">var status = (age &gt;= 18) ? "adult" : "minor";
</pre>

<p>This statement assigns the value "adult" to the variable <code>status</code> if <code>age</code> is eighteen or more. Otherwise, it assigns the value "minor" to <code>status</code>.</p>

<h4 id="comma_operator" name="comma_operator">কমা অপারেটর</h4>

<p>The comma operator (<code>,</code>) simply evaluates both of its operands and returns the value of the second operand. This operator is primarily used inside a <code>for</code> loop, to allow multiple variables to be updated each time through the loop.</p>

<p>For example, if <code>a</code> is a 2-dimensional array with 10 elements on a side, the following code uses the comma operator to increment two variables at once. The code prints the values of the diagonal elements in the array:</p>

<pre class="brush: js">for (var i = 0, j = 9; i &lt;= 9; i++, j--)
  document.writeln("a[" + i + "][" + j + "]= " + a[i][j]);
</pre>

<h4 id="delete" name="delete"><code>ডিলেট</code></h4>

<p>The <code>delete</code> operator deletes an object, an object's property, or an element at a specified index in an array. The syntax is:</p>

<pre class="brush: js">delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // legal only within a with statement
</pre>

<p>where <code>objectName</code> is the name of an object, <code>property</code> is an existing property, and <code>index</code> is an integer representing the location of an element in an array.</p>

<p>The fourth form is legal only within a <code>with</code> statement, to delete a property from an object.</p>

<p>You can use the <code>delete</code> operator to delete variables declared implicitly but not those declared with the <code>var</code> statement.</p>

<p>If the <code>delete</code> operator succeeds, it sets the property or element to <code>undefined</code>. The <code>delete</code> operator returns true if the operation is possible; it returns false if the operation is not possible.</p>

<pre class="brush: js">x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // create property h
delete x;       // returns true (can delete if declared implicitly)
delete y;       // returns false (cannot delete if declared with var)
delete Math.PI; // returns false (cannot delete predefined properties)
delete myobj.h; // returns true (can delete user-defined properties)
delete myobj;   // returns true (can delete if declared implicitly)
</pre>

<h5 id="Array_থেকে_Element_ডিলেট_করা">Array থেকে Element ডিলেট করা</h5>

<p>When you delete an array element, the array length is not affected. For example, if you delete <code>a[3]</code>, <code>a[4]</code> is still <code>a[4]</code> and <code>a[3]</code> is undefined.</p>

<p>When the <code>delete</code> operator removes an array element, that element is no longer in the array. In the following example, <code>trees[3]</code> is removed with <code>delete</code>. However, <code>trees[3]</code> is still addressable and returns <code>undefined</code>.</p>

<pre class="brush: js">var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
delete trees[3];
if (3 in trees) {
  // this does not get executed
}
</pre>

<p>If you want an array element to exist but have an undefined value, use the <code>undefined</code> keyword instead of the <code>delete</code> operator. In the following example, <code>trees[3]</code> is assigned the value <code>undefined</code>, but the array element still exists:</p>

<pre class="brush: js">var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
trees[3] = undefined;
if (3 in trees) {
  // this gets executed
}
</pre>

<h4 id="in" name="in"><code>in</code></h4>

<p>The <code>in</code> operator returns true if the specified property is in the specified object. The syntax is:</p>

<pre class="brush: js">propNameOrNumber in objectName
</pre>

<p>where <code>propNameOrNumber</code> is a string or numeric expression representing a property name or array index, and <code>objectName</code> is the name of an object.</p>

<p>The following examples show some uses of the <code>in</code> operator.</p>

<pre class="brush: js">// Arrays
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees;        // returns true
3 in trees;        // returns true
6 in trees;        // returns false
"bay" in trees;    // returns false (you must specify the index number,
                   // not the value at that index)
"length" in trees; // returns true (length is an Array property)

// Predefined objects
"PI" in Math;          // returns true
var myString = new String("coral");
"length" in myString;  // returns true

// Custom objects
var mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar;  // returns true
"model" in mycar; // returns true
</pre>

<h4 id="instanceof" name="instanceof"><code>instanceof</code></h4>

<p>The <code>instanceof</code> operator returns true if the specified object is of the specified object type. The syntax is:</p>

<pre class="brush: js">objectName instanceof objectType
</pre>

<p>where <code>objectName</code> is the name of the object to compare to <code>objectType</code>, and <code>objectType</code> is an object type, such as <code>Date</code> or <code>Array</code>.</p>

<p>Use <code>instanceof</code> when you need to confirm the type of an object at runtime. For example, when catching exceptions, you can branch to different exception-handling code depending on the type of exception thrown.</p>

<p>For example, the following code uses <code>instanceof</code> to determine whether <code>theDay</code> is a <code>Date</code> object. Because <code>theDay</code> is a <code>Date</code> object, the statements in the <code>if</code> statement execute.</p>

<pre class="brush: js">var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // statements to execute
}
</pre>

<h4 id="new" name="new"><code>new</code></h4>

<p>You can use the <code>new</code> operator to create an instance of a user-defined object type or of one of the predefined object types <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Function</code>, <code>Image</code>, <code>Number</code>, <code>Object</code>, <code>Option</code>, <code>RegExp</code>, or <code>String</code>. On the server, you can also use it with <code>DbPool</code>, <code>Lock</code>, <code>File</code>, or <code>SendMail</code>. Use <code>new</code> as follows:</p>

<pre class="brush: js">var objectName = new objectType([param1, param2, ..., paramN]);
</pre>

<p>You can also create objects using object initializers, as described in {{ web.link("Working_with_objects#Using_object_initializers", "using object initializers") }}.</p>

<p>See the <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code> operator</a> page in the Core JavaScript Reference for more information.</p>

<h4 id="this" name="this"><code>this</code></h4>

<p>Use the <code>this</code> keyword to refer to the current object. In general, <code>this</code> refers to the calling object in a method. Use <code>this</code> as follows:</p>

<pre class="brush: js">this["propertyName"]
</pre>

<pre class="brush: js">this.propertyName
</pre>

<p><strong>Example 1.</strong><br>
 Suppose a function called <code>validate</code> validates an object's <code>value</code> property, given the object and the high and low values:</p>

<pre class="brush: js">function validate(obj, lowval, hival){
  if ((obj.value &lt; lowval) || (obj.value &gt; hival))
    alert("Invalid Value!");
}
</pre>

<p>You could call <code>validate</code> in each form element's <code>onChange</code> event handler, using <code>this</code> to pass it the form element, as in the following example:</p>

<pre class="brush: html">&lt;B&gt;Enter a number between 18 and 99:&lt;/B&gt;
&lt;INPUT TYPE="text" NAME="age" SIZE=3
   onChange="validate(this, 18, 99);"&gt;
</pre>

<p><strong>উদাহরণ ২:</strong><br>
 When combined with the <code>form</code> property, <code>this</code> can refer to the current object's parent form. In the following example, the form <code>myForm</code> contains a <code>Text</code> object and a button. When the user clicks the button, the value of the <code>Text</code> object is set to the form's name. The button's <code>onClick</code> event handler uses <code>this.form</code> to refer to the parent form, <code>myForm</code>.</p>

<pre class="brush: html">&lt;FORM NAME="myForm"&gt;
Form name:&lt;INPUT TYPE="text" NAME="text1" VALUE="Beluga"/&gt;
&lt;INPUT NAME="button1" TYPE="button" VALUE="Show Form Name"
   onClick="this.form.text1.value = this.form.name;"/&gt;
&lt;/FORM&gt;
</pre>

<h4 id="typeof" name="typeof"><code>typeof</code></h4>

<p>The <code>typeof</code> operator is used in either of the following ways:</p>

<ol>
 <li>
  <pre class="brush: js">typeof operand
</pre>
 </li>
 <li>
  <pre class="brush: js">typeof (operand)
</pre>
 </li>
</ol>

<p>The <code>typeof</code> operator returns a string indicating the type of the unevaluated operand. <code>operand</code> is the string, variable, keyword, or object for which the type is to be returned. The parentheses are optional.</p>

<p>Suppose you define the following variables:</p>

<pre class="brush: js">var myFun = new Function("5 + 2");
var shape = "round";
var size = 1;
var today = new Date();
</pre>

<p>The <code>typeof</code> operator returns the following results for these variables:</p>

<pre class="brush: js">typeof myFun;     // returns "function"
typeof shape;     // returns "string"
typeof size;      // returns "number"
typeof today;     // returns "object"
typeof dontExist; // returns "undefined"
</pre>

<p>For the keywords <code>true</code> and <code>null</code>, the <code>typeof</code> operator returns the following results:</p>

<pre class="brush: js">typeof true; // returns "boolean"
typeof null; // returns "object"
</pre>

<p>For a number or string, the <code>typeof</code> operator returns the following results:</p>

<pre class="brush: js">typeof 62;            // returns "number"
typeof 'Hello world'; // returns "string"
</pre>

<p>For property values, the <code>typeof</code> operator returns the type of value the property contains:</p>

<pre class="brush: js">typeof document.lastModified; // returns "string"
typeof window.length;         // returns "number"
typeof Math.LN2;              // returns "number"
</pre>

<p>For methods and functions, the <code>typeof</code> operator returns results as follows:</p>

<pre class="brush: js">typeof blur;        // returns "function"
typeof eval;        // returns "function"
typeof parseInt;    // returns "function"
typeof shape.split; // returns "function"
</pre>

<p>For predefined objects, the <code>typeof</code> operator returns results as follows:</p>

<pre class="brush: js">typeof Date;     // returns "function"
typeof Function; // returns "function"
typeof Math;     // returns "object"
typeof Option;   // returns "function"
typeof String;   // returns "function"
</pre>

<h4 id="void" name="void"><code>void</code></h4>

<p>The <code>void</code> operator is used in either of the following ways:</p>

<ol>
 <li>
  <pre class="brush: js">void (expression)
</pre>
 </li>
 <li>
  <pre class="brush: js">void expression
</pre>
 </li>
</ol>

<p>The <code>void</code> operator specifies an expression to be evaluated without returning a value. <code>expression</code> is a JavaScript expression to evaluate. The parentheses surrounding the expression are optional, but it is good style to use them.</p>

<p>You can use the <code>void</code> operator to specify an expression as a hypertext link. The expression is evaluated but is not loaded in place of the current document.</p>

<p>The following code creates a hypertext link that does nothing when the user clicks it. When the user clicks the link, <code>void(0)</code> evaluates to undefined, which has no effect in JavaScript.</p>

<pre class="brush: html">&lt;A HREF="javascript:void(0)"&gt;Click here to do nothing&lt;/A&gt;
</pre>

<p>The following code creates a hypertext link that submits a form when the user clicks it.</p>

<pre class="brush: html">&lt;A HREF="javascript:void(document.form.submit())"&gt;
Click here to submit&lt;/A&gt;</pre>

<h3 id="Operator_precedence">Operator precedence</h3>

<p>The <em>precedence</em> of operators determines the order they are applied when evaluating an expression. You can override operator precedence by using parentheses.</p>

<p>The following table describes the precedence of operators, from highest to lowest.</p>

<p><small><em>In accordance with <a href="/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Operators#Precedence_Tablerators#Precedence_Table">relevant discussion</a>, this table was reversed to list operators in <strong>decreasing</strong> order of priority.</em></small></p>

<table class="standard-table">
 <caption>Table 3.7 Operator precedence</caption>
 <thead>
  <tr>
   <th scope="col">Operator type</th>
   <th scope="col">Individual operators</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>member</td>
   <td><code>. []</code></td>
  </tr>
  <tr>
   <td>call / create instance</td>
   <td><code>() new</code></td>
  </tr>
  <tr>
   <td>negation/increment</td>
   <td><code>! ~ - + ++ -- typeof void delete</code></td>
  </tr>
  <tr>
   <td>multiply/divide</td>
   <td><code>* / %</code></td>
  </tr>
  <tr>
   <td>addition/subtraction</td>
   <td><code>+ -</code></td>
  </tr>
  <tr>
   <td>bitwise shift</td>
   <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
  </tr>
  <tr>
   <td>relational</td>
   <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
  </tr>
  <tr>
   <td>equality</td>
   <td><code>== != === !==</code></td>
  </tr>
  <tr>
   <td>bitwise-and</td>
   <td><code>&amp;</code></td>
  </tr>
  <tr>
   <td>bitwise-xor</td>
   <td><code>^</code></td>
  </tr>
  <tr>
   <td>bitwise-or</td>
   <td><code>|</code></td>
  </tr>
  <tr>
   <td>logical-and</td>
   <td><code>&amp;&amp;</code></td>
  </tr>
  <tr>
   <td>logical-or</td>
   <td><code>||</code></td>
  </tr>
  <tr>
   <td>conditional</td>
   <td><code>?:</code></td>
  </tr>
  <tr>
   <td>assignment</td>
   <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=</code></td>
  </tr>
  <tr>
   <td>comma</td>
   <td><code>,</code></td>
  </tr>
 </tbody>
</table>

<p>A more detailed version of this table, complete with links to additional details about each operator, may be found in <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">JavaScript Reference</a>.</p>