<div>{{SpiderMonkeySidebar("Internals")}}</div>

<h2 id="Bytecode_Listing">Bytecode Listing</h2>

<p>This document is automatically generated from
<a href="http://dxr.mozilla.org/mozilla-central/source/js/src/vm/Opcodes.h">Opcodes.h</a> by
<a href="http://dxr.mozilla.org/mozilla-central/source/js/src/vm/make_opcode_doc.py">make_opcode_doc.py</a>.</p>

<h3 id="Constants">Constants</h3>
<dl>
<dt id="JSOP_UNDEFINED"><code>JSOP_UNDEFINED</code></dt>
<dd>
<div>Stack: ⇒ <code>undefined</code></div>
<p>Push <code>undefined</code>.</p>
</dd>

<dt id="JSOP_NULL"><code>JSOP_NULL</code></dt>
<dd>
<div>Stack: ⇒ <code>null</code></div>
<p>Push <code>null</code>.</p>
</dd>

<dt id="JSOP_FALSE"><code>JSOP_FALSE</code>, <code>JSOP_TRUE</code></dt>
<dd>
<div>Stack: ⇒ <code>true/false</code></div>
<p>Push a boolean constant.</p>
</dd>

<dt id="JSOP_INT32"><code>JSOP_INT32</code></dt>
<dd>
<div>Operands: <code>(int32_t val)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the <code>int32_t</code> immediate operand as an <code>Int32Value</code>.</p>
<p><code>JSOP_ZERO</code>, <code>JSOP_ONE</code>, <code>JSOP_INT8</code>, <code>JSOP_UINT16</code>, and <code>JSOP_UINT24</code>
are all compact encodings for <code>JSOP_INT32</code>.</p>
</dd>

<dt id="JSOP_ZERO"><code>JSOP_ZERO</code></dt>
<dd>
<div>Stack: ⇒ <code>0</code></div>
<p>Push the number <code>0</code>.</p>
</dd>

<dt id="JSOP_ONE"><code>JSOP_ONE</code></dt>
<dd>
<div>Stack: ⇒ <code>1</code></div>
<p>Push the number <code>1</code>.</p>
</dd>

<dt id="JSOP_INT8"><code>JSOP_INT8</code></dt>
<dd>
<div>Operands: <code>(int8_t val)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the <code>int8_t</code> immediate operand as an <code>Int32Value</code>.</p>
</dd>

<dt id="JSOP_UINT16"><code>JSOP_UINT16</code></dt>
<dd>
<div>Operands: <code>(uint16_t val)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the <code>uint16_t</code> immediate operand as an <code>Int32Value</code>.</p>
</dd>

<dt id="JSOP_UINT24"><code>JSOP_UINT24</code></dt>
<dd>
<div>Operands: <code>(uint24_t val)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the <code>uint24_t</code> immediate operand as an <code>Int32Value</code>.</p>
</dd>

<dt id="JSOP_DOUBLE"><code>JSOP_DOUBLE</code></dt>
<dd>
<div>Operands: <code>(double val)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the 64-bit floating-point immediate operand as a <code>DoubleValue</code>.</p>
<p>If the operand is a NaN, it must be the canonical NaN (see
<code>JS::detail::CanonicalizeNaN</code>).</p>
</dd>

<dt id="JSOP_BIGINT"><code>JSOP_BIGINT</code></dt>
<dd>
<div>Operands: <code>(uint32_t bigIntIndex)</code></div>
<div>Stack: ⇒ <code>bigint</code></div>
<p>Push the BigInt constant <code>script-&gt;getBigInt(bigIntIndex)</code>.</p>
</dd>

<dt id="JSOP_STRING"><code>JSOP_STRING</code></dt>
<dd>
<div>Operands: <code>(uint32_t atomIndex)</code></div>
<div>Stack: ⇒ <code>string</code></div>
<p>Push the string constant <code>script-&gt;getAtom(atomIndex)</code>.</p>
<div>Flags: JOF_ATOM</div>
</dd>

<dt id="JSOP_SYMBOL"><code>JSOP_SYMBOL</code></dt>
<dd>
<div>Operands: <code>(uint8_t symbol (the JS::SymbolCode of the symbol to use))</code></div>
<div>Stack: ⇒ <code>symbol</code></div>
<p>Push a well-known symbol.</p>
<p><code>symbol</code> must be in range for <code>JS::SymbolCode</code>.</p>
</dd>

</dl>
<h3 id="Expressions">Expressions</h3>
<h4 id="Unary_operators">Unary operators</h4>
<dl>
<dt id="JSOP_VOID"><code>JSOP_VOID</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>undefined</code></div>
<p>Pop the top value on the stack, discard it, and push <code>undefined</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-void-operator">The <code>void</code> operator</a>, step 3.</p>
</dd>

<dt id="JSOP_TYPEOF"><code>JSOP_TYPEOF</code>, <code>JSOP_TYPEOFEXPR</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>(typeof val)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-typeof-operator">The <code>typeof</code> operator</a>.</p>
<p>Infallible. The result is always a string that depends on the <a href="https://tc39.es/ecma262/#sec-ecmascript-language-types">type</a>
of <code>val</code>.</p>
<p><code>JSOP_TYPEOF</code> and <code>JSOP_TYPEOFEXPR</code> are the same except
that--amazingly--<code>JSOP_TYPEOF</code> affects the behavior of an immediately
<em>preceding</em> <code>JSOP_GETNAME</code> or <code>JSOP_GETGNAME</code> instruction! This is how
we implement <a href="https://tc39.es/ecma262/#sec-typeof-operator"><code>typeof</code></a> step 2, making <code>typeof nonExistingVariable</code>
return <code>"undefined"</code> instead of throwing a ReferenceError.</p>
<p>In a global scope:</p>
<ul>
<li><code>typeof x</code> compiles to <code>GETGNAME "x"; TYPEOF</code>.</li>
<li><code>typeof (0, x)</code> compiles to <code>GETGNAME "x"; TYPEOFEXPR</code>.</li>
</ul>
<p>Emitting the same bytecode for these two expressions would be a bug.
Per spec, the latter throws a ReferenceError if <code>x</code> doesn't exist.</p>
<div>Flags: JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_POS"><code>JSOP_POS</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>(+val)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-unary-plus-operator">The unary <code>+</code> operator</a>.</p>
<p><code>+val</code> doesn't do any actual math. It just calls <a href="https://tc39.es/ecma262/#sec-tonumber">ToNumber</a>(val).</p>
<p>The conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can
throw. The result on success is always a Number. (Per spec, unary <code>-</code>
supports BigInts, but unary <code>+</code> does not.)</p>
</dd>

<dt id="JSOP_NEG"><code>JSOP_NEG</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>(-val)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-unary-minus-operator">The unary <code>-</code> operator</a>.</p>
<p>Convert <code>val</code> to a numeric value, then push <code>-val</code>. The conversion can
call <code>.toString()</code>/<code>.valueOf()</code> methods and can throw. The result on
success is always numeric.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_BITNOT"><code>JSOP_BITNOT</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>(~val)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-bitwise-not-operator">The bitwise NOT operator</a> (<code>~</code>).</p>
<p><code>val</code> is converted to an integer, then bitwise negated. The conversion
can call <code>.toString()</code>/<code>.valueOf()</code> methods and can throw. The result on
success is always an Int32 or BigInt value.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_NOT"><code>JSOP_NOT</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>(!val)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-logical-not-operator">The logical NOT operator</a> (<code>!</code>).</p>
<p><code>val</code> is first converted with <a href="https://tc39.es/ecma262/#sec-toboolean">ToBoolean</a>, then logically
negated. The result is always a boolean value. This does not call
user-defined methods and can't throw.</p>
<div>Flags: JOF_DETECTING, JOF_IC</div>
</dd>

</dl>
<h4 id="Binary_operators">Binary operators</h4>
<dl>
<dt id="JSOP_BITOR"><code>JSOP_BITOR</code>, <code>JSOP_BITXOR</code>, <code>JSOP_BITAND</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval OP rval)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-binary-bitwise-operators">Binary bitwise operations</a> (<code>|</code>, <code>^</code>, <code>&amp;</code>).</p>
<p>The arguments are converted to integers first. The conversion can call
<code>.toString()</code>/<code>.valueOf()</code> methods and can throw. The result on success
is always an Int32 or BigInt Value.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_EQ"><code>JSOP_EQ</code>, <code>JSOP_NE</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval OP rval)</code></div>
<p>Loose equality operators (<code>==</code> and <code>!=</code>).</p>
<p>Pop two values, compare them, and push the boolean result. The
comparison may perform conversions that call <code>.toString()</code>/<code>.valueOf()</code>
methods and can throw.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-abstract-equality-comparison">Abstract Equality Comparison</a>.</p>
<div>Flags: JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTEQ"><code>JSOP_STRICTEQ</code>, <code>JSOP_STRICTNE</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval OP rval)</code></div>
<p>Strict equality operators (<code>===</code> and <code>!==</code>).</p>
<p>Pop two values, check whether they're equal, and push the boolean
result. This does not call user-defined methods and can't throw
(except possibly due to OOM while flattening a string).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-strict-equality-comparison">Strict Equality Comparison</a>.</p>
<div>Flags: JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_LT"><code>JSOP_LT</code>, <code>JSOP_GT</code>, <code>JSOP_LE</code>, <code>JSOP_GE</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval OP rval)</code></div>
<p>Relative operators (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>).</p>
<p>Pop two values, compare them, and push the boolean result. The
comparison may perform conversions that call <code>.toString()</code>/<code>.valueOf()</code>
methods and can throw.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-relational-operators-runtime-semantics-evaluation">Relational Operators: Evaluation</a>.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_INSTANCEOF"><code>JSOP_INSTANCEOF</code></dt>
<dd>
<div>Stack: <code>value, target</code> ⇒ <code>(value instanceof target)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-instanceofoperator">The <code>instanceof</code> operator</a>.</p>
<p>This throws a <code>TypeError</code> if <code>target</code> is not an object. It calls
<code>target[Symbol.hasInstance](value)</code> if the method exists. On success,
the result is always a boolean value.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_IN"><code>JSOP_IN</code></dt>
<dd>
<div>Stack: <code>id, obj</code> ⇒ <code>(id in obj)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-relational-operators-runtime-semantics-evaluation">The <code>in</code> operator</a>.</p>
<p>Push <code>true</code> if <code>obj</code> has a property with the key <code>id</code>. Otherwise push <code>false</code>.</p>
<p>This throws a <code>TypeError</code> if <code>obj</code> is not an object. This can fire
proxy hooks and can throw. On success, the result is always a boolean
value.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_LSH"><code>JSOP_LSH</code>, <code>JSOP_RSH</code>, <code>JSOP_URSH</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval OP rval)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-bitwise-shift-operators">Bitwise shift operators</a> (<code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>).</p>
<p>Pop two values, convert them to integers, perform a bitwise shift, and
push the result.</p>
<p>Conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can throw.
The result on success is always an Int32 or BigInt Value.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_ADD"><code>JSOP_ADD</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval + rval)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-addition-operator-plus-runtime-semantics-evaluation">The binary <code>+</code> operator</a>.</p>
<p>Pop two values, convert them to primitive values, add them, and push the
result. If both values are numeric, add them; if either is a
string, do string concatenation instead.</p>
<p>The conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can throw.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_SUB"><code>JSOP_SUB</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval - rval)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-subtraction-operator-minus-runtime-semantics-evaluation">The binary <code>-</code> operator</a>.</p>
<p>Pop two values, convert them to numeric values, subtract the top value
from the other one, and push the result.</p>
<p>The conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can
throw. On success, the result is always numeric.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_INC"><code>JSOP_INC</code>, <code>JSOP_DEC</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>(val +/- 1)</code></div>
<p>Add or subtract 1.</p>
<p><code>val</code> must already be a numeric value, such as the result of
<code>JSOP_TONUMERIC</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-postfix-increment-operator">The <code>++</code> and <code>--</code> operators</a>, step 3 of each algorithm.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_MUL"><code>JSOP_MUL</code>, <code>JSOP_DIV</code>, <code>JSOP_MOD</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval OP rval)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-multiplicative-operators-runtime-semantics-evaluation">The multiplicative operators</a> (<code>*</code>, <code>/</code>, <code>%</code>).</p>
<p>Pop two values, convert them to numeric values, do math, and push the
result.</p>
<p>The conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can
throw. On success, the result is always numeric.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_POW"><code>JSOP_POW</code></dt>
<dd>
<div>Stack: <code>lval, rval</code> ⇒ <code>(lval ** rval)</code></div>
<p><a href="https://tc39.es/ecma262/#sec-exp-operator">The exponentiation operator</a> (<code>**</code>).</p>
<p>Pop two values, convert them to numeric values, do exponentiation, and
push the result. The top value is the exponent.</p>
<p>The conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can
throw. This throws a RangeError if both values are BigInts and the
exponent is negative.</p>
<div>Flags: JOF_IC</div>
</dd>

</dl>
<h4 id="Conversions">Conversions</h4>
<dl>
<dt id="JSOP_TOID"><code>JSOP_TOID</code></dt>
<dd>
<div>Stack: <code>propertyNameValue</code> ⇒ <code>propertyKey</code></div>
<p>Convert a value to a property key.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-topropertykey">ToPropertyKey</a>, except that if the result would be the
string representation of some integer in the range 0..2^31, we push the
corresponding Int32 value instead. This is because the spec insists that
array indices are strings, whereas for us they are integers.</p>
<p>This is used for code like <code>++obj[index]</code>, which must do both a
<code>JSOP_GETELEM</code> and a <code>JSOP_SETELEM</code> with the same property key. Both
instructions would convert <code>index</code> to a property key for us, but the
spec says to convert it only once.</p>
<p>The conversion can call <code>.toString()</code>/<code>.valueOf()</code> methods and can
throw.</p>
</dd>

<dt id="JSOP_TONUMERIC"><code>JSOP_TONUMERIC</code>, <code>JSOP_TOSTRING</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>ToNumeric(val)</code></div>
<p>Convert a value to a numeric value (a Number or BigInt).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-tonumeric">ToNumeric</a>(val).</p>
<p>Note: This is used to implement <a href="https://tc39.es/ecma262/#sec-postfix-increment-operator"><code>++</code> and <code>--</code></a>. Surprisingly, it's
not possible to get the right behavior using <code>JSOP_ADD</code> and <code>JSOP_SUB</code>
alone. For one thing, <code>JSOP_ADD</code> sometimes does string concatenation,
while <code>++</code> always does numeric addition. More fundamentally, the result
of evaluating <code>--x</code> is ToNumeric(old value of <code>x</code>), a value that the
sequence <code>GETLOCAL "x"; ONE; SUB; SETLOCAL "x"</code> does not give us.</p>
</dd>

</dl>
<h4 id="Other_expressions">Other expressions</h4>
<dl>
<dt id="JSOP_GLOBALTHIS"><code>JSOP_GLOBALTHIS</code></dt>
<dd>
<div>Stack: ⇒ <code>this</code></div>
<p>Push the global <code>this</code> value. Not to be confused with the <code>globalThis</code>
property on the global.</p>
<p>This must be used only in scopes where <code>this</code> refers to the global
<code>this</code>.</p>
</dd>

<dt id="JSOP_NEWTARGET"><code>JSOP_NEWTARGET</code></dt>
<dd>
<div>Stack: ⇒ <code>new.target</code></div>
<p>Push the value of <code>new.target</code>.</p>
<p>The result is a constructor or <code>undefined</code>.</p>
<p>This must be used only in scripts where <code>new.target</code> is allowed:
non-arrow function scripts and other scripts that have a non-arrow
function script on the scope chain.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getnewtarget">GetNewTarget</a>.</p>
</dd>

<dt id="JSOP_DYNAMIC_IMPORT"><code>JSOP_DYNAMIC_IMPORT</code></dt>
<dd>
<div>Stack: <code>moduleId</code> ⇒ <code>promise</code></div>
<p>Dynamic import of the module specified by the string value on the top of
the stack.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-import-calls">Import Calls</a>.</p>
</dd>

<dt id="JSOP_IMPORTMETA"><code>JSOP_IMPORTMETA</code></dt>
<dd>
<div>Stack: ⇒ <code>import.meta</code></div>
<p>Push the <code>import.meta</code> object.</p>
<p>This must be used only in module code.</p>
</dd>

</dl>
<h3 id="Objects">Objects</h3>
<h4 id="Creating_objects">Creating objects</h4>
<dl>
<dt id="JSOP_NEWINIT"><code>JSOP_NEWINIT</code></dt>
<dd>
<div>Operands: <code>(uint32_t _unused)</code></div>
<div>Stack: ⇒ <code>obj</code></div>
<p>Create and push a new object with no properties.</p>
<p>(This opcode has 4 unused bytes so it can be easily turned into
<code>JSOP_NEWOBJECT</code> during bytecode generation.)</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_NEWOBJECT"><code>JSOP_NEWOBJECT</code>, <code>JSOP_NEWOBJECT_WITHGROUP</code></dt>
<dd>
<div>Operands: <code>(uint32_t baseobjIndex)</code></div>
<div>Stack: ⇒ <code>obj</code></div>
<p>Create and push a new object of a predetermined shape.</p>
<p>The new object has the shape of the template object
<code>script-&gt;getObject(baseobjIndex)</code>. Subsequent <code>INITPROP</code> instructions
must fill in all slots of the new object before it is used in any other
way.</p>
<p>For <code>JSOP_NEWOBJECT</code>, the new object has a group based on the allocation
site (or a new group if the template's group is a singleton). For
<code>JSOP_NEWOBJECT_WITHGROUP</code>, the new object has the same group as the
template object.</p>
<div>Flags: JOF_OBJECT, JOF_IC</div>
</dd>

<dt id="JSOP_OBJECT"><code>JSOP_OBJECT</code></dt>
<dd>
<div>Operands: <code>(uint32_t objectIndex)</code></div>
<div>Stack: ⇒ <code>obj</code></div>
<p>Push a preconstructed object.</p>
<p>Going one step further than <code>JSOP_NEWOBJECT</code>, this instruction doesn't
just reuse the shape--it actually pushes the preconstructed object
<code>script-&gt;getObject(objectIndex)</code> right onto the stack. The object must
be a singleton <code>PlainObject</code> or <code>ArrayObject</code>.</p>
<p>The spec requires that an <em>ObjectLiteral</em> or <em>ArrayLiteral</em> creates a
new object every time it's evaluated, so this instruction must not be
used anywhere it might be executed more than once.</p>
<p>There's a shell-only option, <code>newGlobal({cloneSingletons: true})</code>, that
makes this instruction do a deep copy of the object. A few tests use it.</p>
<div>Flags: JOF_OBJECT</div>
</dd>

<dt id="JSOP_OBJWITHPROTO"><code>JSOP_OBJWITHPROTO</code></dt>
<dd>
<div>Stack: <code>proto</code> ⇒ <code>obj</code></div>
<p>Create and push a new ordinary object with the provided [[Prototype]].</p>
<p>This is used to create the <code>.prototype</code> object for derived classes.</p>
</dd>

</dl>
<h4 id="Defining_properties">Defining properties</h4>
<dl>
<dt id="JSOP_INITPROP"><code>JSOP_INITPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, val</code> ⇒ <code>obj</code></div>
<p>Define a data property on an object.</p>
<p><code>obj</code> must be an object.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a> as used in
<a href="https://tc39.es/ecma262/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation">PropertyDefinitionEvaluation</a> of regular and shorthand
<em>PropertyDefinition</em>s.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPINIT, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_INITHIDDENPROP"><code>JSOP_INITHIDDENPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, val</code> ⇒ <code>obj</code></div>
<p>Like <code>JSOP_INITPROP</code>, but define a non-enumerable property.</p>
<p>This is used to define class methods.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-method-definitions-runtime-semantics-propertydefinitionevaluation">PropertyDefinitionEvaluation</a> for methods, steps 3 and
4, when <em>enumerable</em> is false.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPINIT, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_INITLOCKEDPROP"><code>JSOP_INITLOCKEDPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, val</code> ⇒ <code>obj</code></div>
<p>Like <code>JSOP_INITPROP</code>, but define a non-enumerable, non-writable,
non-configurable property.</p>
<p>This is used to define the <code>.prototype</code> property on classes.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-makeconstructor">MakeConstructor</a>, step 8, when <em>writablePrototype</em> is
false.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPINIT, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_INITELEM"><code>JSOP_INITELEM</code>, <code>JSOP_INITHIDDENELEM</code></dt>
<dd>
<div>Stack: <code>obj, id, val</code> ⇒ <code>obj</code></div>
<p>Define a data property on <code>obj</code> with property key <code>id</code> and value <code>val</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-createdatapropertyorthrow">CreateDataPropertyOrThrow</a>. This instruction is used for
object literals like <code>{0: val}</code> and <code>{[id]: val}</code>, and methods like
<code>*[Symbol.iterator]() {}</code>.</p>
<p><code>JSOP_INITHIDDENELEM</code> is the same but defines a non-enumerable property,
for class methods.</p>
<div>Flags: JOF_ELEM, JOF_PROPINIT, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_INITPROP_GETTER"><code>JSOP_INITPROP_GETTER</code>, <code>JSOP_INITHIDDENPROP_GETTER</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, getter</code> ⇒ <code>obj</code></div>
<p>Define an accessor property on <code>obj</code> with the given <code>getter</code>.
<code>nameIndex</code> gives the property name.</p>
<p><code>JSOP_INITHIDDENPROP_GETTER</code> is the same but defines a non-enumerable
property, for getters in classes.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPINIT, JOF_DETECTING</div>
</dd>

<dt id="JSOP_INITELEM_GETTER"><code>JSOP_INITELEM_GETTER</code>, <code>JSOP_INITHIDDENELEM_GETTER</code></dt>
<dd>
<div>Stack: <code>obj, id, getter</code> ⇒ <code>obj</code></div>
<p>Define an accessor property on <code>obj</code> with property key <code>id</code> and the given <code>getter</code>.</p>
<p>This is used to implement getters like <code>get [id]() {}</code> or <code>get 0() {}</code>.</p>
<p><code>JSOP_INITHIDDENELEM_GETTER</code> is the same but defines a non-enumerable
property, for getters in classes.</p>
<div>Flags: JOF_ELEM, JOF_PROPINIT, JOF_DETECTING</div>
</dd>

<dt id="JSOP_INITPROP_SETTER"><code>JSOP_INITPROP_SETTER</code>, <code>JSOP_INITHIDDENPROP_SETTER</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, setter</code> ⇒ <code>obj</code></div>
<p>Define an accessor property on <code>obj</code> with the given <code>setter</code>.</p>
<p>This is used to implement ordinary setters like <code>set foo(v) {}</code>.</p>
<p><code>JSOP_INITHIDDENPROP_SETTER</code> is the same but defines a non-enumerable
property, for setters in classes.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPINIT, JOF_DETECTING</div>
</dd>

<dt id="JSOP_INITELEM_SETTER"><code>JSOP_INITELEM_SETTER</code>, <code>JSOP_INITHIDDENELEM_SETTER</code></dt>
<dd>
<div>Stack: <code>obj, id, setter</code> ⇒ <code>obj</code></div>
<p>Define an accesssor property on <code>obj</code> with property key <code>id</code> and the
given <code>setter</code>.</p>
<p>This is used to implement setters with computed property keys or numeric
keys.</p>
<p><code>JSOP_INITHIDDENELEM_SETTER</code> is the same but defines a non-enumerable
property, for setters in classes.</p>
<div>Flags: JOF_ELEM, JOF_PROPINIT, JOF_DETECTING</div>
</dd>

</dl>
<h4 id="Accessing_properties">Accessing properties</h4>
<dl>
<dt id="JSOP_GETPROP"><code>JSOP_GETPROP</code>, <code>JSOP_CALLPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj</code> ⇒ <code>obj[name]</code></div>
<p>Get the value of the property <code>obj.name</code>. This can call getters and
proxy traps.</p>
<p><code>JSOP_CALLPROP</code> is exactly like <code>JSOP_GETPROP</code> but hints to the VM that we're
getting a method in order to call it.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getv">GetV</a>, <a href="https://tc39.es/ecma262/#sec-getvalue">GetValue</a> step 5.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_GETELEM"><code>JSOP_GETELEM</code>, <code>JSOP_CALLELEM</code></dt>
<dd>
<div>Stack: <code>obj, key</code> ⇒ <code>obj[key]</code></div>
<p>Get the value of the property <code>obj[key]</code>.</p>
<p><code>JSOP_CALLELEM</code> is exactly like <code>JSOP_GETELEM</code> but hints to the VM that
we're getting a method in order to call it.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getv">GetV</a>, <a href="https://tc39.es/ecma262/#sec-getvalue">GetValue</a> step 5.</p>
<div>Flags: JOF_ELEM, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_LENGTH"><code>JSOP_LENGTH</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj</code> ⇒ <code>obj.length</code></div>
<p>Push the value of <code>obj.length</code>.</p>
<p><code>nameIndex</code> must be the index of the atom <code>"length"</code>. This then behaves
exactly like <code>JSOP_GETPROP</code>.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_SETPROP"><code>JSOP_SETPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, val</code> ⇒ <code>val</code></div>
<p>Non-strict assignment to a property, <code>obj.name = val</code>.</p>
<p>This throws a TypeError if <code>obj</code> is null or undefined. If it's a
primitive value, the property is set on ToObject(<code>obj</code>), typically with
no effect.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-putvalue">PutValue</a> step 6 for non-strict code.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSLOPPY, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTSETPROP"><code>JSOP_STRICTSETPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_SETPROP</code>, but for strict mode code. Throw a TypeError if
<code>obj[key]</code> exists but is non-writable, if it's an accessor property with
no setter, or if <code>obj</code> is a primitive value.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSTRICT, JOF_IC</div>
</dd>

<dt id="JSOP_SETELEM"><code>JSOP_SETELEM</code></dt>
<dd>
<div>Stack: <code>obj, key, val</code> ⇒ <code>val</code></div>
<p>Non-strict assignment to a property, <code>obj[key] = val</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-putvalue">PutValue</a> step 6 for non-strict code.</p>
<div>Flags: JOF_ELEM, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSLOPPY, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTSETELEM"><code>JSOP_STRICTSETELEM</code></dt>
<dd>
<div>Stack: <code>obj, key, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_SETELEM</code>, but for strict mode code. Throw a TypeError if
<code>obj[key]</code> exists but is non-writable, if it's an accessor property with
no setter, or if <code>obj</code> is a primitive value.</p>
<div>Flags: JOF_ELEM, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSTRICT, JOF_IC</div>
</dd>

<dt id="JSOP_DELPROP"><code>JSOP_DELPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj</code> ⇒ <code>succeeded</code></div>
<p>Delete a property from <code>obj</code>. Push true on success, false if the
property existed but could not be deleted. This implements <code>delete
obj.name</code> in non-strict code.</p>
<p>Throws if <code>obj</code> is null or undefined. Can call proxy traps.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation"><code>delete obj.propname</code></a> step 5 in non-strict code.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_CHECKSLOPPY</div>
</dd>

<dt id="JSOP_STRICTDELPROP"><code>JSOP_STRICTDELPROP</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>obj</code> ⇒ <code>succeeded</code></div>
<p>Like <code>JSOP_DELPROP</code>, but for strict mode code. Push <code>true</code> on success,
else throw a TypeError.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_CHECKSTRICT</div>
</dd>

<dt id="JSOP_DELELEM"><code>JSOP_DELELEM</code></dt>
<dd>
<div>Stack: <code>obj, key</code> ⇒ <code>succeeded</code></div>
<p>Delete the property <code>obj[key]</code> and push <code>true</code> on success, <code>false</code>
if the property existed but could not be deleted.</p>
<p>This throws if <code>obj</code> is null or undefined. Can call proxy traps.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation"><code>delete obj[key]</code></a> step 5 in non-strict code.</p>
<div>Flags: JOF_ELEM, JOF_CHECKSLOPPY</div>
</dd>

<dt id="JSOP_STRICTDELELEM"><code>JSOP_STRICTDELELEM</code></dt>
<dd>
<div>Stack: <code>obj, key</code> ⇒ <code>succeeded</code></div>
<p>Like <code>JSOP_DELELEM, but for strict mode code. Push</code>true` on success,
else throw a TypeError.</p>
<div>Flags: JOF_ELEM, JOF_CHECKSTRICT</div>
</dd>

<dt id="JSOP_HASOWN"><code>JSOP_HASOWN</code></dt>
<dd>
<div>Stack: <code>id, obj</code> ⇒ <code>(obj.hasOwnProperty(id))</code></div>
<p>Push true if <code>obj</code> has an own property <code>id</code>.</p>
<p>Note that <code>obj</code> is the top value, like <code>JSOP_IN</code>.</p>
<p>This opcode is not used for normal JS. Self-hosted code uses it by
calling the intrinsic <code>hasOwn(id, obj)</code>. For example,
<code>Object.prototype.hasOwnProperty</code> is implemented this way (see
js/src/builtin/Object.js).</p>
<div>Flags: JOF_IC</div>
</dd>

</dl>
<h4 id="Super">Super</h4>
<dl>
<dt id="JSOP_SUPERBASE"><code>JSOP_SUPERBASE</code></dt>
<dd>
<div>Stack: <code>callee</code> ⇒ <code>superBase</code></div>
<p>Push the SuperBase of the method <code>callee</code>. The SuperBase is
<code>callee.[[HomeObject]].[[GetPrototypeOf]]()</code>, the object where <code>super</code>
property lookups should begin.</p>
<p><code>callee</code> must be a function that has a HomeObject that's an object,
typically produced by <code>JSOP_CALLEE</code> or <code>JSOP_ENVCALLEE</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getsuperbase">GetSuperBase</a>, except that instead of the environment,
the argument supplies the callee.</p>
</dd>

<dt id="JSOP_GETPROP_SUPER"><code>JSOP_GETPROP_SUPER</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>receiver, obj</code> ⇒ <code>super.name</code></div>
<p>Get the value of <code>receiver.name</code>, starting the property search at <code>obj</code>.
In spec terms, <code>obj.[[Get]](name, receiver)</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getvalue">GetValue</a> for references created by <a href="https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation"><code>super.name</code></a>.
The <code>receiver</code> is <code>this</code> and <code>obj</code> is the SuperBase of the enclosing
method.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_GETELEM_SUPER"><code>JSOP_GETELEM_SUPER</code></dt>
<dd>
<div>Stack: <code>receiver, key, obj</code> ⇒ <code>super[key]</code></div>
<p>Get the value of <code>receiver[key]</code>, starting the property search at <code>obj</code>.
In spec terms, <code>obj.[[Get]](key, receiver)</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getvalue">GetValue</a> for references created by <a href="https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation"><code>super[key]</code></a>
(where the <code>receiver</code> is <code>this</code> and <code>obj</code> is the SuperBase of the enclosing
method); <a href="https://tc39.es/ecma262/#sec-reflect.get"><code>Reflect.get(obj, key, receiver)</code></a>.</p>
<div>Flags: JOF_ELEM, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_SETPROP_SUPER"><code>JSOP_SETPROP_SUPER</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>receiver, obj, val</code> ⇒ <code>val</code></div>
<p>Assign <code>val</code> to <code>receiver.name</code>, starting the search for an existing
property at <code>obj</code>. In spec terms, <code>obj.[[Set]](name, val, receiver)</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-putvalue">PutValue</a> for references created by <a href="https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation"><code>super.name</code></a> in
non-strict code. The <code>receiver</code> is <code>this</code> and <code>obj</code> is the SuperBase of
the enclosing method.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSLOPPY</div>
</dd>

<dt id="JSOP_STRICTSETPROP_SUPER"><code>JSOP_STRICTSETPROP_SUPER</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>receiver, obj, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_SETPROP_SUPER</code>, but for strict mode code.</p>
<div>Flags: JOF_ATOM, JOF_PROP, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSTRICT</div>
</dd>

<dt id="JSOP_SETELEM_SUPER"><code>JSOP_SETELEM_SUPER</code></dt>
<dd>
<div>Stack: <code>receiver, key, obj, val</code> ⇒ <code>val</code></div>
<p>Assign <code>val</code> to <code>receiver[key]</code>, strating the search for an existing
property at <code>obj</code>. In spec terms, <code>obj.[[Set]](key, val, receiver)</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-putvalue">PutValue</a> for references created by <a href="https://tc39.es/ecma262/#sec-super-keyword-runtime-semantics-evaluation"><code>super[key]</code></a> in
non-strict code. The <code>receiver</code> is <code>this</code> and <code>obj</code> is the SuperBase of
the enclosing method.</p>
<div>Flags: JOF_ELEM, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSLOPPY</div>
</dd>

<dt id="JSOP_STRICTSETELEM_SUPER"><code>JSOP_STRICTSETELEM_SUPER</code></dt>
<dd>
<div>Stack: <code>receiver, key, obj, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_SETELEM_SUPER</code>, but for strict mode code.</p>
<div>Flags: JOF_ELEM, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSTRICT</div>
</dd>

</dl>
<h4 id="Enumeration">Enumeration</h4>
<dl>
<dt id="JSOP_ITER"><code>JSOP_ITER</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>iter</code></div>
<p>Set up a for-in loop by pushing a <code>PropertyIteratorObject</code> over the
enumerable properties of <code>val</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">ForIn/OfHeadEvaluation</a> step 6,
<a href="https://tc39.es/ecma262/#sec-runtime-semantics-forin-div-ofheadevaluation-tdznames-expr-iterationkind">EnumerateObjectProperties</a>. (The spec refers to an "Iterator object"
with a <code>next</code> method, but notes that it "is never directly accessible"
to scripts. The object we use for this has no public methods.)</p>
<p>If <code>val</code> is null or undefined, this pushes an empty iterator.</p>
<p>The <code>iter</code> object pushed by this instruction must not be used or removed
from the stack except by <code>JSOP_MOREITER</code> and <code>JSOP_ENDITER</code>, or by error
handling.</p>
<p>The script's <code>JSScript::trynotes()</code> must mark the body of the <code>for-in</code>
loop, i.e. exactly those instructions that begin executing with <code>iter</code>
on the stack, starting with the next instruction (always
<code>JSOP_LOOPHEAD</code>). Code must not jump into or out of this region: control
can enter only by executing <code>JSOP_ITER</code> and can exit only by executing a
<code>JSOP_ENDITER</code> or by exception unwinding. (A <code>JSOP_ENDITER</code> is always
emitted at the end of the loop, and extra copies are emitted on "exit
slides", where a <code>break</code>, <code>continue</code>, or <code>return</code> statement exits the
loop.)</p>
<p>Typically a single try note entry marks the contiguous chunk of bytecode
from the instruction after <code>JSOP_ITER</code> to <code>JSOP_ENDITER</code> (inclusive);
but if that range contains any instructions on exit slides, after a
<code>JSOP_ENDITER</code>, then those must be correctly noted as <em>outside</em> the
loop.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_MOREITER"><code>JSOP_MOREITER</code></dt>
<dd>
<div>Stack: <code>iter</code> ⇒ <code>iter, name</code></div>
<p>Get the next property name for a for-in loop.</p>
<p><code>iter</code> must be a <code>PropertyIteratorObject</code> produced by <code>JSOP_ITER</code>.  This
pushes the property name for the next loop iteration, or
<code>MagicValue(JS_NO_ITER_VALUE)</code> if there are no more enumerable
properties to iterate over. The magic value must be used only by
<code>JSOP_ISNOITER</code> and <code>JSOP_ENDITER</code>.</p>
</dd>

<dt id="JSOP_ISNOITER"><code>JSOP_ISNOITER</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>val, done</code></div>
<p>Test whether the value on top of the stack is
<code>MagicValue(JS_NO_ITER_VALUE)</code> and push the boolean result.</p>
</dd>

<dt id="JSOP_ITERNEXT"><code>JSOP_ITERNEXT</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>No-op instruction to hint to IonBuilder that the value on top of the
stack is the (likely string) key in a for-in loop.</p>
</dd>

<dt id="JSOP_ENDITER"><code>JSOP_ENDITER</code></dt>
<dd>
<div>Stack: <code>iter, iterval</code> ⇒</div>
<p>Exit a for-in loop, closing the iterator.</p>
<p><code>iter</code> must be a <code>PropertyIteratorObject</code> pushed by <code>JSOP_ITER</code>.</p>
</dd>

</dl>
<h4 id="Iteration">Iteration</h4>
<dl>
<dt id="JSOP_CHECKISOBJ"><code>JSOP_CHECKISOBJ</code></dt>
<dd>
<div>Operands: <code>(uint8_t kind)</code></div>
<div>Stack: <code>result</code> ⇒ <code>result</code></div>
<p>Check that the top value on the stack is an object, and throw a
TypeError if not. <code>kind</code> is used only to generate an appropriate error
message. It must be in range for <code>js::CheckIsObjectKind</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getiterator">GetIterator</a> step 5, <a href="https://tc39.es/ecma262/#sec-iteratornext">IteratorNext</a> step 3. Both
operations call a JS method which scripts can define however they want,
so they check afterwards that the method returned an object.</p>
</dd>

<dt id="JSOP_CHECKISCALLABLE"><code>JSOP_CHECKISCALLABLE</code></dt>
<dd>
<div>Operands: <code>(uint8_t kind)</code></div>
<div>Stack: <code>obj</code> ⇒ <code>obj</code></div>
<p>Check that the top value on the stack is callable, and throw a TypeError
if not. The operand <code>kind</code> is used only to generate an appropriate error
message. It must be in range for <code>js::CheckIsCallableKind</code>.</p>
</dd>

<dt id="JSOP_CHECKOBJCOERCIBLE"><code>JSOP_CHECKOBJCOERCIBLE</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>Throw a TypeError if <code>val</code> is <code>null</code> or <code>undefined</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-requireobjectcoercible">RequireObjectCoercible</a>. But most instructions that
require an object will perform this check for us, so of the dozens of
calls to RequireObjectCoercible in the spec, we need this instruction
only for <a href="https://tc39.es/ecma262/#sec-runtime-semantics-destructuringassignmentevaluation">destructuring assignment</a> and <a href="https://tc39.es/ecma262/#sec-destructuring-binding-patterns-runtime-semantics-bindinginitialization">initialization</a>.</p>
</dd>

<dt id="JSOP_TOASYNCITER"><code>JSOP_TOASYNCITER</code></dt>
<dd>
<div>Stack: <code>iter, next</code> ⇒ <code>asynciter</code></div>
<p>Create and push an async iterator wrapping the sync iterator <code>iter</code>.
<code>next</code> should be <code>iter</code>'s <code>.next</code> method.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-createasyncfromsynciterator">CreateAsyncToSyncIterator</a>. The spec says this operation
takes one argument, but that argument is a Record with two relevant
fields, <code>[[Iterator]]</code> and <code>[[NextMethod]]</code>.</p>
<p>Used for <code>for await</code> loops.</p>
</dd>

</dl>
<h4 id="SetPrototype">SetPrototype</h4>
<dl>
<dt id="JSOP_MUTATEPROTO"><code>JSOP_MUTATEPROTO</code></dt>
<dd>
<div>Stack: <code>obj, protoVal</code> ⇒ <code>obj</code></div>
<p>Set the prototype of <code>obj</code>.</p>
<p><code>obj</code> must be an object.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-__proto__-property-names-in-object-initializers">B.3.1 <strong>proto</strong> Property Names in Object Initializers</a>, step 7.a.</p>
</dd>

</dl>
<h4 id="Array_literals">Array literals</h4>
<dl>
<dt id="JSOP_NEWARRAY"><code>JSOP_NEWARRAY</code></dt>
<dd>
<div>Operands: <code>(uint32_t length)</code></div>
<div>Stack: ⇒ <code>array</code></div>
<p>Create and push a new Array object with the given <code>length</code>,
preallocating enough memory to hold that many elements.</p>
<div>Flags: JOF_IC</div>
</dd>

<dt id="JSOP_INITELEM_ARRAY"><code>JSOP_INITELEM_ARRAY</code></dt>
<dd>
<div>Operands: <code>(uint32_t index)</code></div>
<div>Stack: <code>array, val</code> ⇒ <code>array</code></div>
<p>Initialize an array element <code>array[index]</code> with value <code>val</code>.</p>
<p><code>val</code> may be <code>MagicValue(JS_ELEMENTS_HOLE)</code>. If it is, this does nothing.</p>
<p>This never calls setters or proxy traps.</p>
<p><code>array</code> must be an Array object created by <code>JSOP_NEWARRAY</code> with length &gt;
<code>index</code>, and never used except by <code>JSOP_INITELEM_ARRAY</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-runtime-semantics-arrayaccumulation">ArrayAccumulation</a>, the third algorithm, step 4, in the
common case where <em>nextIndex</em> is known.</p>
<div>Flags: JOF_ELEM, JOF_PROPINIT, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_INITELEM_INC"><code>JSOP_INITELEM_INC</code></dt>
<dd>
<div>Stack: <code>array, index, val</code> ⇒ <code>array, (index + 1)</code></div>
<p>Initialize an array element <code>array[index++]</code> with value <code>val</code>.</p>
<p><code>val</code> may be <code>MagicValue(JS_ELEMENTS_HOLE)</code>. If it is, no element is
defined, but the array length and the stack value <code>index</code> are still
incremented.</p>
<p>This never calls setters or proxy traps.</p>
<p><code>array</code> must be an Array object created by <code>JSOP_NEWARRAY</code> and never used
except by <code>JSOP_INITELEM_ARRAY</code> and <code>JSOP_INITELEM_INC</code>.</p>
<p><code>index</code> must be an integer, <code>0 &lt;= index &lt;= INT32_MAX</code>. If <code>index</code> is
<code>INT32_MAX</code>, this throws a RangeError.</p>
<p>This instruction is used when an array literal contains a
<em>SpreadElement</em>. In <code>[a, ...b, c]</code>, <code>INITELEM_ARRAY 0</code> is used to put
<code>a</code> into the array, but <code>INITELEM_INC</code> is used for the elements of <code>b</code>
and for <code>c</code>.</p>
<p>Implements: Several steps in <a href="https://tc39.es/ecma262/#sec-runtime-semantics-arrayaccumulation">ArrayAccumulation</a> that call
CreateDataProperty, set the array length, and/or increment <em>nextIndex</em>.</p>
<div>Flags: JOF_ELEM, JOF_PROPINIT, JOF_IC</div>
</dd>

<dt id="JSOP_HOLE"><code>JSOP_HOLE</code></dt>
<dd>
<div>Stack: ⇒ <code>hole</code></div>
<p>Push <code>MagicValue(JS_ELEMENTS_HOLE)</code>, representing an <em>Elision</em> in an
array literal (like the missing property 0 in the array <code>[, 1]</code>).</p>
<p>This magic value must be used only by <code>JSOP_INITELEM_ARRAY</code> or
<code>JSOP_INITELEM_INC</code>.</p>
</dd>

<dt id="JSOP_NEWARRAY_COPYONWRITE"><code>JSOP_NEWARRAY_COPYONWRITE</code></dt>
<dd>
<div>Operands: <code>(uint32_t objectIndex)</code></div>
<div>Stack: ⇒ <code>array</code></div>
<p>Create and push a new array that shares the elements of a template
object.</p>
<p><code>script-&gt;getObject(objectIndex)</code> must be a copy-on-write array whose
elements are all primitive values.</p>
<p>This is an optimization. This single instruction implements an entire
array literal, saving run time, code, and memory compared to
<code>JSOP_NEWARRAY</code> and a series of <code>JSOP_INITELEM</code> instructions.</p>
<div>Flags: JOF_OBJECT</div>
</dd>

</dl>
<h4 id="RegExp_literals">RegExp literals</h4>
<dl>
<dt id="JSOP_REGEXP"><code>JSOP_REGEXP</code></dt>
<dd>
<div>Operands: <code>(uint32_t regexpIndex)</code></div>
<div>Stack: ⇒ <code>regexp</code></div>
<p>Clone and push a new RegExp object.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-regular-expression-literals-runtime-semantics-evaluation">Evaluation for <em>RegularExpressionLiteral</em></a>.</p>
</dd>

</dl>
<h3 id="Functions">Functions</h3>
<h4 id="Creating_functions">Creating functions</h4>
<dl>
<dt id="JSOP_LAMBDA"><code>JSOP_LAMBDA</code></dt>
<dd>
<div>Operands: <code>(uint32_t funcIndex)</code></div>
<div>Stack: ⇒ <code>fn</code></div>
<p>Push a function object.</p>
<p>This clones the function unless it's a singleton; see
<code>CanReuseFunctionForClone</code>. The new function inherits the current
environment chain.</p>
<p>Used to create most JS functions. Notable exceptions are arrow functions
and derived or default class constructors.</p>
<p>The function indicated by <code>funcIndex</code> must be a non-arrow function.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-instantiatefunctionobject">InstantiateFunctionObject</a>, <a href="https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-evaluation">Evaluation for
<em>FunctionExpression</em></a>, and so on.</p>
<div>Flags: JOF_OBJECT</div>
</dd>

<dt id="JSOP_LAMBDA_ARROW"><code>JSOP_LAMBDA_ARROW</code></dt>
<dd>
<div>Operands: <code>(uint32_t funcIndex)</code></div>
<div>Stack: <code>newTarget</code> ⇒ <code>arrowFn</code></div>
<p>Push a new arrow function.</p>
<p><code>newTarget</code> matters only if the arrow function uses the expression
<code>new.target</code>. It should be the current value of <code>new.target</code>, so that
the arrow function inherits <code>new.target</code> from the enclosing scope. (If
<code>new.target</code> is illegal here, the value doesn't matter; use <code>null</code>.)</p>
<p>The function indicated by <code>funcIndex</code> must be an arrow function.</p>
<div>Flags: JOF_OBJECT</div>
</dd>

<dt id="JSOP_SETFUNNAME"><code>JSOP_SETFUNNAME</code></dt>
<dd>
<div>Operands: <code>(uint8_t prefixKind)</code></div>
<div>Stack: <code>fun, name</code> ⇒ <code>fun</code></div>
<p>Set the name of a function.</p>
<p><code>fun</code> must be a function object. <code>name</code> must be a string, Int32 value,
or symbol (like the result of <code>JSOP_TOID</code>).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-setfunctionname">SetFunctionName</a>, used e.g. to name methods with
computed property names.</p>
</dd>

<dt id="JSOP_INITHOMEOBJECT"><code>JSOP_INITHOMEOBJECT</code></dt>
<dd>
<div>Stack: <code>fun, homeObject</code> ⇒ <code>fun</code></div>
<p>Initialize the home object for functions with super bindings.</p>
</dd>

</dl>
<h4 id="Creating_constructors">Creating constructors</h4>
<dl>
<dt id="JSOP_CHECKCLASSHERITAGE"><code>JSOP_CHECKCLASSHERITAGE</code></dt>
<dd>
<div>Stack: <code>baseClass</code> ⇒ <code>baseClass</code></div>
<p>Throw a TypeError if <code>baseClass</code> isn't either <code>null</code> or a constructor.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-runtime-semantics-classdefinitionevaluation">ClassDefinitionEvaluation</a> step 6.f.</p>
</dd>

<dt id="JSOP_FUNWITHPROTO"><code>JSOP_FUNWITHPROTO</code></dt>
<dd>
<div>Operands: <code>(uint32_t funcIndex)</code></div>
<div>Stack: <code>proto</code> ⇒ <code>obj</code></div>
<p>Like <code>JSOP_LAMBDA</code>, but using <code>proto</code> as the new function's
<code>[[Prototype]]</code> (or <code>%FunctionPrototype%</code> if <code>proto</code> is <code>null</code>).</p>
<p><code>proto</code> must be either a constructor or <code>null</code>. We use
<code>JSOP_CHECKCLASSHERITAGE</code> to check.</p>
<p>This is used to create the constructor for a derived class.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-runtime-semantics-classdefinitionevaluation">ClassDefinitionEvaluation</a> steps 6.e.ii, 6.g.iii, and
12 for derived classes.</p>
<div>Flags: JOF_OBJECT</div>
</dd>

<dt id="JSOP_CLASSCONSTRUCTOR"><code>JSOP_CLASSCONSTRUCTOR</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex, uint32_t sourceStart, uint32_t sourceEnd)</code></div>
<div>Stack: ⇒ <code>constructor</code></div>
<p>Create and push a default constructor for a base class.</p>
<p>A default constructor behaves like <code>constructor() {}</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-runtime-semantics-classdefinitionevaluation">ClassDefinitionEvaluation for <em>ClassTail</em></a>, steps
10.b. and 12-17.</p>
<p>The <code>sourceStart</code>/<code>sourceEnd</code> offsets are the start/end offsets of the
class definition in the source buffer and are used for <code>toString()</code>.</p>
<div>Flags: JOF_CLASS_CTOR</div>
</dd>

<dt id="JSOP_DERIVEDCONSTRUCTOR"><code>JSOP_DERIVEDCONSTRUCTOR</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex, uint32_t sourceStart, uint32_t sourceEnd)</code></div>
<div>Stack: <code>proto</code> ⇒ <code>constructor</code></div>
<p>Create and push a default constructor for a derived class.</p>
<p>A default derived-class constructor behaves like
<code>constructor(...args) { super(...args); }</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-runtime-semantics-classdefinitionevaluation">ClassDefinitionEvaluation for <em>ClassTail</em></a>, steps
10.a. and 12-17.</p>
<p>The <code>sourceStart</code>/<code>sourceEnd</code> offsets are the start/end offsets of the
class definition in the source buffer and are used for <code>toString()</code>.</p>
<div>Flags: JOF_CLASS_CTOR</div>
</dd>

<dt id="JSOP_BUILTINPROTO"><code>JSOP_BUILTINPROTO</code></dt>
<dd>
<div>Operands: <code>(uint8_t kind)</code></div>
<div>Stack: ⇒ <code>%BuiltinPrototype%</code></div>
<p>Pushes the current global's builtin prototype for a given proto key.</p>
</dd>

</dl>
<h4 id="Calls">Calls</h4>
<dl>
<dt id="JSOP_CALL"><code>JSOP_CALL</code>, <code>JSOP_CALLITER</code>, <code>JSOP_FUNAPPLY</code>, <code>JSOP_FUNCALL</code>, <code>JSOP_CALL_IGNORES_RV</code></dt>
<dd>
<div>Operands: <code>(uint16_t argc)</code></div>
<div>Stack: <code>callee, this, args[0], ..., args[argc-1]</code> ⇒ <code>rval</code></div>
<p>Invoke <code>callee</code> with <code>this</code> and <code>args</code>, and push the return value. Throw
a TypeError if <code>callee</code> isn't a function.</p>
<p><code>JSOP_CALLITER</code> is used for implicit calls to @@iterator methods, to
ensure error messages are formatted with <code>JSMSG_NOT_ITERABLE</code> ("x is not
iterable") rather than <code>JSMSG_NOT_FUNCTION</code> ("x[Symbol.iterator] is not
a function"). The <code>argc</code> operand must be 0 for this variation.</p>
<p><code>JSOP_FUNAPPLY</code> hints to the VM that this is likely a call to the
builtin method <code>Function.prototype.apply</code>, an easy optimization target.</p>
<p><code>JSOP_FUNCALL</code> similarly hints to the VM that the callee is likely
<code>Function.prototype.call</code>.</p>
<p><code>JSOP_CALL_IGNORES_RV</code> hints to the VM that the return value is ignored.
This allows alternate faster implementations to be used that avoid
unnecesary allocations.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-evaluatecall">EvaluateCall</a> steps 4, 5, and 7.</p>
<div>Flags: JOF_ARGC, JOF_INVOKE, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_SPREADCALL"><code>JSOP_SPREADCALL</code></dt>
<dd>
<div>Stack: <code>callee, this, args</code> ⇒ <code>rval</code></div>
<p>Like <code>JSOP_CALL</code>, but the arguments are provided in an array rather than
a span of stack slots. Used to implement spread-call syntax:
<code>f(...args)</code>.</p>
<p><code>args</code> must be an Array object containing the actual arguments. The
array must be packed (dense and free of holes; see IsPackedArray).
This can be ensured by creating the array with <code>JSOP_NEWARRAY</code> and
populating it using <code>JSOP_INITELEM_ARRAY</code>.</p>
<div>Flags: JOF_INVOKE, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_OPTIMIZE_SPREADCALL"><code>JSOP_OPTIMIZE_SPREADCALL</code></dt>
<dd>
<div>Stack: <code>arr</code> ⇒ <code>arr, optimized</code></div>
<p>Push true if <code>arr</code> is an array object that can be passed directly as the
<code>args</code> argument to <code>JSOP_SPREADCALL</code>.</p>
<p>This instruction and the branch around the iterator loop are emitted
only when <code>arr</code> is itself a rest parameter, as in <code>(...arr) =&gt;
f(...arr)</code>, a strong hint that it's a packed Array whose prototype is
<code>Array.prototype</code>.</p>
<p>See <code>js::OptimizeSpreadCall</code>.</p>
</dd>

<dt id="JSOP_EVAL"><code>JSOP_EVAL</code></dt>
<dd>
<div>Operands: <code>(uint16_t argc)</code></div>
<div>Stack: <code>callee, this, args[0], ..., args[argc-1]</code> ⇒ <code>rval</code></div>
<p>Perform a direct eval in the current environment if <code>callee</code> is the
builtin <code>eval</code> function, otherwise follow same behaviour as <code>JSOP_CALL</code>.</p>
<p>All direct evals use one of the JSOP_*EVAL operations here and these
opcodes are only used when the syntactic conditions for a direct eval
are met. If the builtin <code>eval</code> function is called though other means, it
becomes an indirect eval.</p>
<p>Direct eval causes all bindings in <em>enclosing</em> non-global scopes to be
marked "aliased". The optimization that puts bindings in stack slots has
to prove that the bindings won't need to be captured by closures or
accessed using <code>JSOP_{GET,BIND,SET,DEL}NAME</code> instructions. Direct eval
makes that analysis impossible.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-function-calls-runtime-semantics-evaluation">Function Call Evaluation</a>, steps 5-7 and 9, when the
syntactic critera for direct eval in step 6 are all met.</p>
<div>Flags: JOF_ARGC, JOF_INVOKE, JOF_TYPESET, JOF_CHECKSLOPPY, JOF_IC</div>
</dd>

<dt id="JSOP_SPREADEVAL"><code>JSOP_SPREADEVAL</code></dt>
<dd>
<div>Stack: <code>callee, this, args</code> ⇒ <code>rval</code></div>
<p>Spread-call variant of <code>JSOP_EVAL</code>.</p>
<p>See <code>JSOP_SPREADCALL</code> for restrictions on <code>args</code>.</p>
<div>Flags: JOF_INVOKE, JOF_TYPESET, JOF_CHECKSLOPPY, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTEVAL"><code>JSOP_STRICTEVAL</code></dt>
<dd>
<div>Operands: <code>(uint16_t argc)</code></div>
<div>Stack: <code>evalFn, this, args[0], ..., args[argc-1]</code> ⇒ <code>rval</code></div>
<p>Like <code>JSOP_EVAL</code>, but for strict mode code.</p>
<div>Flags: JOF_ARGC, JOF_INVOKE, JOF_TYPESET, JOF_CHECKSTRICT, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTSPREADEVAL"><code>JSOP_STRICTSPREADEVAL</code></dt>
<dd>
<div>Stack: <code>callee, this, args</code> ⇒ <code>rval</code></div>
<p>Spread-call variant of <code>JSOP_STRICTEVAL</code>.</p>
<p>See <code>JSOP_SPREADCALL</code> for restrictions on <code>args</code>.</p>
<div>Flags: JOF_INVOKE, JOF_TYPESET, JOF_CHECKSTRICT, JOF_IC</div>
</dd>

<dt id="JSOP_IMPLICITTHIS"><code>JSOP_IMPLICITTHIS</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>this</code></div>
<p>Push the implicit <code>this</code> value for an unqualified function call, like
<code>foo()</code>. <code>nameIndex</code> gives the name of the function we're calling.</p>
<p>The result is always <code>undefined</code> except when the name refers to a <code>with</code>
binding.  For example, in <code>with (date) { getFullYear(); }</code>, the
implicit <code>this</code> passed to <code>getFullYear</code> is <code>date</code>, not <code>undefined</code>.</p>
<p>This walks the run-time environment chain looking for the environment
record that contains the function. If the function call is not inside a
<code>with</code> statement, use <code>JSOP_GIMPLICITTHIS</code> instead. If the function call
definitely refers to a local binding, use <code>JSOP_UNDEFINED</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-evaluatecall">EvaluateCall</a> step 1.b. But not entirely correctly.
See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1166408">bug 1166408</a>.</p>
<div>Flags: JOF_ATOM</div>
</dd>

<dt id="JSOP_GIMPLICITTHIS"><code>JSOP_GIMPLICITTHIS</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>this</code></div>
<p>Like <code>JSOP_IMPLICITTHIS</code>, but the name must not be bound in any local
environments.</p>
<p>The result is always <code>undefined</code> except when the name refers to a
binding in a non-syntactic <code>with</code> environment.</p>
<p>Note: The frontend has to emit <code>JSOP_GIMPLICITTHIS</code> (and not
<code>JSOP_UNDEFINED</code>) for global unqualified function calls, even when
<code>CompileOptions::nonSyntacticScope == false</code>, because later
<code>js::CloneGlobalScript</code> can be called with <code>ScopeKind::NonSyntactic</code> to
clone the script into a non-syntactic environment, with the bytecode
reused, unchanged.</p>
<div>Flags: JOF_ATOM</div>
</dd>

<dt id="JSOP_CALLSITEOBJ"><code>JSOP_CALLSITEOBJ</code></dt>
<dd>
<div>Operands: <code>(uint32_t objectIndex)</code></div>
<div>Stack: ⇒ <code>callSiteObj</code></div>
<p>Push the call site object for a tagged template call.</p>
<p><code>script-&gt;getObject(objectIndex)</code> is the call site object;
<code>script-&gt;getObject(objectIndex + 1)</code> is the raw object.</p>
<p>The first time this instruction runs for a given template, it assembles
the final value, defining the <code>.raw</code> property on the call site object
and freezing both objects.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-gettemplateobject">GetTemplateObject</a>, steps 4 and 12-16.</p>
<div>Flags: JOF_OBJECT</div>
</dd>

<dt id="JSOP_IS_CONSTRUCTING"><code>JSOP_IS_CONSTRUCTING</code></dt>
<dd>
<div>Stack: ⇒ <code>JS_IS_CONSTRUCTING</code></div>
<p>Push <code>MagicValue(JS_IS_CONSTRUCTING)</code>.</p>
<p>This magic value is a required argument to the <code>JSOP_NEW</code> and
<code>JSOP_SUPERCALL</code> instructions and must not be used any other way.</p>
</dd>

<dt id="JSOP_NEW"><code>JSOP_NEW</code>, <code>JSOP_SUPERCALL</code></dt>
<dd>
<div>Operands: <code>(uint16_t argc)</code></div>
<div>Stack: <code>callee, isConstructing, args[0], ..., args[argc-1], newTarget</code> ⇒ <code>rval</code></div>
<p>Invoke <code>callee</code> as a constructor with <code>args</code> and <code>newTarget</code>, and push
the return value. Throw a TypeError if <code>callee</code> isn't a constructor.</p>
<p><code>isConstructing</code> must be the value pushed by <code>JSOP_IS_CONSTRUCTING</code>.</p>
<p><code>JSOP_SUPERCALL</code> behaves exactly like <code>JSOP_NEW</code>, but is used for
<em>SuperCall</em> expressions, to allow JITs to distinguish them from <code>new</code>
expressions.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-evaluatenew">EvaluateConstruct</a> steps 7 and 8.</p>
<div>Flags: JOF_ARGC, JOF_INVOKE, JOF_TYPESET, JOF_IC, JOF_IC</div>
</dd>

<dt id="JSOP_SPREADNEW"><code>JSOP_SPREADNEW</code>, <code>JSOP_SPREADSUPERCALL</code></dt>
<dd>
<div>Stack: <code>callee, isConstructing, args, newTarget</code> ⇒ <code>rval</code></div>
<p>Spread-call variant of <code>JSOP_NEW</code>.</p>
<p>Invokes <code>callee</code> as a constructor with <code>args</code> and <code>newTarget</code>, and
pushes the return value onto the stack.</p>
<p><code>isConstructing</code> must be the value pushed by <code>JSOP_IS_CONSTRUCTING</code>.
See <code>JSOP_SPREADCALL</code> for restrictions on <code>args</code>.</p>
<p><code>JSOP_SPREADSUPERCALL</code> behaves exactly like <code>JSOP_SPREADNEW</code>, but is
used for <em>SuperCall</em> expressions.</p>
<div>Flags: JOF_INVOKE, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_SUPERFUN"><code>JSOP_SUPERFUN</code></dt>
<dd>
<div>Stack: <code>callee</code> ⇒ <code>superFun</code></div>
<p>Push the prototype of <code>callee</code> in preparation for calling <code>super()</code>.
Throw a TypeError if that value is not a constructor.</p>
<p><code>callee</code> must be a derived class constructor.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getsuperconstructor">GetSuperConstructor</a>, steps 4-7.</p>
</dd>

<dt id="JSOP_CHECKTHISREINIT"><code>JSOP_CHECKTHISREINIT</code></dt>
<dd>
<div>Stack: <code>thisval</code> ⇒ <code>thisval</code></div>
<p>Throw a ReferenceError if <code>thisval</code> is not
<code>MagicValue(JS_UNINITIALIZED_LEXICAL)</code>. Used in derived class
constructors to prohibit calling <code>super</code> more than once.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-bindthisvalue">BindThisValue</a>, step 3.</p>
</dd>

</dl>
<h4 id="Generators_and_async_functions">Generators and async functions</h4>
<dl>
<dt id="JSOP_GENERATOR"><code>JSOP_GENERATOR</code></dt>
<dd>
<div>Stack: ⇒ <code>generator</code></div>
<p>Initializes generator frame, creates a generator and pushes it on the
stack.</p>
</dd>

<dt id="JSOP_INITIALYIELD"><code>JSOP_INITIALYIELD</code></dt>
<dd>
<div>Operands: <code>(uint24_t resumeIndex)</code></div>
<div>Stack: <code>gen</code> ⇒ <code>rval, gen, resumeKind</code></div>
<p>Pops the generator from the top of the stack, suspends it and stops
execution.</p>
<p>When resuming execution, JSOP_RESUME pushes the rval, gen and resumeKind
values. resumeKind is the GeneratorResumeKind stored as int32.</p>
<div>Flags: JOF_RESUMEINDEX</div>
</dd>

<dt id="JSOP_AFTERYIELD"><code>JSOP_AFTERYIELD</code></dt>
<dd>
<div>Operands: <code>(uint32_t icIndex)</code></div>
<p>Bytecode emitted after 'yield' expressions. This is useful for the
Debugger and <code>AbstractGeneratorObject::isAfterYieldOrAwait</code>. It's
treated as jump target op so that the Baseline Interpreter can
efficiently restore the frame's interpreterICEntry when resuming a
generator.</p>
<div>Flags: JOF_ICINDEX</div>
</dd>

<dt id="JSOP_FINALYIELDRVAL"><code>JSOP_FINALYIELDRVAL</code></dt>
<dd>
<div>Stack: <code>gen</code> ⇒</div>
<p>Pops the generator and suspends and closes it. Yields the value in the
frame's return value slot.</p>
</dd>

<dt id="JSOP_YIELD"><code>JSOP_YIELD</code></dt>
<dd>
<div>Operands: <code>(uint24_t resumeIndex)</code></div>
<div>Stack: <code>rval1, gen</code> ⇒ <code>rval2, gen, resumeKind</code></div>
<p>Pops the generator and the return value 'rval1', stops execution and
returns 'rval1'.</p>
<p>When resuming execution, JSOP_RESUME pushes the rval2, gen and resumeKind
values.</p>
<div>Flags: JOF_RESUMEINDEX</div>
</dd>

<dt id="JSOP_ISGENCLOSING"><code>JSOP_ISGENCLOSING</code></dt>
<dd>
<div>Stack: <code>val</code> ⇒ <code>val, res</code></div>
<p>Pushes a boolean indicating whether the top of the stack is
<code>MagicValue(JS_GENERATOR_CLOSING)</code>.</p>
</dd>

<dt id="JSOP_ASYNCAWAIT"><code>JSOP_ASYNCAWAIT</code></dt>
<dd>
<div>Stack: <code>value, gen</code> ⇒ <code>promise</code></div>
<p>Pops the top two values 'value' and 'gen' from the stack, then starts
"awaiting" for 'value' to be resolved, which will then resume the
execution of 'gen'. Pushes the async function promise on the stack, so
that it'll be returned to the caller on the very first "await".</p>
</dd>

<dt id="JSOP_ASYNCRESOLVE"><code>JSOP_ASYNCRESOLVE</code></dt>
<dd>
<div>Operands: <code>(uint8_t fulfillOrReject)</code></div>
<div>Stack: <code>valueOrReason, gen</code> ⇒ <code>promise</code></div>
<p>Pops the top two values 'valueOrReason' and 'gen' from the stack, then
pushes the promise resolved with 'valueOrReason'. <code>gen</code> must be the
internal generator object created in async functions. The pushed promise
is the async function's result promise, which is stored in <code>gen</code>.</p>
</dd>

<dt id="JSOP_AWAIT"><code>JSOP_AWAIT</code></dt>
<dd>
<div>Operands: <code>(uint24_t resumeIndex)</code></div>
<div>Stack: <code>promise, gen</code> ⇒ <code>resolved, gen, resumeKind</code></div>
<p>Pops the generator and the return value 'promise', stops execution and
returns 'promise'.</p>
<p>When resuming execution, JSOP_RESUME pushes the resolved, gen and
resumeKind values. resumeKind is the GeneratorResumeKind stored as int32.</p>
<div>Flags: JOF_RESUMEINDEX</div>
</dd>

<dt id="JSOP_TRYSKIPAWAIT"><code>JSOP_TRYSKIPAWAIT</code></dt>
<dd>
<div>Stack: <code>value</code> ⇒ <code>value_or_resolved, canskip</code></div>
<p>Pops the top of stack value as 'value', checks if the await for 'value'
can be skipped. If the await operation can be skipped and the resolution
value for 'value' can be acquired, pushes the resolution value and
'true' onto the stack. Otherwise, pushes 'value' and 'false' on the
stack.</p>
</dd>

<dt id="JSOP_RESUMEKIND"><code>JSOP_RESUMEKIND</code></dt>
<dd>
<div>Operands: <code>(GeneratorResumeKind resumeKind (encoded as uint8_t))</code></div>
<div>Stack: ⇒ <code>resumeKind</code></div>
<p>Pushes one of the GeneratorResumeKind values as Int32Value.</p>
</dd>

<dt id="JSOP_CHECK_RESUMEKIND"><code>JSOP_CHECK_RESUMEKIND</code></dt>
<dd>
<div>Stack: <code>rval, gen, resumeKind</code> ⇒ <code>rval</code></div>
<p>Pops the generator and resumeKind values. resumeKind is the
GeneratorResumeKind stored as int32. If resumeKind is Next, continue
execution. If resumeKind is Throw or Return, these completions are
handled by throwing an exception. See GeneratorThrowOrReturn.</p>
</dd>

<dt id="JSOP_RESUME"><code>JSOP_RESUME</code></dt>
<dd>
<div>Stack: <code>gen, val, resumeKind</code> ⇒ <code>rval</code></div>
<p>Pops the generator, argument and resumeKind from the stack, pushes a new
generator frame and resumes execution of it. Pushes the return value
after the generator yields.</p>
<div>Flags: JOF_INVOKE</div>
</dd>

</dl>
<h3 id="Control_flow">Control flow</h3>
<h4 id="Jump_targets">Jump targets</h4>
<dl>
<dt id="JSOP_JUMPTARGET"><code>JSOP_JUMPTARGET</code></dt>
<dd>
<div>Operands: <code>(uint32_t icIndex)</code></div>
<p>No-op instruction marking the target of a jump instruction.</p>
<p>This instruction and a few others (see <code>js::BytecodeIsJumpTarget</code>) are
jump target instructions. The Baseline Interpreter uses these
instructions to sync the frame's <code>interpreterICEntry</code> after a jump. Ion
uses them to find block boundaries when translating bytecode to MIR.</p>
<div>Flags: JOF_ICINDEX</div>
</dd>

<dt id="JSOP_LOOPHEAD"><code>JSOP_LOOPHEAD</code></dt>
<dd>
<div>Operands: <code>(uint32_t icIndex, uint8_t depthHint)</code></div>
<p>Marks the target of the backwards jump for some loop.</p>
<p>This is a jump target instruction (see <code>JSOP_JUMPTARGET</code>). Additionally,
it checks for interrupts and handles JIT tiering.</p>
<p>The <code>depthHint</code> operand is a loop depth hint for Ion. It starts at 1 and
deeply nested loops all have the same value.</p>
<p>For the convenience of the JITs, scripts must not start with this
instruction. See bug 1602390.</p>
</dd>

</dl>
<h4 id="Jumps">Jumps</h4>
<dl>
<dt id="JSOP_GOTO"><code>JSOP_GOTO</code></dt>
<dd>
<div>Operands: <code>(int32_t offset)</code></div>
<p>Jump to a 32-bit offset from the current bytecode.</p>
<p>See "Jump instructions" above for details.</p>
<div>Flags: JOF_JUMP</div>
</dd>

<dt id="JSOP_IFEQ"><code>JSOP_IFEQ</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>cond</code> ⇒</div>
<p>If ToBoolean(<code>cond</code>) is false, jumps to a 32-bit offset from the current
instruction.</p>
<div>Flags: JOF_JUMP, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_IFNE"><code>JSOP_IFNE</code></dt>
<dd>
<div>Operands: <code>(int32_t offset)</code></div>
<div>Stack: <code>cond</code> ⇒</div>
<p>If ToBoolean(<code>cond</code>) is true, jump to a 32-bit offset from the current
instruction.</p>
<p><code>offset</code> may be positive or negative. This is the instruction used at the
end of a do-while loop to jump back to the top.</p>
<div>Flags: JOF_JUMP, JOF_IC</div>
</dd>

<dt id="JSOP_AND"><code>JSOP_AND</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>cond</code> ⇒ <code>cond</code></div>
<p>Short-circuit for logical AND.</p>
<p>If ToBoolean(<code>cond</code>) is false, jump to a 32-bit offset from the current
instruction. The value remains on the stack.</p>
<div>Flags: JOF_JUMP, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_OR"><code>JSOP_OR</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>cond</code> ⇒ <code>cond</code></div>
<p>Short-circuit for logical OR.</p>
<p>If ToBoolean(<code>cond</code>) is true, jump to a 32-bit offset from the current
instruction. The value remains on the stack.</p>
<div>Flags: JOF_JUMP, JOF_DETECTING, JOF_IC</div>
</dd>

<dt id="JSOP_COALESCE"><code>JSOP_COALESCE</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>Short-circuiting for nullish coalescing.</p>
<p>If <code>val</code> is not null or undefined, jump to a 32-bit offset from the
current instruction.</p>
<div>Flags: JOF_JUMP, JOF_DETECTING</div>
</dd>

<dt id="JSOP_CASE"><code>JSOP_CASE</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>val, cond</code> ⇒ <code>val (if !cond)</code></div>
<p>Like <code>JSOP_IFNE</code> ("jump if true"), but if the branch is taken,
pop and discard an additional stack value.</p>
<p>This is used to implement <code>switch</code> statements when the
<code>JSOP_TABLESWITCH</code> optimization is not possible. The switch statement</p>
<pre><code>switch (expr) {
    case A: stmt1;
    case B: stmt2;
}
</code></pre>
<p>compiles to this bytecode:</p>
<pre><code>    # dispatch code - evaluate expr, check it against each `case`,
    # jump to the right place in the body or to the end.
    &lt;expr&gt;
    dup; &lt;A&gt;; stricteq; case L1; jumptarget
    dup; &lt;B&gt;; stricteq; case L2; jumptarget
    default LE

    # body code
L1: jumptarget; &lt;stmt1&gt;
L2: jumptarget; &lt;stmt2&gt;
LE: jumptarget
</code></pre>
<p>This opcode is weird: it's the only one whose ndefs varies depending on
which way a conditional branch goes. We could implement switch
statements using <code>JSOP_IFNE</code> and <code>JSOP_POP</code>, but that would also be
awkward--putting the <code>POP</code> inside the <code>switch</code> body would complicate
fallthrough.</p>
<div>Flags: JOF_JUMP</div>
</dd>

<dt id="JSOP_DEFAULT"><code>JSOP_DEFAULT</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>lval</code> ⇒</div>
<p>Like <code>JSOP_GOTO</code>, but pop and discard an additional stack value.</p>
<p>This appears after all cases for a non-optimized <code>switch</code> statement. If
there's a <code>default:</code> label, it jumps to that point in the body;
otherwise it jumps to the next statement.</p>
<div>Flags: JOF_JUMP</div>
</dd>

<dt id="JSOP_TABLESWITCH"><code>JSOP_TABLESWITCH</code></dt>
<dd>
<div>Operands: <code>(int32_t defaultOffset, int32_t low, int32_t high, uint24_t firstResumeIndex)</code></div>
<div>Stack: <code>i</code> ⇒</div>
<p>Optimized switch-statement dispatch, used when all <code>case</code> labels are
small integer constants.</p>
<p>If <code>low &lt;= i &lt;= high</code>, jump to the instruction at the offset given by
<code>script-&gt;resumeOffsets()[firstResumeIndex + i - low]</code>, in bytes from the
start of the current script's bytecode. Otherwise, jump to the
instruction at <code>defaultOffset</code> from the current instruction. All of
these offsets must be in range for the current script and must point to
<code>JSOP_JUMPTARGET</code> instructions.</p>
<p>The following inequalities must hold: <code>low &lt;= high</code> and
<code>firstResumeIndex + high - low &lt; resumeOffsets().size()</code>.</p>
<div>Flags: JOF_DETECTING</div>
</dd>

</dl>
<h4 id="Return">Return</h4>
<dl>
<dt id="JSOP_RETURN"><code>JSOP_RETURN</code></dt>
<dd>
<div>Stack: <code>rval</code> ⇒</div>
<p>Return <code>rval</code>.</p>
<p>This must not be used in derived class constructors. Instead use
<code>JSOP_SETRVAL</code>, <code>JSOP_CHECKRETURN</code>, and <code>JSOP_RETRVAL</code>.</p>
</dd>

<dt id="JSOP_GETRVAL"><code>JSOP_GETRVAL</code></dt>
<dd>
<div>Stack: ⇒ <code>rval</code></div>
<p>Push the current stack frame's <code>returnValue</code>. If no <code>JSOP_SETRVAL</code>
instruction has been executed in this stack frame, this is <code>undefined</code>.</p>
<p>Every stack frame has a <code>returnValue</code> slot, used by top-level scripts,
generators, async functions, and derived class constructors. Plain
functions usually use <code>JSOP_RETURN</code> instead.</p>
</dd>

<dt id="JSOP_SETRVAL"><code>JSOP_SETRVAL</code></dt>
<dd>
<div>Stack: <code>rval</code> ⇒</div>
<p>Store <code>rval</code> in the current stack frame's <code>returnValue</code> slot.</p>
</dd>

<dt id="JSOP_RETRVAL"><code>JSOP_RETRVAL</code></dt>
<dd>
<p>Stop execution and return the current stack frame's <code>returnValue</code>. If no
<code>JSOP_SETRVAL</code> instruction has been executed in this stack frame, this
is <code>undefined</code>.</p>
<p>Also emitted at end of every script so consumers don't need to worry
about running off the end.</p>
<p>If the current script is a derived class constructor, <code>returnValue</code> must
be an object. The script can use <code>JSOP_CHECKRETURN</code> to ensure this.</p>
</dd>

<dt id="JSOP_CHECKRETURN"><code>JSOP_CHECKRETURN</code></dt>
<dd>
<div>Stack: <code>thisval</code> ⇒</div>
<p>Check the return value in a derived class constructor.</p>
<ul>
<li>
<p>If the current stack frame's <code>returnValue</code> is an object, do nothing.</p>
</li>
<li>
<p>Otherwise, if the <code>returnValue</code> is undefined and <code>thisval</code> is an
    object, store <code>thisval</code> in the <code>returnValue</code> slot.</p>
</li>
<li>
<p>Otherwise, throw a TypeError.</p>
</li>
</ul>
<p>This is exactly what has to happen when a derived class constructor
returns. <code>thisval</code> should be the current value of <code>this</code>, or
<code>MagicValue(JS_UNINITIALIZED_LEXICAL)</code> if <code>this</code> is uninitialized.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-ecmascript-function-objects-construct-argumentslist-newtarget">The [[Construct]] internal method of JS functions</a>,
steps 13 and 15.</p>
</dd>

</dl>
<h4 id="Exceptions">Exceptions</h4>
<dl>
<dt id="JSOP_THROW"><code>JSOP_THROW</code></dt>
<dd>
<div>Stack: <code>exc</code> ⇒</div>
<p>Throw <code>exc</code>. (ノಠ益ಠ)ノ彡┴──┴</p>
<p>This sets the pending exception to <code>exc</code> and jumps to error-handling
code. If we're in a <code>try</code> block, error handling adjusts the stack and
environment chain and resumes execution at the top of the <code>catch</code> or
<code>finally</code> block. Otherwise it starts unwinding the stack.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-throw-statement-runtime-semantics-evaluation"><em>ThrowStatement</em> Evaluation</a>, step 3.</p>
<p>This is also used in for-of loops. If the body of the loop throws an
exception, we catch it, close the iterator, then use <code>JSOP_THROW</code> to
rethrow.</p>
</dd>

<dt id="JSOP_THROWMSG"><code>JSOP_THROWMSG</code></dt>
<dd>
<div>Operands: <code>(uint16_t msgNumber)</code></div>
<p>Create and throw an Error object.</p>
<p>Sometimes we know at emit time that an operation always throws. For
example, <code>delete super.prop;</code> is allowed in methods, but always throws a
ReferenceError.</p>
<p><code>msgNumber</code> must be one of the error codes listed in js/src/js.msg; it
determines the <code>.message</code> and [[Prototype]] of the new Error object. The
number of arguments in the error message must be 0.</p>
</dd>

<dt id="JSOP_THROWSETALIASEDCONST"><code>JSOP_THROWSETALIASEDCONST</code></dt>
<dd>
<div>Operands: <code>(uint8_t hops, uint24_t slot)</code></div>
<div>Stack: <code>v</code> ⇒ <code>v</code></div>
<p>Throw a TypeError for invalid assignment to a <code>const</code>. The environment
coordinate is used to get the variable name for the error message.</p>
<div>Flags: JOF_ENVCOORD, JOF_NAME, JOF_DETECTING</div>
</dd>

<dt id="JSOP_THROWSETCALLEE"><code>JSOP_THROWSETCALLEE</code></dt>
<dd>
<div>Stack: <code>v</code> ⇒ <code>v</code></div>
<p>Throw a TypeError for invalid assignment to the callee binding in a named
lambda, which is always a <code>const</code> binding. This is a different bytecode
than <code>JSOP_THROWSETCONST</code> because the named lambda callee, if not closed
over, does not have a frame slot to look up the name with for the error
message.</p>
</dd>

<dt id="JSOP_THROWSETCONST"><code>JSOP_THROWSETCONST</code></dt>
<dd>
<div>Operands: <code>(uint24_t localno)</code></div>
<div>Stack: <code>v</code> ⇒ <code>v</code></div>
<p>Throws a runtime TypeError for invalid assignment to an optimized
<code>const</code> binding. <code>localno</code> is used to get the variable name for the
error message.</p>
<div>Flags: JOF_LOCAL, JOF_NAME, JOF_DETECTING</div>
</dd>

<dt id="JSOP_TRY"><code>JSOP_TRY</code></dt>
<dd>
<div>Operands: <code>(int32_t jumpAtEndOffset)</code></div>
<p>No-op instruction that marks the top of the bytecode for a
<em>TryStatement</em>.</p>
<p>The <code>jumpAtEndOffset</code> operand is the offset (relative to the current op)
of the <code>JSOP_GOTO</code> at the end of the try-block body. This is used by
bytecode analysis and JIT compilation.</p>
<p>Location information for catch/finally blocks is stored in a side table,
<code>script-&gt;trynotes()</code>.</p>
<div>Flags: JOF_CODE_OFFSET</div>
</dd>

<dt id="JSOP_TRY_DESTRUCTURING"><code>JSOP_TRY_DESTRUCTURING</code></dt>
<dd>
<p>No-op instruction used by the exception unwinder to determine the
correct environment to unwind to when performing IteratorClose due to
destructuring.</p>
</dd>

<dt id="JSOP_EXCEPTION"><code>JSOP_EXCEPTION</code></dt>
<dd>
<div>Stack: ⇒ <code>exception</code></div>
<p>Push and clear the pending exception. ┬──┬◡ﾉ(° -°ﾉ)</p>
<p>This must be used only in the fixed sequence of instructions following a
<code>JSTRY_CATCH</code> span (see "Bytecode Invariants" above), as that's the only
way instructions would run with an exception pending.</p>
<p>Used to implement catch-blocks, including the implicit ones generated as
part of for-of iteration.</p>
</dd>

<dt id="JSOP_RESUMEINDEX"><code>JSOP_RESUMEINDEX</code></dt>
<dd>
<div>Operands: <code>(uint24_t resumeIndex)</code></div>
<div>Stack: ⇒ <code>resumeIndex</code></div>
<p>Push <code>resumeIndex</code>.</p>
<p>This value must be used only by <code>JSOP_GOSUB</code>, <code>JSOP_FINALLY</code>, and <code>JSOP_RETSUB</code>.</p>
<div>Flags: JOF_RESUMEINDEX</div>
</dd>

<dt id="JSOP_GOSUB"><code>JSOP_GOSUB</code></dt>
<dd>
<div>Operands: <code>(int32_t forwardOffset)</code></div>
<div>Stack: <code>false, resumeIndex</code> ⇒</div>
<p>Jump to the start of a <code>finally</code> block.</p>
<p><code>JSOP_GOSUB</code> is unusual: if the finally block finishes normally, it will
reach the <code>JSOP_RETSUB</code> instruction at the end, and control then
"returns" to the <code>JSOP_GOSUB</code> and picks up at the next instruction, like
a function call but within a single script and stack frame. (It's named
after the thing in BASIC.)</p>
<p>We need this because a <code>try</code> block can terminate in several different
ways: control can flow off the end, return, throw an exception, <code>break</code>
with or without a label, or <code>continue</code>. Exceptions are handled
separately; but all those success paths are written as bytecode, and
each one needs to run the <code>finally</code> block before continuing with
whatever they were doing. They use <code>JSOP_GOSUB</code> for this. It is thus
normal for multiple <code>GOSUB</code> instructions in a script to target the same
<code>finally</code> block.</p>
<p>Rules: <code>forwardOffset</code> must be positive and must target a
<code>JSOP_JUMPTARGET</code> instruction followed by <code>JSOP_FINALLY</code>. The
instruction immediately following <code>JSOP_GOSUB</code> in the script must be a
<code>JSOP_JUMPTARGET</code> instruction, and <code>resumeIndex</code> must be the index into
<code>script-&gt;resumeOffsets()</code> that points to that instruction.</p>
<p>Note: This op doesn't actually push or pop any values. Its use count of
2 is a lie to make the stack depth math work for this very odd control
flow instruction.</p>
<p><code>JSOP_GOSUB</code> is considered to have two "successors": the target of
<code>offset</code>, which is the actual next instruction to run; and the
instruction immediately following <code>JSOP_GOSUB</code>, even though it won't run
until later. We define the successor graph this way in order to support
knowing the stack depth at that instruction without first reading the
whole <code>finally</code> block.</p>
<p>The stack depth at that instruction is, as it happens, the current stack
depth minus 2. So this instruction gets nuses == 2.</p>
<p>Unfortunately there is a price to be paid in horribleness. When
<code>JSOP_GOSUB</code> runs, it leaves two values on the stack that the stack
depth math doesn't know about. It jumps to the finally block, where
<code>JSOP_FINALLY</code> again does nothing to the stack, but with a bogus def
count of 2, restoring balance to the accounting. If <code>JSOP_RETSUB</code> is
reached, it pops the two values (for real this time) and control
resumes at the instruction that follows JSOP_GOSUB in memory.</p>
<div>Flags: JOF_JUMP</div>
</dd>

<dt id="JSOP_FINALLY"><code>JSOP_FINALLY</code></dt>
<dd>
<div>Stack: ⇒ <code>false, resumeIndex</code></div>
<p>No-op instruction that marks the start of a <code>finally</code> block. This has a
def count of 2, but the values are already on the stack (they're
actually left on the stack by <code>JSOP_GOSUB</code>).</p>
<p>These two values must not be used except by <code>JSOP_RETSUB</code>.</p>
</dd>

<dt id="JSOP_RETSUB"><code>JSOP_RETSUB</code></dt>
<dd>
<div>Stack: <code>throwing, v</code> ⇒</div>
<p>Jump back to the next instruction, or rethrow an exception, at the end
of a <code>finally</code> block. See <code>JSOP_GOSUB</code> for the explanation.</p>
<p>If <code>throwing</code> is true, throw <code>v</code>. Otherwise, <code>v</code> must be a resume index;
jump to the corresponding offset within the script.</p>
<p>The two values popped must be the ones notionally pushed by
<code>JSOP_FINALLY</code>.</p>
</dd>

</dl>
<h3 id="Variables_and_scopes">Variables and scopes</h3>
<h4 id="Initialization">Initialization</h4>
<dl>
<dt id="JSOP_UNINITIALIZED"><code>JSOP_UNINITIALIZED</code></dt>
<dd>
<div>Stack: ⇒ <code>uninitialized</code></div>
<p>Push <code>MagicValue(JS_UNINITIALIZED_LEXICAL)</code>, a magic value used to mark
a binding as uninitialized.</p>
<p>This magic value must be used only by <code>JSOP_INIT*LEXICAL</code>.</p>
</dd>

<dt id="JSOP_INITLEXICAL"><code>JSOP_INITLEXICAL</code></dt>
<dd>
<div>Operands: <code>(uint24_t localno)</code></div>
<div>Stack: <code>v</code> ⇒ <code>v</code></div>
<p>Initialize an optimized local lexical binding; or mark it as
uninitialized.</p>
<p>This stores the value <code>v</code> in the fixed slot <code>localno</code> in the current
stack frame. If <code>v</code> is the magic value produced by <code>JSOP_UNINITIALIZED</code>,
this marks the binding as uninitialized. Otherwise this initializes the
binding with value <code>v</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-declarative-environment-records-createmutablebinding-n-d">CreateMutableBinding</a> step 3, substep "record that it is
uninitialized", and <a href="https://tc39.es/ecma262/#sec-declarative-environment-records-initializebinding-n-v">InitializeBinding</a>, for optimized locals. (Note:
this is how <code>const</code> bindings are initialized.)</p>
<div>Flags: JOF_LOCAL, JOF_NAME, JOF_DETECTING</div>
</dd>

<dt id="JSOP_INITGLEXICAL"><code>JSOP_INITGLEXICAL</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>Initialize a global lexical binding; or mark it as uninitialized.</p>
<p>Like <code>JSOP_INITLEXICAL</code> but for global lexicals.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_PROPINIT, JOF_GNAME, JOF_IC</div>
</dd>

<dt id="JSOP_INITALIASEDLEXICAL"><code>JSOP_INITALIASEDLEXICAL</code></dt>
<dd>
<div>Operands: <code>(uint8_t hops, uint24_t slot)</code></div>
<div>Stack: <code>v</code> ⇒ <code>v</code></div>
<p>Initialize an aliased lexical binding; or mark it as uninitialized.</p>
<p>Like <code>JSOP_INITLEXICAL</code> but for aliased bindings.</p>
<p>Note: There is no even-less-optimized <code>INITNAME</code> instruction because JS
doesn't need it. We always know statically which binding we're
initializing.</p>
<p><code>hops</code> is usually 0, but in <code>function f(a=eval("var b;")) { }</code>, the
argument <code>a</code> is initialized from inside a nested scope, so <code>hops == 1</code>.</p>
<div>Flags: JOF_ENVCOORD, JOF_NAME, JOF_PROPINIT, JOF_DETECTING</div>
</dd>

<dt id="JSOP_CHECKLEXICAL"><code>JSOP_CHECKLEXICAL</code></dt>
<dd>
<div>Operands: <code>(uint24_t localno)</code></div>
<p>Throw a ReferenceError if the optimized local <code>localno</code> is
uninitialized.</p>
<p><code>localno</code> must be the number of a fixed slot in the current stack frame
previously initialized or marked uninitialized using <code>JSOP_INITLEXICAL</code>.</p>
<p>Typically used before <code>JSOP_GETLOCAL</code> or <code>JSOP_SETLOCAL</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-declarative-environment-records-getbindingvalue-n-s">GetBindingValue</a> step 3 and <a href="https://tc39.es/ecma262/#sec-declarative-environment-records-setmutablebinding-n-v-s">SetMutableBinding</a> step
4 for declarative Environment Records.</p>
<div>Flags: JOF_LOCAL, JOF_NAME</div>
</dd>

<dt id="JSOP_CHECKALIASEDLEXICAL"><code>JSOP_CHECKALIASEDLEXICAL</code></dt>
<dd>
<div>Operands: <code>(uint8_t hops, uint24_t slot)</code></div>
<p>Like <code>JSOP_CHECKLEXICAL</code> but for aliased bindings.</p>
<p>Note: There are no <code>CHECKNAME</code> or <code>CHECKGNAME</code> instructions because
they're unnecessary. <code>JSOP_{GET,SET}{NAME,GNAME}</code> all check for
uninitialized lexicals and throw if needed.</p>
<div>Flags: JOF_ENVCOORD, JOF_NAME</div>
</dd>

<dt id="JSOP_CHECKTHIS"><code>JSOP_CHECKTHIS</code></dt>
<dd>
<div>Stack: <code>this</code> ⇒ <code>this</code></div>
<p>Throw a ReferenceError if the value on top of the stack is
<code>MagicValue(JS_UNINITIALIZED_LEXICAL)</code>. Used in derived class
constructors to check <code>this</code> (which needs to be initialized before use,
by calling <code>super()</code>).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-function-environment-records-getthisbinding">GetThisBinding</a> step 3.</p>
</dd>

</dl>
<h4 id="Looking_up_bindings">Looking up bindings</h4>
<dl>
<dt id="JSOP_BINDGNAME"><code>JSOP_BINDGNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>global</code></div>
<p>Push the global environment onto the stack, unless the script has a
non-syntactic global scope. In that case, this acts like JSOP_BINDNAME.</p>
<p><code>nameIndex</code> is only used when acting like JSOP_BINDNAME.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_GNAME, JOF_IC</div>
</dd>

<dt id="JSOP_BINDNAME"><code>JSOP_BINDNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>env</code></div>
<p>Look up a name on the environment chain and push the environment which
contains a binding for that name. If no such binding exists, push the
global lexical environment.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_IC</div>
</dd>

</dl>
<h4 id="Getting_binding_values">Getting binding values</h4>
<dl>
<dt id="JSOP_GETNAME"><code>JSOP_GETNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Find a binding on the environment chain and push its value.</p>
<p>If the binding is an uninitialized lexical, throw a ReferenceError. If
no such binding exists, throw a ReferenceError unless the next
instruction is <code>JSOP_TYPEOF</code>, in which case push <code>undefined</code>.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-resolvebinding">ResolveBinding</a> followed by <a href="https://tc39.es/ecma262/#sec-getvalue">GetValue</a>
(adjusted hackily for <code>typeof</code>).</p>
<p>This is the fallback <code>GET</code> instruction that handles all unoptimized
cases. Optimized instructions follow.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_GETGNAME"><code>JSOP_GETGNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Find a global binding and push its value.</p>
<p>This searches the global lexical environment and, failing that, the
global object. (Unlike most declarative environments, the global lexical
environment can gain more bindings after compilation, possibly shadowing
global object properties.)</p>
<p>This is an optimized version of <code>JSOP_GETNAME</code> that skips all local
scopes, for use when the name doesn't refer to any local binding.
<code>NonSyntacticVariablesObject</code>s break this optimization, so if the
current script has a non-syntactic global scope, this acts like
<code>JSOP_GETNAME</code>.</p>
<p>Like <code>JSOP_GETNAME</code>, this throws a ReferenceError if no such binding is
found (unless the next instruction is <code>JSOP_TYPEOF</code>) or if the binding
is an uninitialized lexical.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_TYPESET, JOF_GNAME, JOF_IC</div>
</dd>

<dt id="JSOP_GETARG"><code>JSOP_GETARG</code></dt>
<dd>
<div>Operands: <code>(uint16_t argno)</code></div>
<div>Stack: ⇒ <code>arguments[argno]</code></div>
<p>Push the value of an argument that is stored in the stack frame
or in an <code>ArgumentsObject</code>.</p>
<div>Flags: JOF_QARG, JOF_NAME</div>
</dd>

<dt id="JSOP_GETLOCAL"><code>JSOP_GETLOCAL</code></dt>
<dd>
<div>Operands: <code>(uint24_t localno)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the value of an optimized local variable.</p>
<p>If the variable is an uninitialized lexical, push
<code>MagicValue(JS_UNINIITALIZED_LEXICAL)</code>.</p>
<div>Flags: JOF_LOCAL, JOF_NAME</div>
</dd>

<dt id="JSOP_GETALIASEDVAR"><code>JSOP_GETALIASEDVAR</code></dt>
<dd>
<div>Operands: <code>(uint8_t hops, uint24_t slot)</code></div>
<div>Stack: ⇒ <code>aliasedVar</code></div>
<p>Push the value of an aliased binding.</p>
<p>Local bindings that aren't closed over or dynamically accessed are
stored in stack slots. Global and <code>with</code> bindings are object properties.
All other bindings are called "aliased" and stored in
<code>EnvironmentObject</code>s.</p>
<p>Where possible, <code>ALIASED</code> instructions are used to access aliased
bindings.  (There's no difference in meaning between <code>ALIASEDVAR</code> and
<code>ALIASEDLEXICAL</code>.) Each of these instructions has operands <code>hops</code> and
<code>slot</code> that encode an <a href="https://searchfox.org/mozilla-central/search?q=symbol:T_js%3A%3AEnvironmentCoordinate"><code>EnvironmentCoordinate</code></a>, directions to the
binding from the current environment object.</p>
<p><code>hops</code> and <code>slot</code> must be valid for the current scope.</p>
<p><code>ALIASED</code> instructions can't be used when there's a dynamic scope (due
to non-strict <code>eval</code> or <code>with</code>) that might shadow the aliased binding.</p>
<div>Flags: JOF_ENVCOORD, JOF_NAME, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_GETIMPORT"><code>JSOP_GETIMPORT</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>val</code></div>
<p>Get the value of a module import by name and pushes it onto the stack.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_GETBOUNDNAME"><code>JSOP_GETBOUNDNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>env</code> ⇒ <code>v</code></div>
<p>Get the value of a binding from the environment <code>env</code>. If the name is
not bound in <code>env</code>, throw a ReferenceError.</p>
<p><code>env</code> must be an environment currently on the environment chain, pushed
by <code>JSOP_BINDNAME</code>.</p>
<p>Note: <code>JSOP_BINDNAME</code> and <code>JSOP_GETBOUNDNAME</code> are the two halves of the
<code>JSOP_GETNAME</code> operation: finding and reading a variable. This
decomposed version is needed to implement the compound assignment and
increment/decrement operators, which get and then set a variable. The
spec says the variable lookup is done only once. If we did the lookup
twice, there would be observable bugs, thanks to dynamic scoping. We
could set the wrong variable or call proxy traps incorrectly.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-getvalue">GetValue</a> steps 4 and 6.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_GETINTRINSIC"><code>JSOP_GETINTRINSIC</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>intrinsic[name]</code></div>
<p>Push the value of an intrinsic onto the stack.</p>
<p>Non-standard. Intrinsics are slots in the intrinsics holder object (see
<code>GlobalObject::getIntrinsicsHolder</code>), which is used in lieu of global
bindings in self-hosting code.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_CALLEE"><code>JSOP_CALLEE</code></dt>
<dd>
<div>Stack: ⇒ <code>callee</code></div>
<p>Pushes the currently executing function onto the stack.</p>
<p>The current script must be a function script.</p>
<p>Used to implement <code>super</code>. This is also used sometimes as a minor
optimization when a named function expression refers to itself by name:</p>
<pre><code>f = function fac(n) {  ... fac(n - 1) ... };
</code></pre>
<p>This lets us optimize away a lexical environment that contains only the
binding for <code>fac</code>, unless it's otherwise observable (via <code>with</code>, <code>eval</code>,
or a nested closure).</p>
</dd>

<dt id="JSOP_ENVCALLEE"><code>JSOP_ENVCALLEE</code></dt>
<dd>
<div>Operands: <code>(uint8_t numHops)</code></div>
<div>Stack: ⇒ <code>callee</code></div>
<p>Load the callee stored in a CallObject on the environment chain. The
numHops operand is the number of environment objects to skip on the
environment chain.</p>
</dd>

</dl>
<h4 id="Setting_binding_values">Setting binding values</h4>
<dl>
<dt id="JSOP_SETNAME"><code>JSOP_SETNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>env, val</code> ⇒ <code>val</code></div>
<p>Assign <code>val</code> to the binding in <code>env</code> with the name given by <code>nameIndex</code>.
Throw a ReferenceError if the binding is an uninitialized lexical.
This can call setters and/or proxy traps.</p>
<p><code>env</code> must be an environment currently on the environment chain,
pushed by <code>JSOP_BINDNAME</code>.</p>
<p>This is the fallback <code>SET</code> instruction that handles all unoptimized
cases. Optimized instructions follow.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-putvalue">PutValue</a> steps 5 and 7 for unoptimized bindings.</p>
<p>Note: <code>JSOP_BINDNAME</code> and <code>JSOP_SETNAME</code> are the two halves of simple
assignment: finding and setting a variable. They are two separate
instructions because, per spec, the "finding" part happens before
evaluating the right-hand side of the assignment, and the "setting" part
after. Optimized cases don't need a <code>BIND</code> instruction because the
"finding" is done statically.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSLOPPY, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTSETNAME"><code>JSOP_STRICTSETNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>env, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_SETNAME</code>, but throw a TypeError if there is no binding for
the specified name in <code>env</code>, or if the binding is immutable (a <code>const</code>
or read-only property).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-putvalue">PutValue</a> steps 5 and 7 for strict mode code.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_PROPSET, JOF_DETECTING, JOF_CHECKSTRICT, JOF_IC</div>
</dd>

<dt id="JSOP_SETGNAME"><code>JSOP_SETGNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>env, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_SETNAME</code>, but for assigning to globals. <code>env</code> must be an
environment pushed by <code>JSOP_BINDGNAME</code>.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_PROPSET, JOF_DETECTING, JOF_GNAME, JOF_CHECKSLOPPY, JOF_IC</div>
</dd>

<dt id="JSOP_STRICTSETGNAME"><code>JSOP_STRICTSETGNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>env, val</code> ⇒ <code>val</code></div>
<p>Like <code>JSOP_STRICTSETGNAME</code>, but for assigning to globals. <code>env</code> must be
an environment pushed by <code>JSOP_BINDGNAME</code>.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_PROPSET, JOF_DETECTING, JOF_GNAME, JOF_CHECKSTRICT, JOF_IC</div>
</dd>

<dt id="JSOP_SETARG"><code>JSOP_SETARG</code></dt>
<dd>
<div>Operands: <code>(uint16_t argno)</code></div>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>Assign <code>val</code> to an argument binding that's stored in the stack frame or
in an <code>ArgumentsObject</code>.</p>
<div>Flags: JOF_QARG, JOF_NAME</div>
</dd>

<dt id="JSOP_SETLOCAL"><code>JSOP_SETLOCAL</code></dt>
<dd>
<div>Operands: <code>(uint24_t localno)</code></div>
<div>Stack: <code>v</code> ⇒ <code>v</code></div>
<p>Assign to an optimized local binding.</p>
<div>Flags: JOF_LOCAL, JOF_NAME, JOF_DETECTING</div>
</dd>

<dt id="JSOP_SETALIASEDVAR"><code>JSOP_SETALIASEDVAR</code></dt>
<dd>
<div>Operands: <code>(uint8_t hops, uint24_t slot)</code></div>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>Assign to an aliased binding.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-declarative-environment-records-setmutablebinding-n-v-s">SetMutableBinding for declarative Environment Records</a>,
in certain cases where it's known that the binding exists, is mutable,
and has been initialized.</p>
<div>Flags: JOF_ENVCOORD, JOF_NAME, JOF_PROPSET, JOF_DETECTING</div>
</dd>

<dt id="JSOP_SETINTRINSIC"><code>JSOP_SETINTRINSIC</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: <code>val</code> ⇒ <code>val</code></div>
<p>Assign to an intrinsic.</p>
<p>Nonstandard. Intrinsics are used in lieu of global bindings in self-
hosted code. The value is actually stored in the intrinsics holder
object, <code>GlobalObject::getIntrinsicsHolder</code>. (Self-hosted code doesn't
have many global <code>var</code>s, but it has many <code>function</code>s.)</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_DETECTING</div>
</dd>

</dl>
<h4 id="Entering_and_leaving_environments">Entering and leaving environments</h4>
<dl>
<dt id="JSOP_PUSHLEXICALENV"><code>JSOP_PUSHLEXICALENV</code></dt>
<dd>
<div>Operands: <code>(uint32_t lexicalScopeIndex)</code></div>
<p>Push a lexical environment onto the environment chain.</p>
<p>The <code>LexicalScope</code> indicated by <code>lexicalScopeIndex</code> determines the shape
of the new <code>LexicalEnvironmentObject</code>. All bindings in the new
environment are marked as uninitialized.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-block-runtime-semantics-evaluation">Evaluation of <em>Block</em></a>, steps 1-4.</p>
<h4 id="Fine_print_for_environment_chain_instructions">Fine print for environment chain instructions</h4>
<p>The following rules for <code>JSOP_{PUSH,POP}LEXICALENV</code> also apply to
<code>JSOP_{PUSH,POP}VARENV</code> and <code>JSOP_{ENTER,LEAVE}WITH</code>.</p>
<p>Each <code>JSOP_POPLEXICALENV</code> instruction matches a particular
<code>JSOP_PUSHLEXICALENV</code> instruction in the same script and must have the
same scope and stack depth as the instruction immediately after that
<code>PUSHLEXICALENV</code>.</p>
<p><code>JSOP_PUSHLEXICALENV</code> enters a scope that extends to some set of
instructions in the script. Code must not jump into or out of this
region: control can enter only by executing <code>PUSHLEXICALENV</code> and can
exit only by executing a <code>POPLEXICALENV</code> or by exception unwinding. (A
<code>JSOP_POPLEXICALENV</code> is always emitted at the end of the block, and
extra copies are emitted on "exit slides", where a <code>break</code>, <code>continue</code>,
or <code>return</code> statement exits the scope.)</p>
<p>The script's <code>JSScript::scopeNotes()</code> must identify exactly which
instructions begin executing in this scope. Typically this means a
single entry marking the contiguous chunk of bytecode from the
instruction after <code>JSOP_PUSHLEXICALENV</code> to <code>JSOP_POPLEXICALENV</code>
(inclusive); but if that range contains any instructions on exit slides,
after a <code>JSOP_POPLEXICALENV</code>, then those must be correctly noted as
<em>outside</em> the scope.</p>
<div>Flags: JOF_SCOPE</div>
</dd>

<dt id="JSOP_POPLEXICALENV"><code>JSOP_POPLEXICALENV</code></dt>
<dd>
<p>Pop a lexical environment from the environment chain.</p>
<p>See <code>JSOP_PUSHLEXICALENV</code> for the fine print.</p>
</dd>

<dt id="JSOP_DEBUGLEAVELEXICALENV"><code>JSOP_DEBUGLEAVELEXICALENV</code></dt>
<dd>
<p>No-op instruction that indicates leaving an optimized lexical scope.</p>
<p>If all bindings in a lexical scope are optimized into stack slots, then
the runtime environment objects for that scope are optimized away. No
<code>JSOP_{PUSH,POP}LEXICALENV</code> instructions are emitted. However, the
debugger still needs to be notified when control exits a scope; that's
what this instruction does.</p>
<p>The last instruction in a lexical scope, as indicated by scope notes,
must be marked with either this instruction (if the scope is optimized)
or <code>JSOP_POPLEXICALENV</code> (if not).</p>
</dd>

<dt id="JSOP_RECREATELEXICALENV"><code>JSOP_RECREATELEXICALENV</code></dt>
<dd>
<p>Recreate the current block on the environment chain with a fresh block
with uninitialized bindings. This implements the behavior of inducing a
fresh lexical environment for every iteration of a for-in/of loop whose
loop-head has a (captured) lexical declaration.</p>
</dd>

<dt id="JSOP_FRESHENLEXICALENV"><code>JSOP_FRESHENLEXICALENV</code></dt>
<dd>
<p>Replace the current block on the environment chain with a fresh block
that copies all the bindings in the block. This implements the behavior
of inducing a fresh lexical environment for every iteration of a
<code>for(let ...; ...; ...)</code> loop, if any declarations induced by such a
loop are captured within the loop.</p>
</dd>

<dt id="JSOP_PUSHVARENV"><code>JSOP_PUSHVARENV</code></dt>
<dd>
<div>Operands: <code>(uint32_t scopeIndex)</code></div>
<p>Push a var environment onto the environment chain.</p>
<p>Like <code>JSOP_PUSHLEXICALENV</code>, but pushes a <code>VarEnvironmentObject</code> rather
than a <code>LexicalEnvironmentObject</code>. The difference is that non-strict
direct <code>eval</code> can add bindings to a var environment; see <code>VarScope</code> in
Scope.h.</p>
<p>See <code>JSOP_PUSHLEXICALENV</code> for the fine print.</p>
<p>Implements: Places in the spec where the VariableEnvironment is set:</p>
<ul>
<li>
<p>The bit in <a href="https://tc39.es/ecma262/#sec-performeval">PerformEval</a> where, in strict direct eval, the new
    eval scope is taken as <em>varEnv</em> and becomes "<em>runningContext</em>'s
    VariableEnvironment".</p>
</li>
<li>
<p>The weird scoping rules for functions with default parameter
    expressions, as specified in <a href="https://tc39.es/ecma262/#sec-functiondeclarationinstantiation">FunctionDeclarationInstantiation</a>
    step 28 ("NOTE: A separate Environment Record is needed...") and
    <a href="https://tc39.es/ecma262/#sec-function-definitions-runtime-semantics-iteratorbindinginitialization">IteratorBindingInitialization for <em>FormalParameter</em> and
    <em>FormalRestParameter</em></a>.</p>
</li>
</ul>
<p>Note: The spec also pushes a new VariableEnvironment on entry to every
function, but the VM takes care of that as part of pushing the stack
frame, before the function script starts to run, so <code>JSOP_PUSHVARENV</code> is
not needed.</p>
<div>Flags: JOF_SCOPE</div>
</dd>

<dt id="JSOP_POPVARENV"><code>JSOP_POPVARENV</code></dt>
<dd>
<p>Pop a <code>VarEnvironmentObject</code> from the environment chain.</p>
<p>See <code>JSOP_PUSHLEXICALENV</code> for the fine print.</p>
</dd>

<dt id="JSOP_ENTERWITH"><code>JSOP_ENTERWITH</code></dt>
<dd>
<div>Operands: <code>(uint32_t staticWithIndex)</code></div>
<div>Stack: <code>val</code> ⇒</div>
<p>Push a <code>WithEnvironmentObject</code> wrapping ToObject(<code>val</code>) to the
environment chain.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-with-statement-runtime-semantics-evaluation">Evaluation of <code>with</code> statements</a>, steps 2-6.</p>
<p>Operations that may need to consult a WithEnvironment can't be correctly
implemented using optimized instructions like <code>JSOP_GETLOCAL</code>. A script
must use the deoptimized <code>JSOP_GETNAME</code>, <code>BINDNAME</code>, <code>SETNAME</code>, and
<code>DELNAME</code> instead. Since those instructions don't work correctly with
optimized locals and arguments, all bindings in scopes enclosing a
<code>with</code> statement are marked as "aliased" and deoptimized too.</p>
<p>See <code>JSOP_PUSHLEXICALENV</code> for the fine print.</p>
<div>Flags: JOF_SCOPE</div>
</dd>

<dt id="JSOP_LEAVEWITH"><code>JSOP_LEAVEWITH</code></dt>
<dd>
<p>Pop a <code>WithEnvironmentObject</code> from the environment chain.</p>
<p>See <code>JSOP_PUSHLEXICALENV</code> for the fine print.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-with-statement-runtime-semantics-evaluation">Evaluation of <code>with</code> statements</a>, step 8.</p>
</dd>

</dl>
<h4 id="Creating_and_deleting_bindings">Creating and deleting bindings</h4>
<dl>
<dt id="JSOP_BINDVAR"><code>JSOP_BINDVAR</code></dt>
<dd>
<div>Stack: ⇒ <code>env</code></div>
<p>Push the current VariableEnvironment (the environment on the environment
chain designated to receive new variables).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-web-compat-functiondeclarationinstantiation">Annex B.3.3.1, changes to FunctionDeclarationInstantiation
for block-level functions</a>, step 1.a.ii.3.a, and similar steps in
other Annex B.3.3 algorithms, when setting the function's second binding
can't be optimized.</p>
</dd>

<dt id="JSOP_DEFVAR"><code>JSOP_DEFVAR</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<p>Create a new binding on the current VariableEnvironment (the environment
on the environment chain designated to receive new variables).</p>
<p><code>JSOP_DEF{VAR,LET,CONST,FUN}</code> instructions must appear in the script
before anything else that might add bindings to the environment, and
only once per binding. There must be a correct entry for the new binding
in <code>script-&gt;bodyScope()</code>. (All this ensures that at run time, there is
no existing conflicting binding. We check before running the script, in
<code>js::CheckGlobalOrEvalDeclarationConflicts</code>.)</p>
<p>Throw a SyntaxError if the current VariableEnvironment is the global
environment and a binding with the same name exists on the global
lexical environment.</p>
<p>This is used for global scripts and also in some cases for function
scripts where use of dynamic scoping inhibits optimization.</p>
<div>Flags: JOF_ATOM</div>
</dd>

<dt id="JSOP_DEFFUN"><code>JSOP_DEFFUN</code></dt>
<dd>
<div>Stack: <code>fun</code> ⇒</div>
<p>Create a new binding for the given function on the current scope.</p>
<p><code>fun</code> must be a function object with an explicit name. The new
variable's name is <code>fun-&gt;explicitName()</code>, and its value is <code>fun</code>. In
global scope, this creates a new property on the global object.</p>
<p>Implements: The body of the loop in <a href="https://tc39.es/ecma262/#sec-globaldeclarationinstantiation">GlobalDeclarationInstantiation</a>
step 17 ("For each Parse Node <em>f</em> in <em>functionsToInitialize</em>...") and
the corresponding loop in <a href="https://tc39.es/ecma262/#sec-evaldeclarationinstantiation">EvalDeclarationInstantiation</a>.</p>
</dd>

<dt id="JSOP_DEFLET"><code>JSOP_DEFLET</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<p>Create a new mutable binding in the global lexical environment. Throw a
SyntaxError if a binding with the same name already exists on that
environment, or if a var binding with the same name exists on the
global.</p>
<div>Flags: JOF_ATOM</div>
</dd>

<dt id="JSOP_DEFCONST"><code>JSOP_DEFCONST</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<p>Create a new constant binding in the global lexical environment.</p>
<p>Throw a SyntaxError if a binding with the same name already exists in
that environment, or if a var binding with the same name exists on the
global.</p>
<div>Flags: JOF_ATOM</div>
</dd>

<dt id="JSOP_DELNAME"><code>JSOP_DELNAME</code></dt>
<dd>
<div>Operands: <code>(uint32_t nameIndex)</code></div>
<div>Stack: ⇒ <code>succeeded</code></div>
<p>Look up a variable on the environment chain and delete it. Push <code>true</code>
on success (if a binding was deleted, or if no such binding existed in
the first place), <code>false</code> otherwise (most kinds of bindings can't be
deleted).</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-delete-operator-runtime-semantics-evaluation"><code>delete</code> <em>Identifier</em></a>, which <a href="https://tc39.es/ecma262/#sec-delete-operator-static-semantics-early-errors">is a SyntaxError</a> in
strict mode code.</p>
<div>Flags: JOF_ATOM, JOF_NAME, JOF_CHECKSLOPPY</div>
</dd>

</dl>
<h4 id="Function_environment_setup">Function environment setup</h4>
<dl>
<dt id="JSOP_ARGUMENTS"><code>JSOP_ARGUMENTS</code></dt>
<dd>
<div>Stack: ⇒ <code>arguments</code></div>
<p>Create and push the <code>arguments</code> object for the current function activation.</p>
<p>When it exists, <code>arguments</code> is stored in an ordinary local variable.
<code>JSOP_ARGUMENTS</code> is used in function preludes, to populate that variable
before the function body runs, <em>not</em> each time <code>arguments</code> appears in a
function.</p>
<p>If a function clearly doesn't use <code>arguments</code>, we optimize it away when
emitting bytecode. The function's script won't use <code>JSOP_ARGUMENTS</code> at
all.</p>
<p>The current script must be a function script. This instruction must
execute at most once per function activation.</p>
<h4 id="Optimized_arguments">Optimized arguments</h4>
<p>If <code>script-&gt;needsArgsObj()</code> is false, no ArgumentsObject is created.
Instead, <code>MagicValue(JS_OPTIMIZED_ARGUMENTS)</code> is pushed.</p>
<p>This optimization imposes no restrictions on bytecode. Rather,
<code>js::jit::AnalyzeArgumentsUsage</code> examines the bytecode and enables the
optimization only if all uses of <code>arguments</code> are optimizable.  Each
execution engine must know what the analysis considers optimizable and
cope with the magic value when it is used in those ways.</p>
<p>Example 1: <code>arguments[0]</code> is supported; therefore the interpreter's
implementation of <code>JSOP_GETELEM</code> checks for optimized arguments (see
<code>GetElemOptimizedArguments</code>).</p>
<p>Example 2: <code>f.apply(this, arguments)</code> is supported; therefore our
implementation of <code>Function.prototype.apply</code> checks for optimized
arguments (<code>see js::fun_apply</code>), and all <code>JSOP_FUNAPPLY</code> implementations
must check for cases where <code>f.apply</code> turns out to be any other function
(see <code>GuardFunApplyArgumentsOptimization</code>).</p>
<p>It's not documented anywhere exactly which opcodes support
<code>JS_OPTIMIZED_ARGUMENTS</code>; see the source of <code>AnalyzeArgumentsUsage</code>.</p>
</dd>

<dt id="JSOP_REST"><code>JSOP_REST</code></dt>
<dd>
<div>Stack: ⇒ <code>rest</code></div>
<p>Create and push the rest parameter array for current function call.</p>
<p>This must appear only in function scripts.</p>
<div>Flags: JOF_TYPESET, JOF_IC</div>
</dd>

<dt id="JSOP_FUNCTIONTHIS"><code>JSOP_FUNCTIONTHIS</code></dt>
<dd>
<div>Stack: ⇒ <code>this</code></div>
<p>Determines the <code>this</code> value for current function frame and pushes it
onto the stack.</p>
<p>In functions, <code>this</code> is stored in a local variable. This instruction is
used in the function prologue to get the value to initialize that
variable.  (This doesn't apply to arrow functions, becauses they don't
have a <code>this</code> binding; also, <code>this</code> is optimized away if it's unused.)</p>
<p>Functions that have a <code>this</code> binding have a local variable named
<code>".this"</code>, which is initialized using this instruction in the function
prologue.</p>
</dd>

</dl>
<h3 id="Stack_operations">Stack operations</h3>
<dl>
<dt id="JSOP_POP"><code>JSOP_POP</code></dt>
<dd>
<div>Stack: <code>v</code> ⇒</div>
<p>Pop the top value from the stack and discard it.</p>
</dd>

<dt id="JSOP_POPN"><code>JSOP_POPN</code></dt>
<dd>
<div>Operands: <code>(uint16_t n)</code></div>
<div>Stack: <code>v[n-1], ..., v[1], v[0]</code> ⇒</div>
<p>Pop the top <code>n</code> values from the stack. <code>n</code> must be &lt;= the current stack
depth.</p>
</dd>

<dt id="JSOP_DUP"><code>JSOP_DUP</code></dt>
<dd>
<div>Stack: <code>v</code> ⇒ <code>v, v</code></div>
<p>Push a copy of the top value on the stack.</p>
</dd>

<dt id="JSOP_DUP2"><code>JSOP_DUP2</code></dt>
<dd>
<div>Stack: <code>v1, v2</code> ⇒ <code>v1, v2, v1, v2</code></div>
<p>Duplicate the top two values on the stack.</p>
</dd>

<dt id="JSOP_DUPAT"><code>JSOP_DUPAT</code></dt>
<dd>
<div>Operands: <code>(uint24_t n)</code></div>
<div>Stack: <code>v[n], v[n-1], ..., v[1], v[0]</code> ⇒ <code>v[n], v[n-1], ..., v[1], v[0], v[n]</code></div>
<p>Push a copy of the nth value from the top of the stack.</p>
<p><code>n</code> must be less than the current stack depth.</p>
</dd>

<dt id="JSOP_SWAP"><code>JSOP_SWAP</code></dt>
<dd>
<div>Stack: <code>v1, v2</code> ⇒ <code>v2, v1</code></div>
<p>Swap the top two values on the stack.</p>
</dd>

<dt id="JSOP_PICK"><code>JSOP_PICK</code></dt>
<dd>
<div>Operands: <code>(uint8_t n)</code></div>
<div>Stack: <code>v[n], v[n-1], ..., v[1], v[0]</code> ⇒ <code>v[n-1], ..., v[1], v[0], v[n]</code></div>
<p>Pick the nth element from the stack and move it to the top of the stack.</p>
</dd>

<dt id="JSOP_UNPICK"><code>JSOP_UNPICK</code></dt>
<dd>
<div>Operands: <code>(uint8_t n)</code></div>
<div>Stack: <code>v[n], v[n-1], ..., v[1], v[0]</code> ⇒ <code>v[0], v[n], v[n-1], ..., v[1]</code></div>
<p>Move the top of the stack value under the <code>n</code>th element of the stack.
<code>n</code> must not be 0.</p>
</dd>

</dl>
<h3 id="Other">Other</h3>
<dl>
<dt id="JSOP_NOP"><code>JSOP_NOP</code></dt>
<dd>
<p>Do nothing. This is used when we need distinct bytecode locations for
various mechanisms.</p>
</dd>

<dt id="JSOP_LINENO"><code>JSOP_LINENO</code></dt>
<dd>
<div>Operands: <code>(uint32_t lineno)</code></div>
<p>No-op instruction used to speed up pc-to-line mapping.</p>
</dd>

<dt id="JSOP_NOP_DESTRUCTURING"><code>JSOP_NOP_DESTRUCTURING</code></dt>
<dd>
<p>No-op instruction used by the decompiler to produce nicer error messages
about destructuring code.</p>
</dd>

<dt id="JSOP_FORCEINTERPRETER"><code>JSOP_FORCEINTERPRETER</code></dt>
<dd>
<p>No-op instruction only emitted in some self-hosted functions. Not
handled by the JITs or Baseline Interpreter so the script always runs in
the C++ interpreter.</p>
</dd>

<dt id="JSOP_DEBUGCHECKSELFHOSTED"><code>JSOP_DEBUGCHECKSELFHOSTED</code></dt>
<dd>
<div>Stack: <code>checkVal</code> ⇒ <code>checkVal</code></div>
<p>Examine the top stack value, asserting that it's either a self-hosted
function or a self-hosted intrinsic. This does nothing in a non-debug
build.</p>
</dd>

<dt id="JSOP_INSTRUMENTATION_ACTIVE"><code>JSOP_INSTRUMENTATION_ACTIVE</code></dt>
<dd>
<div>Stack: ⇒ <code>val</code></div>
<p>Push a boolean indicating if instrumentation is active.</p>
</dd>

<dt id="JSOP_INSTRUMENTATION_CALLBACK"><code>JSOP_INSTRUMENTATION_CALLBACK</code></dt>
<dd>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the instrumentation callback for the current realm.</p>
</dd>

<dt id="JSOP_INSTRUMENTATION_SCRIPT_ID"><code>JSOP_INSTRUMENTATION_SCRIPT_ID</code></dt>
<dd>
<div>Stack: ⇒ <code>val</code></div>
<p>Push the current script's instrumentation ID.</p>
</dd>

<dt id="JSOP_DEBUGGER"><code>JSOP_DEBUGGER</code></dt>
<dd>
<p>Break in the debugger, if one is attached. Otherwise this is a no-op.</p>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger-API/Debugger"><code>Debugger</code> API</a> offers a way to hook into this instruction.</p>
<p>Implements: <a href="https://tc39.es/ecma262/#sec-debugger-statement-runtime-semantics-evaluation">Evaluation for <em>DebuggerStatement</em></a>.</p>
</dd>

</dl>