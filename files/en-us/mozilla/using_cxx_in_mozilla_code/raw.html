<h2 id="C_language_features">C++ language features</h2>

<p>Mozilla code only uses a subset of C++. Runtime type information (RTTI) is disabled, as it tends to cause a very large increase in codesize. This means that <code>dynamic_cast</code>, <code>typeid()</code> and <code>&lt;typeinfo&gt;</code> cannot be used in Mozilla code. Also disabled are exceptions; do not use <code>try</code>/<code>catch</code> or throw any exceptions. Libraries that throw exceptions may be used if you are willing to have the throw instead be treated as an abort.</p>

<p>On the side of extending C++, we compile with <code>-fno-strict-aliasing</code>. This means that when reinterpreting a pointer as a differently-typed pointer, you don't need to adhere to the "effective type" (of the pointee) rule from the standard (aka. "the strict aliasing rule") when dereferencing the reinterpreted pointer. You still need make sure that you don't violate alignment requirements and need to make sure that the data at the memory location pointed to forms a valid value when interpreted according to the type of the pointer when dereferencing the pointer for reading. Likewise, if you write by dereferencing the reinterpreted pointer and the originally-typed pointer might still be dereferenced for reading, you need to make sure that the values you write are valid according to the original type. This value validity issue is moot for e.g. primitive integers for which all bit patterns of their size are valid values.</p>

<ul>
 <li>As of Mozilla 59, C++14 mode is required to build Mozilla.</li>
 <li>As of Mozilla 67, MSVC can no longer be used to build Mozilla.</li>
 <li>As of Mozilla 73, C++17 mode is required to build Mozilla.</li>
</ul>

<p>This means that C++17 can be used where supported on all platforms. The list of acceptable features is given below:</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col"></th>
   <th scope="col">GCC</th>
   <th scope="col">Clang</th>
   <th scope="col"></th>
  </tr>
  <tr>
   <td>Current minimal requirement</td>
   <td>7.1</td>
   <td>5.0</td>
   <td></td>
  </tr>
  <tr>
   <th scope="col">Feature</th>
   <th scope="col">GCC</th>
   <th scope="col">Clang</th>
   <th scope="col">Can be used in code</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>type_t &amp;&amp;</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.3</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes (see notes)</td>
  </tr>
  <tr>
   <td>ref qualifiers on methods</td>
   <td style="background-color: rgb(204, 255, 153);">4.8.1</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>default member initializers (except for bit-fields)</td>
   <td style="background-color: rgb(204, 255, 153);">4.7</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>default member initializers (for bit-fields)</td>
   <td style="background-color: rgb(255, 204, 204);">8</td>
   <td style="background-color: rgb(255, 204, 204);">6</td>
   <td style="background-color: rgb(255, 204, 204);">No</td>
  </tr>
  <tr>
   <td>variadic templates</td>
   <td style="background-color: rgb(204, 255, 153);">4.3</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Initializer lists</td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>static_assert</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.3</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>auto</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>lambdas</td>
   <td style="background-color: rgb(204, 255, 153);">4.5</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>decltype</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.3</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>Foo&lt;Bar&lt;T&gt;&gt;</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.3</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>auto func() -&gt; int</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Templated aliasing</td>
   <td style="background-color: rgb(204, 255, 153);">4.7</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td style="vertical-align: middle;"><code>nullptr</code></td>
   <td style="vertical-align: middle; background-color: rgb(204, 255, 153);">4.6</td>
   <td style="vertical-align: middle; background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>enum foo : int16_t</code> {};</td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>enum class foo {}</code>;</td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>enum foo;</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.6</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>[[attributes]]</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.8</td>
   <td style="background-color: rgb(204, 255, 153);">3.3</td>
   <td style="background-color: rgb(255, 204, 204);">No (see notes)</td>
  </tr>
  <tr>
   <td><code>constexpr</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.6</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>alignas</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.8</td>
   <td style="background-color: rgb(204, 255, 153);">3.3</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>alignof</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.8</td>
   <td style="background-color: rgb(204, 255, 153);">3.3</td>
   <td style="background-color: rgb(255, 255, 153);">Yes, but see notes ; only clang 3.6 claims __has_feature(cxx_alignof)</td>
  </tr>
  <tr>
   <td>Delegated constructors</td>
   <td style="background-color: rgb(204, 255, 153);">4.7</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Inherited constructors</td>
   <td style="background-color: rgb(204, 255, 153);">4.8</td>
   <td style="background-color: rgb(204, 255, 153);">3.3</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>explicit operator bool()</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.5</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td style="vertical-align: middle;"><code>char16_t/u"string"</code></td>
   <td style="background-color: rgb(204, 255, 153); vertical-align: middle;">4.4</td>
   <td style="background-color: rgb(204, 255, 153); vertical-align: middle;">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>R"(string)"</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.5</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>operator""()</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.7</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>=delete</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>=default</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.4</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>unrestricted unions</td>
   <td style="background-color: rgb(204, 255, 153);">4.6</td>
   <td style="background-color: rgb(204, 255, 153);">3.1</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>for (auto x : vec)</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.6</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes (<a href="https://stackoverflow.com/questions/15176104/c11-range-based-loop-get-item-by-value-or-reference-to-const">be careful about the type of the iterator</a>)</td>
  </tr>
  <tr>
   <td><code>override</code>/<code>final</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.7</td>
   <td style="background-color: rgb(204, 255, 153);">3.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>thread_local</code></td>
   <td style="background-color: rgb(204, 255, 153);">4.8</td>
   <td style="background-color: rgb(204, 255, 153);">3.3</td>
   <td style="background-color: rgb(255, 204, 204);">No (see notes)</td>
  </tr>
  <tr>
   <td>function template default arguments</td>
   <td style="background-color: rgb(204, 255, 153);">4.3</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>local structs as template parameters</td>
   <td style="background-color: rgb(204, 255, 153);">4.5</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>extended friend declarations</td>
   <td style="background-color: rgb(204, 255, 153);">4.7</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><code>0b100</code> (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">2.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/">Tweaks to some C++ contextual conversions</a> (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Return type deduction (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes (but only in template code when you would have used <code>decltype(complex-expression)</code>)</td>
  </tr>
  <tr>
   <td>Generic lambdas (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Initialized lambda captures (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Digit separator (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Variable templates (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">5.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Relaxed constexpr (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">5.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Aggregate member initialization (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">5.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.3</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td><a href="/en-US/docs/">Clarifying memory allocation</a> (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">5.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>[[deprecated]] attribute (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">4.9</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(255, 204, 204);">No (see notes)</td>
  </tr>
  <tr>
   <td>Sized deallocation (C++14)</td>
   <td style="background-color: rgb(204, 255, 153);">5.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(255, 204, 204);">No (see notes)</td>
  </tr>
  <tr>
   <td>Concepts (Concepts TS)</td>
   <td style="background-color: rgb(204, 255, 153);">6.0</td>
   <td style="background-color: rgb(255, 204, 204);">—</td>
   <td style="background-color: rgb(255, 204, 204);">No</td>
  </tr>
  <tr>
   <td>Inline variables (C++17)</td>
   <td style="background-color: rgb(204, 255, 153);">7.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.9</td>
   <td style="background-color: rgb(255, 204, 204);">No (clang 5 has bugs with inline variables)</td>
  </tr>
  <tr>
   <td>constexpr_if (C++17)</td>
   <td style="background-color: rgb(204, 255, 153);">7.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>constexpr lambdas (C++17)</td>
   <td style="background-color: rgb(255, 204, 204);">—</td>
   <td style="background-color: rgb(255, 204, 204);">—</td>
   <td style="background-color: rgb(255, 204, 204);">No</td>
  </tr>
  <tr>
   <td>Structured bindings (C++17)</td>
   <td style="background-color: rgb(204, 255, 153);">7.0</td>
   <td style="background-color: rgb(204, 255, 153);">4.0</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>[[fallthrough]], [[maybe_unused]], [[nodiscard]] (C++17)</td>
   <td style="background-color: rgb(204, 255, 153);">7.0</td>
   <td style="background-color: rgb(204, 255, 153);">3.9</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
  </tr>
  <tr>
   <td>Aligned allocation/deallocation (C++17)</td>
   <td style="background-color: rgb(204, 255, 153);">7.0</td>
   <td style="background-color: rgb(204, 255, 153);">4.0</td>
   <td style="background-color: rgb(255, 204, 204);">No (see notes)</td>
  </tr>
  <tr>
   <td>#pragma once</td>
   <td style="background-color: rgb(204, 255, 153);">3.4</td>
   <td style="background-color: rgb(204, 255, 153);">Yes</td>
   <td style="background-color: rgb(255, 204, 204);">Not until we <a href="https://groups.google.com/d/msg/mozilla.dev.platform/PgDjWw3xp8k/eqCFlP4Kz1MJ">normalize headers</a></td>
  </tr>
  <tr>
   <td><a href="https://en.cppreference.com/w/cpp/experimental/lib_extensions_2#Source_code_information_capture">Source code information capture</a></td>
   <td style="background-color: rgb(255, 204, 204);">8.0</td>
   <td style="background-color: rgb(255, 204, 204);">—</td>
   <td style="background-color: rgb(255, 204, 204);">No</td>
  </tr>
 </tbody>
</table>

<h3 id="Sources">Sources</h3>

<p>GCC: <a href="https://gcc.gnu.org/projects/cxx-status.html">https://gcc.gnu.org/projects/cxx-status.html</a><br>
 Clang: <a href="https://clang.llvm.org/cxx_status.html">https://clang.llvm.org/cxx_status.html</a></p>

<h3 id="Notes">Notes</h3>

<p>rvalue references: Implicit move method generation cannot be used.</p>

<p>Attributes: Several common attributes are defined in <a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/Attributes.h">mozilla/Attributes.h</a> or nscore.h.</p>

<p>Alignment: Some alignment utilities are defined in <a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/Alignment.h">mozilla/Alignment.h</a>. /!\ MOZ_ALIGNOF and alignof don't have the same semantics. Be careful of what you expect from them.</p>

<p><code>[[deprecated]]</code>: If we have deprecated code, we should be removing it rather than marking it as such. Marking things as <code>[[deprecated]]</code> also means the compiler will warn if you use the deprecated API, which turns into a fatal error in our automation builds, which is not helpful.</p>

<p>Sized deallocation: Our compilers all support this (custom flags are required for GCC and Clang), but turning it on breaks some classes' <code>operator new</code> methods, and <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1250998">some work</a> would need to be done to make it an efficiency win with our custom memory allocator.</p>

<p>Aligned allocation/deallocation: Our custom memory allocator doesn't have support for these functions.</p>

<p>Thread locals: <code>thread_local</code> is not supported on Android.</p>

<h2 id="C_and_Mozilla_standard_libraries">C++ and Mozilla standard libraries</h2>

<p>The Mozilla codebase contains within it several subprojects which follow different rules for which libraries can and can't be used it. The rules listed here apply to normal platform code, and assume unrestricted usability of MFBT or XPCOM APIs.</p>

<div class="warning">
<p>The rest of this section is a draft for expository and exploratory purposes. Do not trust the information listed here.</p>
</div>

<p>What follows is a list of standard library components provided by Mozilla or the C++ standard. If an API is not listed here, then it is not permissible to use it in Mozilla code. Deprecated APIs are not listed here. In general, prefer Mozilla variants of data structures to standard C++ ones, even when permitted to use the latter, since Mozilla variants tend to have features not found in the standard library (e.g., memory size tracking) or have more controllable performance characteristics.</p>

<p>A list of approved standard library headers is maintained in <a href="https://searchfox.org/mozilla-central/source/config/stl-headers.mozbuild">config/stl-headers.mozbuild</a>.</p>

<h3 id="Data_structures">Data structures</h3>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Name</th>
   <th scope="col">Header</th>
   <th scope="col">STL equivalent</th>
   <th scope="col">Notes</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>nsAutoTArray</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/ds/nsTArray.h">nsTArray.h</a></code></td>
   <td></td>
   <td>Like <code>nsTArray</code>, but will store a small amount as stack storage</td>
  </tr>
  <tr>
   <td><code>nsAutoTObserverArray</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/ds/nsTObserverArray.h">nsTObserverArray.h</a></code></td>
   <td></td>
   <td>Like <code>nsTObserverArray</code>, but will store a small amount as stack storage</td>
  </tr>
  <tr>
   <td><code>mozilla::BloomFilter</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/BloomFilter.h">mozilla/BloomFilter.h</a></code></td>
   <td></td>
   <td>Probabilistic set membership (see <a href="https://en.wikipedia.org/wiki/Bloom_filter#Counting_filters">Wikipedia</a>)</td>
  </tr>
  <tr>
   <td><code>nsClassHashtable</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/ds/nsClassHashtable.h">nsClassHashtable.h</a></code></td>
   <td></td>
   <td>Adaptation of nsTHashtable, see <a href="/en-US/docs/XPCOM_hashtable_guide">XPCOM hashtable guide</a></td>
  </tr>
  <tr>
   <td><code>nsCOMArray</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/ds/nsCOMArray.h">nsCOMArray.h</a></code></td>
   <td></td>
   <td>Like <code>nsTArray&lt;nsCOMPtr&lt;T&gt;&gt;</code></td>
  </tr>
  <tr>
   <td><code>nsDataHashtable</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/ds/nsDataHashtable.h">nsClassHashtable.h</a></code></td>
   <td><code>std::unordered_map</code></td>
   <td>Adaptation of <code>nsTHashtable</code>, see <a href="/en-US/docs/XPCOM_hashtable_guide">XPCOM hashtable guide</a></td>
  </tr>
  <tr>
   <td><code>nsDeque</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/ds/nsDeque.h">nsDeque.h</a></code></td>
   <td><code>std::deque&lt;void *&gt;</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::EnumSet</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/EnumSet.h">mozilla/EnumSet.h</a></code></td>
   <td></td>
   <td>Like <code>std::set</code>, but for enum classes.</td>
  </tr>
  <tr>
   <td><code>mozilla::Hash{Map,Set}</code></td>
   <td><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/HashTable.h">mozilla/HashTable.h</a></td>
   <td><code>std::unordered_{map,set}</code></td>
   <td>A general purpose hash map and hash set.</td>
  </tr>
  <tr>
   <td><code>nsInterfaceHashtable</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsInterfaceHashtable.h">nsInterfaceHashtable.h</a></code></td>
   <td><code>std::unordered_map</code></td>
   <td>Adaptation of <code>nsTHashtable</code>, see <a href="/en-US/docs/XPCOM_hashtable_guide">XPCOM hashtable guide</a></td>
  </tr>
  <tr>
   <td><code>nsJSThingHashtable</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsJSThingHashtable.h">nsJSThingHashtable.h</a></code></td>
   <td></td>
   <td>Adaptation of <code>nsTHashtable</code>, see <a href="/en-US/docs/XPCOM_hashtable_guide">XPCOM hashtable guide</a></td>
  </tr>
  <tr>
   <td><code>mozilla::LinkedList</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/LinkedList.h">mozilla/LinkedList.h</a></code></td>
   <td><code>std::list</code></td>
   <td>Doubly-linked list</td>
  </tr>
  <tr>
   <td><code>nsRefPtrHashtable</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsRefPtrHashtable.h">nsRefPtrHashtable.h</a></code></td>
   <td><code>std::unordered_map</code></td>
   <td>Adaptation of <code>nsTHashtable</code>, see <a href="/en-US/docs/XPCOM_hashtable_guide">XPCOM hashtable guide</a></td>
  </tr>
  <tr>
   <td><code>mozilla::SegmentedVector</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/SegmentedVector.h">mozilla/SegmentedVector.h</a></code></td>
   <td><code>std::deque</code> w/o O(1) pop_front</td>
   <td>Doubly-linked list of vector elements</td>
  </tr>
  <tr>
   <td><code>mozilla::SplayTree</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/SplayTree.h">mozilla/SplayTree.h</a></code></td>
   <td></td>
   <td>Quick access to recently-accessed elements (see <a href="https://en.wikipedia.org/wiki/Splay_tree">Wikipedia</a>)</td>
  </tr>
  <tr>
   <td><code>nsTArray</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsTArray.h">nsTArray.h</a></code></td>
   <td><code>std::vector</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>nsTHashtable</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsTHashtable.h">nsTHashtable.h</a></code></td>
   <td><code>std::unordered_{map,set}</code></td>
   <td>See <a href="/en-US/docs/XPCOM_hashtable_guide">XPCOM hashtable guide</a>, you probably want a subclass</td>
  </tr>
  <tr>
   <td><code>nsTObserverArray</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsTObserverArray.h">nsTObserverArray.h</a></code></td>
   <td></td>
   <td>Like <code>nsTArray</code>, but iteration is stable even through mutation</td>
  </tr>
  <tr>
   <td><code>nsTPriorityQueue</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/xpcom/glue/nsTPriorityQueue.h">nsTPriorityQueue.h</a></code></td>
   <td><code>std::priority_queue</code></td>
   <td>Unlike the STL class, not a container adapter</td>
  </tr>
  <tr>
   <td><code>mozilla::Vector</code></td>
   <td><code><a href="https://dxr.mozilla.org/mozilla-central/source/mfbt/Vector.h">mozilla/Vector.h</a></code></td>
   <td><code>std::vector</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::Buffer</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/Buffer.h">mozilla/Buffer.h</a></code></td>
   <td></td>
   <td>Unlike <code>Array</code>, has a run-time variable length. Unlike <code>Vector</code>, does not have capacity and growth mechanism. Unlike <code>Span</code>, owns its buffer.</td>
  </tr>
 </tbody>
</table>

<h3 id="Safety_utilities">Safety utilities</h3>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Name</th>
   <th scope="col">Header</th>
   <th scope="col">STL equivalent</th>
   <th scope="col">Notes</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>mozilla::Array</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/Array.h">mfbt/Array.h</a></code></td>
   <td></td>
   <td>safe array index</td>
  </tr>
  <tr>
   <td><code>mozilla::AssertedCast</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/Casting.h">mfbt/Casting.h</a></code></td>
   <td></td>
   <td>casts</td>
  </tr>
  <tr>
   <td><code>mozilla::CheckedInt</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/CheckedInt.h">mfbt/CheckedInt.h</a></code></td>
   <td></td>
   <td>avoids overflow</td>
  </tr>
  <tr>
   <td><code>nsCOMPtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/xpcom/base/nsCOMPtr.h">xpcom/base/nsCOMPtr.h</a></code></td>
   <td><code>std::shared_ptr</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::EnumeratedArray</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/EnumeratedArray.h">mfbt/EnumeratedArray.h</a></code></td>
   <td><code>mozilla::Array</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::Maybe</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/Maybe.h">mfbt/Maybe.h</a></code></td>
   <td><code>std::optional</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::RangedPtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/RangedPtr.h">mfbt/RangedPtr.h</a></code></td>
   <td></td>
   <td>like <code>mozilla::Span</code> but with two pointers instead of pointer and length</td>
  </tr>
  <tr>
   <td><code>mozilla::RefPtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/RefPtr.h">mfbt/RefPtr.h</a></code></td>
   <td><code>std::shared_ptr</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::Span</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/Span.h">mozilla/Span.h</a></code></td>
   <td><code>gsl::span</code>, <code>absl::Span</code>, <code>std::string_view</code>, <code>std::u16string_view</code></td>
   <td>Rust's slice concept for C++ (without borrow checking)</td>
  </tr>
  <tr>
   <td><code>StaticRefPtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/xpcom/base/StaticPtr.h">xpcom/base/StaticPtr.h</a></code></td>
   <td></td>
   <td><code>nsRefPtr</code> w/o static constructor</td>
  </tr>
  <tr>
   <td><code>mozilla::UniquePtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/UniquePtr.h">mfbt/UniquePtr.h</a></code></td>
   <td><code>std::unique_ptr</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::WeakPtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/mfbt/WeakPtr.h">mfbt/WeakPtr.h</a></code></td>
   <td><code>std::weak_ptr</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>nsWeakPtr</code></td>
   <td><code><a href="https://searchfox.org/mozilla-central/source/xpcom/base/nsWeakPtr.h">xpcom/base/nsWeakPtr.h</a></code></td>
   <td><code>std::weak_ptr</code></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h3 id="Strings">Strings</h3>

<p>See the <a href="/en-US/docs/Mozilla/Tech/XPCOM/Guide/Internal_strings">Mozilla internal string guide</a> for usage of <code>nsAString</code> (our copy-on-write replacement for <code>std::u16string</code>) and <code>nsACString</code> (our copy-on-write replacement for <code>std::string</code>).</p>

<p>Be sure not to introduce further uses of <code>std::wstring</code>, which is not portable! (Some uses exist in the IPC code.)</p>

<h3 id="Algorithms">Algorithms</h3>

<p><code>mozilla::BinarySearch</code> mfbt/BinarySearch.h<br>
 <code>mozilla::BitwiseCast</code> mfbt/Casting.h (strict aliasing-safe cast)<br>
 mozilla/MathAlgorithms.h (rotate, ctlz, popcount, gcd, abs, lcm)<br>
 <code>mozilla::RollingMean</code> mfbt/RollingMean.h ()</p>

<h3 id="Concurrency">Concurrency</h3>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Name</th>
   <th scope="col">Header</th>
   <th scope="col">STL/boost equivalent</th>
   <th scope="col">Notes</th>
  </tr>
  <tr>
   <td><code>mozilla::Atomic</code></td>
   <td>mfbt/Atomic.h</td>
   <td><code>std::atomic</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::CondVar</code></td>
   <td>xpcom/threads/CondVar.h</td>
   <td><code>std::condition_variable</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::DataMutex</code></td>
   <td>xpcom/threads/DataMutex.h</td>
   <td><code>boost::synchronized_value</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::Monitor</code></td>
   <td>xpcom/threads/Monitor.h</td>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::Mutex</code></td>
   <td>xpcom/threads/Mutex.h</td>
   <td><code>std::mutex</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::ReentrantMonitor</code></td>
   <td>xpcom/threads/ReentrantMonitor.h</td>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::StaticMutex</code></td>
   <td>xpcom/base/StaticMutex.h</td>
   <td><code>std::mutex</code></td>
   <td>Mutex that can (and in fact, must) be used as a global/static variable.</td>
  </tr>
 </thead>
</table>

<h3 id="Miscellaneous">Miscellaneous</h3>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Name</th>
   <th scope="col">Header</th>
   <th scope="col">STL/boost equivalent</th>
   <th scope="col">Notes</th>
  </tr>
  <tr>
   <td><code>mozilla::AlignedStorage</code></td>
   <td>mfbt/Alignment.h</td>
   <td><code>std::aligned_storage</code></td>
   <td></td>
  </tr>
  <tr>
   <td><code>mozilla::MaybeOneOf</code></td>
   <td>mfbt/MaybeOneOf.h</td>
   <td><code>std::optional&lt;std::variant&lt;T1, T2&gt;&gt;</code></td>
   <td>~<code>mozilla::Maybe&lt;union {T1, T2}&gt;</code></td>
  </tr>
  <tr>
   <td><code>mozilla::Pair</code></td>
   <td>mfbt/Pair.h</td>
   <td><code>std::tuple&lt;T1, T2&gt;</code></td>
   <td>minimal space!</td>
  </tr>
  <tr>
   <td><code>mozilla::TimeStamp</code></td>
   <td>xpcom/ds/TimeStamp.h</td>
   <td><code>std::chrono::time_point</code></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/TypeTraits.h</td>
   <td><code>&lt;type_traits&gt;</code></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/PodOperations.h</td>
   <td></td>
   <td>C++ versions of <code>memset</code>, <code>memcpy</code>, etc.</td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/ArrayUtils.h</td>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/Compression.h</td>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/Endian.h</td>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/FloatingPoint.h</td>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/HashFunctions.h</td>
   <td><code>std::hash</code></td>
   <td></td>
  </tr>
  <tr>
   <td></td>
   <td>mozilla/Move.h</td>
   <td><code>std::move</code>, <code>std::swap</code>, <code>std::forward</code></td>
   <td></td>
  </tr>
 </thead>
</table>

<h3 class="editable" id="Mozilla_data_structures_and_standard_C_ranges_and_iterators">Mozilla data structures and standard C++ ranges and iterators</h3>

<p>Some Mozilla-defined data structures provide STL-style <a href="https://en.cppreference.com/w/cpp/named_req/Iterator">iterators</a> and are usable in <a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for loops</a> as well as STL <a href="https://en.cppreference.com/w/cpp/algorithm">algorithms</a>.</p>

<p>Currently, these include:</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Name</th>
   <th scope="col">Header</th>
   <th scope="col">Bug(s)</th>
   <th scope="col">Iterator category</th>
   <th scope="col">Notes</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>nsTArray</code></td>
   <td><code>xpcom/ds/nsTArray.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1126552">1126552</a></td>
   <td>Random-access</td>
   <td>
    <p>Also reverse-iterable.<br>
     Also supports remove-erase pattern via RemoveElementsAt method.<br>
     Also supports back-inserting output iterators via <code>MakeBackInserter</code> function.</p>
   </td>
  </tr>
  <tr>
   <td>
    <p><code>nsBaseHashtable</code> and subclasses:<br>
     <code>nsClassHashtable</code><br>
     <code>nsDataHashtable</code><br>
     <code>nsInterfaceHashtable</code><br>
     <code>nsJSThingHashtable</code><br>
     <code>nsRefPtrHashtable</code></p>
   </td>
   <td>
    <p><code>xpcom/ds/nsBaseHashtable.h<br>
     xpcom/ds/nsClassHashtable.h<br>
     xpcom/ds/nsDataHashtable.h<br>
     xpcom/ds/nsInterfaceHashtable.h<br>
     xpcom/ds/nsJSThingHashtable.h<br>
     xpcom/ds/nsRefPtrHashtable.h</code></p>
   </td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1575479">1575479</a></td>
   <td>Forward</td>
   <td></td>
  </tr>
  <tr>
   <td><code>nsCOMArray</code></td>
   <td><code>xpcom/ds/nsCOMArray.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1342303">1342303</a></td>
   <td>Random-access</td>
   <td>Also reverse-iterable.</td>
  </tr>
  <tr>
   <td>
    <p><code>Array<br>
     EnumerationArray<br>
     RangedArray</code></p>
   </td>
   <td>
    <p><code>mfbt/Array.h<br>
     mfbt/EnumerationArray.h<br>
     mfbt/RangedArray.h</code></p>
   </td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1216041">1216041</a></td>
   <td>Random-access</td>
   <td>Also reverse-iterable.</td>
  </tr>
  <tr>
   <td><code>Buffer</code></td>
   <td><code>mfbt/Buffer.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1512155">1512155</a></td>
   <td>Random-access</td>
   <td>Also reverse-iterable.</td>
  </tr>
  <tr>
   <td><code>DoublyLinkedList</code></td>
   <td><code>mfbt/DoublyLinkedList.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1277725">1277725</a></td>
   <td>Forward</td>
   <td></td>
  </tr>
  <tr>
   <td><code>EnumeratedRange</code></td>
   <td><code>mfbt/EnumeratedRange.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1142999">1142999</a></td>
   <td><em>Missing</em></td>
   <td>Also reverse-iterable.</td>
  </tr>
  <tr>
   <td><code>IntegerRange</code></td>
   <td><code>mfbt/IntegerRange.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1126701">1126701</a></td>
   <td><em>Missing</em></td>
   <td>Also reverse-iterable.</td>
  </tr>
  <tr>
   <td><code>SmallPointerArray</code></td>
   <td><code>mfbt/SmallPointerArray.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1331718">1331718</a></td>
   <td>Random-access</td>
   <td></td>
  </tr>
  <tr>
   <td><code>Span</code></td>
   <td><code>mfbt/Span.h</code></td>
   <td><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1295611">1295611</a></td>
   <td>Random-access</td>
   <td>Also reverse-iterable.</td>
  </tr>
 </tbody>
</table>

<p class="editable">Note that if the iterator category is stated as "missing", the type is probably only usable in range-based for. This is most likely just an omission, which could be easily fixed.</p>

<p class="editable">Useful in this context are also the class template <code>IteratorRange</code> (which can be used to construct a range from any pair of iterators) and function template <code>Reversed</code> (which can be used to reverse any range), both defined in <code>mfbt/ReverseIterator.h</code></p>

<h2 class="editable" id="Further_C_rules">Further C++ rules</h2>

<h3 id="Dont_use_static_constructors">Don't use static constructors</h3>

<p>(You probably shouldn't be using global variables to begin with. Quite apart from the weighty software-engineering arguments against them, globals affect startup time! But sometimes we have to do ugly things.)</p>

<p>Non-portable example:</p>

<pre class="code">FooBarClass static_object(87, 92);

void
bar()
{
  if (static_object.count &gt; 15) {
     ...
  }
}
</pre>

<p>Once upon a time, there were compiler bugs that could result in constructors not being called for global objects. Those bugs are probably long gone by now, but even with the feature working correctly, there are so many problems with correctly ordering C++ constructors that it's easier to just have an init function:</p>

<pre class="code">static FooBarClass* static_object;

FooBarClass*
getStaticObject()
{
  if (!static_object)
    static_object =
      new FooBarClass(87, 92);
  return static_object;
}

void
bar()
{
  if (getStaticObject()-&gt;count &gt; 15) {
    ...
  }
}
</pre>

<h3 class="editable" id="Dont_use_exceptions">Don't use exceptions</h3>

<p>See the introduction to the "C++ language features" section at the start of this document.</p>

<h3 class="editable" id="Dont_use_Run-time_Type_Information">Don't use Run-time Type Information</h3>

<p>See the introduction to the "C++ language features" section at the start of this document.</p>

<p>If you need runtime typing, you can achieve a similar result by adding a <code>classOf()</code> virtual member function to the base class of your hierarchy and overriding that member function in each subclass. If <code>classOf()</code> returns a unique value for each class in the hierarchy, you'll be able to do type comparisons at runtime.</p>

<h3 class="editable" id="Dont_use_the_C_standard_library_including_iostream_and_locale">Don't use the C++ standard library (including iostream and locale)</h3>

<p>See the section "C++ and Mozilla standard libraries".</p>

<h3 class="editable" id="Use_C_lambdas_but_with_care">Use C++ lambdas, but with care</h3>

<p>C++ lambdas are supported across all our compilers now.  Rejoice!  We recommend explicitly listing out the variables that you capture in the lambda, both for documentation purposes, and to double-check that you're only capturing what you expect to capture.</p>

<h3 class="editable" id="Use_namespaces">Use namespaces</h3>

<p>Namespaces may be used according to the style guidelines in <a class="internal" href="https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/Coding_Style" rel="internal">Mozilla Coding Style Guide</a>.</p>

<h3 class="editable" id="Dont_mix_varargs_and_inlines">Don't mix varargs and inlines</h3>

<p>What? Why are you using varargs to begin with?! Stop that at once!</p>

<h3 id="Make_header_files_compatible_with_C_and_C">Make header files compatible with C and C++</h3>

<p>Non-portable example:</p>

<pre class="code">/*oldCheader.h*/
int existingCfunction(char*);
int anotherExistingCfunction(char*);

/* oldCfile.c */
#include "oldCheader.h"
...

// new file.cpp
extern "C" {
#include "oldCheader.h"
};
...
</pre>

<p>If you make new header files with exposed C interfaces, make the header files work correctly when they are included by both C and C++ files.</p>

<p>(If you need to include a C header in new C++ files, that should just work. If not, it's the C header maintainer's fault, so fix the header if you can, and if not, whatever hack you come up with will probably be fine.)</p>

<p>Portable example:</p>

<pre class="code">/* oldCheader.h*/
PR_BEGIN_EXTERN_C
int existingCfunction(char*);
int anotherExistingCfunction(char*);
PR_END_EXTERN_C

/* oldCfile.c */
#include "oldCheader.h"
...

// new file.cpp
#include "oldCheader.h"
...
</pre>

<p>There are number of reasons for doing this, other than just good style. For one thing, you are making life easier for everyone else, doing the work in one common place (the header file) instead of all the C++ files that include it. Also, by making the C header safe for C++, you document that "hey, this file is now being included in C++". That's a good thing. You also avoid a big portability nightmare that is nasty to fix...</p>

<h3 id="Use_override_on_subclass_virtual_member_functions">Use override on subclass virtual member functions</h3>

<p>The <code>override</code> keyword is supported in C++11 and in all our supported compilers, and it catches bugs.</p>

<h3 id="Always_declare_a_copy_constructor_and_assignment_operator">Always declare a copy constructor and assignment operator</h3>

<p>Many classes shouldn't be copied or assigned. If you're writing one of these, the way to enforce your policy is to declare a deleted copy constructor as private and not supply a definition. While you're at it, do the same for the assignment operator used for assignment of objects of the same class. Example:</p>

<pre class="code">class Foo {
  ...
  private:
    Foo(const Foo&amp; x) = delete;
    Foo&amp; operator=(const Foo&amp; x) = delete;
};
</pre>

<p>Any code that implicitly calls the copy constructor will hit a compile-time error. That way nothing happens in the dark. When a user's code won't compile, they'll see that they were passing by value, when they meant to pass by reference (oops).</p>

<h3 class="editable" id="Be_careful_of_overloaded_methods_with_like_signatures">Be careful of overloaded methods with like signatures</h3>

<p>It's best to avoid overloading methods when the type signature of the methods differs only by one "abstract" type (e.g. <code>PR_Int32</code> or <code>int32</code>). What you will find as you move that code to different platforms, is suddenly on the Foo2000 compiler your overloaded methods will have the same type-signature.</p>

<h3 class="editable" id="Type_scalar_constants_to_avoid_unexpected_ambiguities">Type scalar constants to avoid unexpected ambiguities</h3>

<p>Non-portable code:</p>

<pre class="code">class FooClass {
  // having such similar signatures
  // is a bad idea in the first place.
  void doit(long);
  void doit(short);
};

void
B::foo(FooClass* xyz)
{
  xyz-&gt;doit(45);
}
</pre>

<p>Be sure to type your scalar constants, e.g., <code>uint32_t(10)</code> or <code>10L</code>. Otherwise, you can produce ambiguous function calls which potentially could resolve to multiple methods, particularly if you haven't followed (2) above. Not all of the compilers will flag ambiguous method calls.</p>

<p>Portable code:</p>

<pre class="code">class FooClass {
  // having such similar signatures
  // is a bad idea in the first place.
  void doit(long);
  void doit(short);
};

void
B::foo(FooClass* xyz)
{
  xyz-&gt;doit(45L);
}
</pre>

<h3 id="Use_nsCOMPtr_in_XPCOM_code">Use nsCOMPtr in XPCOM code</h3>

<p>See the <code>nsCOMPtr</code> <a href="https://developer.mozilla.org/en-US/docs/Using_nsCOMPtr" rel="internal">User Manual</a> for usage details.</p>

<h3 class="editable" id="Dont_use_identifiers_that_start_with_an_underscore">Don't use identifiers that start with an underscore</h3>

<p>This rule occasionally surprises people who've been hacking C++ for decades. But it comes directly from the C++ standard!</p>

<p>According to the C++ Standard, 17.4.3.1.2 Global Names [lib.global.names], paragraph 1:</p>

<p>Certain sets of names and function signatures are always reserved to the implementation:</p>

<ul>
 <li>Each name that contains a double underscore (__) or begins with an underscore followed by an uppercase letter (2.11) is reserved to the implementation for any use.</li>
 <li><strong>Each name that begins with an underscore is reserved to the implementation</strong> for use as a name in the global namespace.</li>
</ul>

<h2 class="editable" id="Stuff_that_is_good_to_do_for_C_or_C">Stuff that is good to do for C or C++</h2>

<h3 id="Avoid_conditional_includes_when_possible">Avoid conditional #includes when possible</h3>

<p>Don't write an <code>#include</code> inside an <code>#ifdef</code> if you could instead put it outside. Unconditional includes are better because they make the compilation more similar across all platforms and configurations, so you're less likely to cause stupid compiler errors on someone else's favorite platform that you never use.</p>

<p>Bad code example:</p>

<pre class="code">#ifdef MOZ_ENABLE_JPEG_FOUR_BILLION
#include &lt;stdlib.h&gt;   // &lt;--- don't do this
#include "jpeg4e9.h"  // &lt;--- only do this if the header really might not be there
#endif
</pre>

<p>Of course when you're including different system files for different machines, you don't have much choice. That's different.</p>

<h3 class="editable" id="Every_.cpp_source_file_should_have_a_unique_name">Every .cpp source file should have a unique name</h3>

<p>Every object file linked into libxul needs to have a unique name. Avoid generic names like nsModule.cpp and instead use nsPlacesModule.cpp.</p>

<h3 class="editable" id="Turn_on_warnings_for_your_compiler_and_then_write_warning_free_code">Turn on warnings for your compiler, and then write warning free code</h3>

<p>What generates a warning on one platform will generate errors on another. Turn warnings on. Write warning-free code. It's good for you. Treat warnings as errors by adding <code>ac_add_options --enable-warnings-as-errors</code> to your mozconfig file.</p>

<h3 class="editable" id="Use_the_same_type_for_all_bitfields_in_a_struct_or_class">Use the same type for all bitfields in a <code>struct</code> or <code>class</code></h3>

<p>Some compilers do not pack the bits when different bitfields are given different types. For example, the following struct might have a size of 8 bytes, even though it would fit in 1:</p>

<pre class="code">struct {
  char ch : 1;
  int i : 1;
};
</pre>

<h3 id="Dont_use_an_enum_type_for_a_bitfield"><span>Don't use an enum type for a bitfield</span></h3>

<p>The classic example of this is using <code>PRBool</code> for a boolean bitfield. Don't do that. <code>PRBool</code> is a signed integer type, so the bitfield's value when set will be <code>-1</code> instead of <code>+1</code>, which---I know, <em>crazy</em>, right? The things C++ hackers used to have to put up with...</p>

<p>You shouldn't be using <code>PRBool</code> anyway. Use <code>bool</code>. Bitfields of type <code>bool</code> are fine.</p>

<p>Enums are signed on some platforms (in some configurations) and unsigned on others and therefore unsuitable for writing portable code when every bit counts, even if they happen to work on your system.</p>