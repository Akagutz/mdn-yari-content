<div>{{JsSidebar("More")}}</div>

<p>Esta página describe la gramática léxica de JavaScript. El texto de origen de las secuencias de órdenes ECMAScript se analiza de izquierda a derecha y se convierte en una secuencia de elementos de entrada tales como fichas, caracteres de control, finalizadores de renglón, comentarios y espacios en blanco. ECMAScript define asimismo determinadas palabras claves y literales y cuenta con reglas de inserción automática de punto y coma para finalizar declaraciones.</p>

<h2 id="Caracteres_de_control">Caracteres de control</h2>

<p>Los caracteres de control no tienen ninguna representación visula pero se utilizan para controlar la interpretación del texto</p>

<table class="standard-table">
 <caption>Caracteres de control de formato en Unicode</caption>
 <tbody>
  <tr>
   <th>Punto de código</th>
   <th>Nombre</th>
   <th>Abreviatura</th>
   <th>Descripción</th>
  </tr>
  <tr>
   <td><code>U+200C</code></td>
   <td>Zero width non-joiner</td>
   <td>&lt;ZWNJ&gt;</td>
   <td>Placed between characters to prevent being connected into ligatures in certain languages (<a href="http://en.wikipedia.org/wiki/Zero-width_non-joiner">Wikipedia</a>).</td>
  </tr>
  <tr>
   <td><code>U+200D</code></td>
   <td>Zero width joiner</td>
   <td>&lt;ZWJ&gt;</td>
   <td>Placed between characters that would not normally be connected in order to cause the characters to be rendered using their connected form in certain languages (<a href="http://en.wikipedia.org/wiki/Zero-width_joiner">Wikipedia</a>).</td>
  </tr>
  <tr>
   <td><code>U+FEFF</code></td>
   <td>Byte order mark</td>
   <td>&lt;BOM&gt;</td>
   <td>Used at the start of the script to mark it as Unicode and the text's byte order (<a href="http://en.wikipedia.org/wiki/Byte_order_mark">Wikipedia</a>).</td>
  </tr>
 </tbody>
</table>

<h2 id="Espacio_en_blanco">Espacio en blanco</h2>

<p>Los caracteres de espacio en blanco mejoran la legibilidad del texto fuente y separan las fichas las unas de las otras. Estos caracteres no suelen ser necesarios para la funcionalidad del código. A menudo se utilizan <a href="http://en.wikipedia.org/wiki/Minification_%28programming%29">herramientas miniaturizadoras</a> para quitar el espacio en blanco y así reducir la cantidad de datos que debe transmitirse.</p>

<table class="standard-table">
 <caption>Caracteres de espacio en blanco</caption>
 <tbody>
  <tr>
   <th>Punto de código</th>
   <th>Nombre</th>
   <th>Abreviatura</th>
   <th>Descripción</th>
   <th>Secuencia de escape</th>
  </tr>
  <tr>
   <td>U+0009</td>
   <td>Character tabulation</td>
   <td>&lt;HT&gt;</td>
   <td>Horizontal tabulation</td>
   <td>\t</td>
  </tr>
  <tr>
   <td>U+000B</td>
   <td>Line tabulation</td>
   <td>&lt;VT&gt;</td>
   <td>Vertical tabulation</td>
   <td>\v</td>
  </tr>
  <tr>
   <td>U+000C</td>
   <td>Form feed</td>
   <td>&lt;FF&gt;</td>
   <td>Page breaking control character (<a href="http://en.wikipedia.org/wiki/Page_break#Form_feed">Wikipedia</a>).</td>
   <td>\f</td>
  </tr>
  <tr>
   <td>U+0020</td>
   <td>Space</td>
   <td>&lt;SP&gt;</td>
   <td>Normal space</td>
   <td></td>
  </tr>
  <tr>
   <td>U+00A0</td>
   <td>No-break space</td>
   <td>&lt;NBSP&gt;</td>
   <td>Normal space, but no point at which a line may break</td>
   <td></td>
  </tr>
  <tr>
   <td>Others</td>
   <td>Other Unicode space characters</td>
   <td>&lt;USP&gt;</td>
   <td><a href="http://en.wikipedia.org/wiki/Space_%28punctuation%29#Spaces_in_Unicode">Spaces in Unicode on Wikipedia</a></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Finalizadores_de_renglón">Finalizadores de renglón</h2>

<p>Como los caracteres de espacio en blanco, los caracteres finalizadores de renglón permiten mejorar la legibilidad del texto fuente. Sin embargo, en algunos casos, los finalizadores de renglón pueden influir en la ejecución del código JavaScript, dado que hay algunos sitios donde están prohibidos. Los finalizadores de renglón también afectan el proceso de <a href="#Automatic_semicolon_insertion">inserción automática de punto y coma</a>. Los finalizadores de renglón pueden encontrarse mediante la clase <strong>\s</strong> en las <a href="/en-US/docs/Web/JavaScript/Guide/Regular_Expressions">expresiones regulares</a>.</p>

<p>Únicamente los puntos de código de Unicode enumerados a continuación se reconocen como finalizadores de renglón en ECMAScript; otros caracteres de salto de renglón se tratan como si fuesen espacio en blanco (por ejemplo, Próximo renglón, NEL, U+0085 se considera espacio en blanco).</p>

<table class="standard-table">
 <caption>Caracteres finalizadores de renglón</caption>
 <tbody>
  <tr>
   <th>Punto de código</th>
   <th>Nombre</th>
   <th>Abreviatura</th>
   <th>Descripción</th>
   <th>Secuencia de escape</th>
  </tr>
  <tr>
   <td>U+000A</td>
   <td>Line Feed</td>
   <td>&lt;LF&gt;</td>
   <td>New line character in UNIX systems.</td>
   <td>\n</td>
  </tr>
  <tr>
   <td>U+000D</td>
   <td>Carriage Return</td>
   <td>&lt;CR&gt;</td>
   <td>New line character in Commodore and early Mac systems.</td>
   <td>\r</td>
  </tr>
  <tr>
   <td>U+2028</td>
   <td>Line Separator</td>
   <td>&lt;LS&gt;</td>
   <td><a href="http://en.wikipedia.org/wiki/Newline">Wikipedia</a></td>
   <td></td>
  </tr>
  <tr>
   <td>U+2029</td>
   <td>Paragraph Separator</td>
   <td>&lt;PS&gt;</td>
   <td><a href="http://en.wikipedia.org/wiki/Newline">Wikipedia</a></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Comentarios">Comentarios</h2>

<p>Los comentarios permiten añadir pistas, notas, sugerencias o alertas al código en JavaScript, lo que puede facilitar su lectura y comprensión. También permiten desactivar código para evitar su ejecución; visto así, puede constituir una valiosa herramienta de depuración.</p>

<p>JavaScript por mucho tiempo ha contado con dos maneras de añadir comentarios al código.</p>

<p>La primera es el comentario <code>//</code>; todo el texto que se sitúe tras estos dos caracteres en el mismo renglón serán un comentario. Por ejemplo:</p>

<pre class="brush: js">function comment() {
  // Este es un comentario en JavaScript de un renglón
  console.log('Hello world!');
}
comment();
</pre>

<p>El segundo método es el estilo <code>/* */</code>, mucho más flexible.</p>

<p>Por ejemplo, se puede emplear en un solo renglón:</p>

<pre class="brush: js">function comment() {
  /* Este es un comentario en JavaScript de un renglón */
  console.log('Hello world!');
}
comment();</pre>

<p>También puede ampliar un comentario por varios renglones:</p>

<pre class="brush: js">function comment() {
  /* Este comentario abarca varios renglones. Observe que no
     hace falta finalizar el comentario si no hemos terminado. */
  console.log('Hello world!');
}
comment();</pre>

<p>Además puede emplearse en medio de un renglón, si lo prefiere, aunque esto podría dificultar la lectura del código; utilícelo con precaución:</p>

<pre class="brush: js">function comment(x) {
  console.log('Hello ' + x /* insertar valor de x */ + ' !');
}
comment('world');</pre>

<p>Asimismo, meter código en un comentario desactivará su ejecución:</p>

<pre class="brush: js">function comment() {
  /* console.log('Hello world!'); */
}
comment();</pre>

<p>En este caso, no se emite nunca la llamada <code>console.log()</code>, dado que está encerrada en un comentario. De este modo es posible desactivar cualquier cantidad de renglones de código.</p>

<h2 id="Comentarios_hashbang">Comentarios <em>hashbang</em></h2>

<p>Una tercera sintaxis, el <strong>comentario <em>hashbang</em></strong>, está en vías de ser estandarizada en ECMAScript para propósitos especializados (consulte la <a href="https://github.com/tc39/proposal-hashbang">propuesta Gramática <em>hashbang</em></a>).</p>

<p>Un comentario <em>hashbang</em> se comporta de la misma manera que uno de renglón único (<code>//</code>), pero comienza con <code>#!</code> y <strong>únicamente es válido en el comienzo absoluto de una secuencia de órdenes o un módulo</strong>. Tampoco se permite añadir espacios en blanco de ningún tipo antes de <code>#!</code>. El comentario consta de todos los caracteres tras <code>#!</code> hasta el término del renglón; solo se permite uno de estos comentarios.</p>

<p>El comentario <em>hashbang</em> especifica la ruta hacia un intérprete de JavaScript concreto que quiere utilizar para ejecutar la secuencia de órdenes. He aquí un ejemplo:</p>

<pre class="brush: js">#!/usr/bin/env node

console.log("Hello world");
</pre>

<div class="blockIndicator note">
<p><strong>Nota</strong>: los comentarios <em>hashbang</em> en JavaScript imitan a los <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)"><em>shebangs</em> de Unix</a>, utilizados para ejecutar archivos con el intérprete correcto.</p>
</div>

<div class="blockIndicator warning">
<p>Aunque el <a href="https://en.wikipedia.org/wiki/Byte_order_mark">BOM</a> situado antes del comentario <em>hashbang</em> funcionará en un navegador, no se aconseja utilizar BOM en una secuencia de órdenes con <em>hasbang</em>. El BOM no funcionará cuando intente ejecutar la secuencia de órdenes en Unix/Linux. Utilice UTF-8 sin BOM si quiere ejecutar secuencias de órdenes directamente desde la consola.</p>
</div>

<p>You must only use the <code>#!</code> comment style to specify a JavaScript interpreter. In all other cases just use a <code>//</code> comment (or mulitiline comment).</p>

<h2 id="Palabras_clave">Palabras clave</h2>

<h3 id="Palabras_clave_desde_ECMAScript_2015">Palabras clave desde ECMAScript 2015</h3>

<ul class="threecolumns">
 <li>{{jsxref("Statements/break", "break")}}</li>
 <li>{{jsxref("Statements/switch", "case")}}</li>
 <li>{{jsxref("Statements/try...catch", "catch")}}</li>
 <li>{{jsxref("Statements/class", "class")}}</li>
 <li>{{jsxref("Statements/const", "const")}}</li>
 <li>{{jsxref("Statements/continue", "continue")}}</li>
 <li>{{jsxref("Statements/debugger", "debugger")}}</li>
 <li>{{jsxref("Statements/default", "default")}}</li>
 <li>{{jsxref("Operators/delete", "delete")}}</li>
 <li>{{jsxref("Statements/do...while", "do")}}</li>
 <li>{{jsxref("Statements/if...else", "else")}}</li>
 <li>{{jsxref("Statements/export", "export")}}</li>
 <li>{{jsxref("Statements/class", "extends")}}</li>
 <li>{{jsxref("Statements/try...catch", "finally")}}</li>
 <li>{{jsxref("Statements/for", "for")}}</li>
 <li>{{jsxref("Statements/function", "function")}}</li>
 <li>{{jsxref("Statements/if...else", "if")}}</li>
 <li>{{jsxref("Statements/import", "import")}}</li>
 <li>{{jsxref("Operators/in", "in")}}</li>
 <li>{{jsxref("Operators/instanceof", "instanceof")}}</li>
 <li>{{jsxref("Operators/new", "new")}}</li>
 <li>{{jsxref("Statements/return", "return")}}</li>
 <li>{{jsxref("Operators/super", "super")}}</li>
 <li>{{jsxref("Statements/switch", "switch")}}</li>
 <li>{{jsxref("Operators/this", "this")}}</li>
 <li>{{jsxref("Statements/throw", "throw")}}</li>
 <li>{{jsxref("Statements/try...catch", "try")}}</li>
 <li>{{jsxref("Operators/typeof", "typeof")}}</li>
 <li>{{jsxref("Statements/var", "var")}}</li>
 <li>{{jsxref("Operators/void", "void")}}</li>
 <li>{{jsxref("Statements/while", "while")}}</li>
 <li>{{jsxref("Statements/with", "with")}}</li>
 <li>{{jsxref("Operators/yield", "yield")}}</li>
</ul>

<h3 id="Futuras_palabras_clave_reservadas">Futuras palabras clave reservadas</h3>

<p>The following are reserved as future keywords by the ECMAScript specification. They have no special functionality at present, but they might at some future time, so they cannot be used as identifiers.</p>

<p>These are always reserved:</p>

<ul>
 <li><code>enum</code></li>
</ul>

<p>The following are only reserved when they are found in strict mode code:</p>

<ul class="threecolumns">
 <li><code>implements</code></li>
 <li><code>interface</code></li>
 <li>{{jsxref("Statements/let", "let")}}</li>
 <li><code>package</code></li>
 <li><code>private</code></li>
 <li><code>protected</code></li>
 <li><code>public</code></li>
 <li><code>static</code></li>
</ul>

<p>The following are only reserved when they are found in module code:</p>

<ul>
 <li><code>await</code></li>
</ul>

<h4 id="Futuras_palabras_clave_reservadas_en_normas_anteriores">Futuras palabras clave reservadas en normas anteriores</h4>

<p>The following are reserved as future keywords by older ECMAScript specifications (ECMAScript 1 till 3).</p>

<ul class="threecolumns">
 <li><code>abstract</code></li>
 <li><code>boolean</code></li>
 <li><code>byte</code></li>
 <li><code>char</code></li>
 <li><code>double</code></li>
 <li><code>final</code></li>
 <li><code>float</code></li>
 <li><code>goto</code></li>
 <li><code>int</code></li>
 <li><code>long</code></li>
 <li><code>native</code></li>
 <li><code>short</code></li>
 <li><code>synchronized</code></li>
 <li><code>throws</code></li>
 <li><code>transient</code></li>
 <li><code>volatile</code></li>
</ul>

<p>Additionally, the literals <code>null</code>, <code>true</code>, and <code>false</code> cannot be used as identifiers in ECMAScript.</p>

<h3 id="Uso_de_palabras_reservado">Uso de palabras reservado</h3>

<p>Reserved words actually only apply to Identifiers (vs. <code>IdentifierNames</code>) . As described in <a href="http://es5.github.com/#A.1">es5.github.com/#A.1</a>, these are all <code>IdentifierNames</code> which do not exclude <code>ReservedWords</code>.</p>

<pre class="brush: js">a.import
a['import']
a = { import: 'test' }.
</pre>

<p>On the other hand the following is illegal because it's an <code>Identifier</code>, which is an <code>IdentifierName</code> without the reserved words. Identifiers are used for <code>FunctionDeclaration, FunctionExpression, VariableDeclaration</code> and so on. <code>IdentifierNames </code>are used for<code> MemberExpression, CallExpression</code> and so on.</p>

<pre class="brush: js">function import() {} // Illegal.</pre>

<h2 id="Literales">Literales</h2>

<h3 id="Literal_nulo">Literal nulo</h3>

<p>See also {{jsxref("null")}} for more information.</p>

<pre class="brush: js">null</pre>

<h3 id="Literal_booleano">Literal booleano</h3>

<p>See also {{jsxref("Boolean")}} for more information.</p>

<pre class="brush: js">true
false</pre>

<h3 id="Literales_numéricos">Literales numéricos</h3>

<p>The {{jsxref("Number")}} and {{jsxref("BigInt")}} types use numeric literals.</p>

<h4 id="Decimal">Decimal</h4>

<pre class="brush: js">1234567890
42

// Caution when using with a leading zero:
0888 // 888 parsed as decimal
0777 // parsed as octal, 511 in decimal
</pre>

<p>Note that decimal literals can start with a zero (<code>0</code>) followed by another decimal digit, but If all digits after the leading <code>0</code> are smaller than 8, the number is interpreted as an octal number. This won't throw in JavaScript, see {{bug(957513)}}. See also the page about {{jsxref("parseInt", "parseInt()")}}</p>

<h4 id="Binario">Binario</h4>

<p>Binary number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "B" (<code>0b</code> or <code>0B</code>). Because this syntax is new in ECMAScript 2015, see the browser compatibility table, below. If the digits after the <code>0b</code> are not 0 or 1, the following {{jsxref("SyntaxError")}} is thrown: "Missing binary digits after 0b".</p>

<pre class="brush: js">var FLT_SIGNBIT  = 0b10000000000000000000000000000000; // 2147483648
var FLT_EXPONENT = 0b01111111100000000000000000000000; // 2139095040
var FLT_MANTISSA = 0B00000000011111111111111111111111; // 8388607</pre>

<h4 id="Octal">Octal</h4>

<p>Octal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "O" (<code>0o</code> or <code>0O)</code>. Because this syntax is new in ECMAScript 2015, see the browser compatibility table, below. If the digits after the <code>0o</code> are outside the range (01234567), the following {{jsxref("SyntaxError")}} is thrown: "Missing octal digits after 0o".</p>

<pre class="brush: js">var n = 0O755; // 493
var m = 0o644; // 420

// Also possible with just a leading zero (see note about decimals above)
0755
0644
</pre>

<h4 id="Hexadecimal">Hexadecimal</h4>

<p>Hexadecimal number syntax uses a leading zero followed by a lowercase or uppercase Latin letter "X" (<code>0x</code> or <code>0X)</code>. If the digits after 0x are outside the range (0123456789ABCDEF), the following {{jsxref("SyntaxError")}} is thrown: "Identifier starts immediately after numeric literal".</p>

<pre class="brush: js">0xFFFFFFFFFFFFFFFFF // 295147905179352830000
0x123456789ABCDEF   // 81985529216486900
0XA                 // 10
</pre>

<h4 id="Literal_BigInt">Literal BigInt</h4>

<p>The {{jsxref("BigInt")}} type is a numeric primitive in JavaScript that can represent integers with arbitrary precision. BigInt literals are created by appending <code>n</code> to the end of an integer.</p>

<pre class="brush: js">123456789123456789n     (decimal, base 10)
0o777777777777n         (octal, base 8)
0x123456789ABCDEFn      (hexadecimal, "hex" or base 16)
0b11101001010101010101n (binary, base 2)
</pre>

<p>Note that legacy octal numbers with just a leading zero won't work for <code>BigInt</code>:</p>

<pre class="brush: js example-bad">// 0755n
// SyntaxError: invalid BigInt syntax</pre>

<p>For octal <code>BigInt</code> numbers, always use zero followed by the letter "o" (uppercase or lowercase):</p>

<pre class="brush: js example-good">0o755n</pre>

<p>For more information about <code>BigInt</code>, see also <a href="/en-US/docs/Web/JavaScript/Data_structures#BigInt_type">JavaScript data structures</a>.</p>

<h4 id="Separadores_numéricos">Separadores numéricos</h4>

<p>To improve readability for numeric literals, underscores (<code>_</code>, <code>U+005F</code>) can be used as separators:</p>

<pre class="brush: js">// separators in decimal numbers
1_000_000_000_000
1_050.95

// separators in binary numbers
0b1010_0001_1000_0101

// separators in octal numbers
0o2_2_5_6

// separators in hex numbers
0xA0_B0_C0

// separators in BigInts
1_000_000_000_000_000_000_000n
</pre>

<p>Cabe tener en cuenta estas limitaciones:</p>

<pre class="brush: js example-bad">// More than one underscore in a row is not allowed
100__000; // SyntaxError

// Not allowed at the end of numeric literals
100_; // SyntaxError

// Can not be used after leading 0
0_1; // SyntaxError
</pre>

<h3 id="Literales_para_objetos">Literales para objetos</h3>

<p>See also {{jsxref("Object")}} and <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer">Object initializer</a> for more information.</p>

<pre class="brush: js">var o = { a: 'foo', b: 'bar', c: 42 };

// shorthand notation. New in ES2015
var a = 'foo', b = 'bar', c = 42;
var o = {a, b, c};

// instead of
var o = { a: a, b: b, c: c };
</pre>

<h3 id="Literales_para_matrices">Literales para matrices</h3>

<p>See also {{jsxref("Array")}} for more information.</p>

<pre class="brush: js">[1954, 1974, 1990, 2014]</pre>

<h3 id="Literales_para_cadenas">Literales para cadenas</h3>

<p>A string literal is zero or more Unicode code points enclosed in single or double quotes. Unicode code points may also be represented by an escape sequence. All code points may appear literally in a string literal except for these closing quote code points:</p>

<ul>
 <li>U+005C \(backslash),</li>
 <li>U+000D &lt;CR&gt;,</li>
 <li>and U+000A &lt;LF&gt;.</li>
</ul>

<p>Prior to the <a href="https://github.com/tc39/proposal-json-superset">proposal to make all JSON text valid ECMA-262</a>, U+2028 &lt;LS&gt; and U+2029 &lt;PS&gt;, were also disallowed from appearing unescaped in string literals.</p>

<p>Any code points may appear in the form of an escape sequence. String literals evaluate to ECMAScript String values. When generating these String values Unicode code points are UTF-16 encoded.</p>

<pre class="brush: js">'foo'
"bar"</pre>

<h4 id="Secuencias_de_escape_hexadecimales">Secuencias de escape hexadecimales</h4>

<p>Hexadecimal escape sequences consist of <code>\x</code> followed by exactly two hexadecimal digits representing a code unit or code point in the range 0x0000 to 0x00FF.</p>

<pre class="brush: js">'\xA9' // "©"
</pre>

<h4 id="Secuencias_de_escape_Unicode">Secuencias de escape Unicode</h4>

<p>A Unicode escape sequence consists of exactly four hexadecimal digits following <code>\u</code>. It represents a code unit in the UTF-16 encoding. For code points U+0000 to U+FFFF, the code unit is equal to the code point. Code points U+10000 to U+10FFFF require two escape sequences representing the two code units (a surrogate pair) used to encode the character; the surrogate pair is distinct from the code point.</p>

<p>See also {{jsxref("String.fromCharCode()")}} and {{jsxref("String.prototype.charCodeAt()")}}.</p>

<pre class="brush: js">'\u00A9' // "©" (U+A9)</pre>

<h4 id="Escapes_de_puntos_de_código_de_Unicode">Escapes de puntos de código de Unicode</h4>

<p>A Unicode code point escape consists of <code>\u{</code>, followed by a code point in hexadecimal base, followed by <code>}</code>. The value of the hexadecimal digits must be in the range 0 and 0x10FFFF inclusive. Code points in the range U+10000 to U+10FFFF do not need to be represented as a surrogate pair. Code point escapes were added to JavaScript in ECMAScript 2015 (ES6).</p>

<p>See also {{jsxref("String.fromCodePoint()")}} and {{jsxref("String.prototype.codePointAt()")}}.</p>

<pre class="brush: js">'\u{2F804}' // CJK COMPATIBILITY IDEOGRAPH-2F804 (U+2F804)

// the same character represented as a surrogate pair
'\uD87E\uDC04'</pre>

<h3 id="Literales_para_expresiones_regulares">Literales para expresiones regulares</h3>

<p>See also {{jsxref("RegExp")}} for more information.</p>

<pre class="brush: js">/ab+c/g

// An "empty" regular expression literal
// The empty non-capturing group is necessary 
// to avoid ambiguity with single-line comments.
/(?:)/</pre>

<h3 id="Literales_para_plantillas">Literales para plantillas</h3>

<p>See also <a href="/en-US/docs/Web/JavaScript/Reference/template_strings">template strings</a> for more information.</p>

<pre class="brush: js">`string text`

`string text line 1
 string text line 2`

`string text ${expression} string text`

tag `string text ${expression} string text`</pre>

<h2 id="Inserción_automática_de_punto_y_coma">Inserción automática de punto y coma</h2>

<p>Some <a href="/en-US/docs/Web/JavaScript/Reference/Statements">JavaScript statements</a> must be terminated with semicolons and are therefore affected by automatic semicolon insertion (ASI):</p>

<ul>
 <li>Empty statement</li>
 <li><code>let</code>, <code>const</code>, variable statement</li>
 <li><code>import</code>, <code>export</code>, module declaration</li>
 <li>Expression statement</li>
 <li><code>debugger</code></li>
 <li><code>continue</code>, <code>break</code>, <code>throw</code></li>
 <li><code>return</code></li>
</ul>

<p>The ECMAScript specification mentions<a href="https://tc39.github.io/ecma262/#sec-rules-of-automatic-semicolon-insertion"> three rules of semicolon insertion</a>.</p>

<p>1. A semicolon is inserted before, when a <a href="#Line_terminators">Line terminator</a> or "}" is encountered that is not allowed by the grammar.</p>

<pre class="brush: js">{ 1 2 } 3 

// is transformed by ASI into 

{ 1 2 ;} 3;</pre>

<p>2. A semicolon is inserted at the end, when the end of the input stream of tokens is detected and the parser is unable to parse the single input stream as a complete program.</p>

<p>Here <code>++</code> is not treated as a <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Increment">postfix operator</a> applying to variable <code>b</code>, because a line terminator occurs between <code>b</code> and <code>++</code>.</p>

<pre class="brush: js">a = b
++c

// is transformend by ASI into

a = b;
++c;
</pre>

<p>3. A semicolon is inserted at the end, when a statement with restricted productions in the grammar is followed by a line terminator. These statements with "no LineTerminator here" rules are:</p>

<ul>
 <li>PostfixExpressions (<code>++</code> and <code>--</code>)</li>
 <li><code>continue</code></li>
 <li><code>break</code></li>
 <li><code>return</code></li>
 <li><code>yield</code>, <code>yield*</code></li>
 <li><code>module</code></li>
</ul>

<pre class="brush: js">return
a + b

// is transformed by ASI into

return;
a + b;
</pre>

<h2 id="Especificaciones">Especificaciones</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Especificación</th>
   <th scope="col">Estado</th>
   <th scope="col">Comentario</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2("ES1")}}</td>
   <td>Initial definition.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-7', 'Lexical Conventions')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-ecmascript-language-lexical-grammar', 'Lexical Grammar')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>Added: Binary and Octal Numeric literals, Unicode code point escapes, Templates</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-ecmascript-language-lexical-grammar', 'Lexical Grammar')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Compatibilidad_en_navegadores">Compatibilidad en navegadores</h2>

<div class="hidden">The compatibility table on this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<p>{{Compat("javascript.grammar")}}</p>

<h3 id="Progreso_de_la_implementación">Progreso de la implementación</h3>

<p>The following table provides a daily implementation status for this feature, because this feature has not yet reached cross-browser stability. The data is generated by running the relevant feature tests in <a href="https://github.com/tc39/test262">Test262</a>, the standard test suite of JavaScript, in the nightly build, or latest release of each browser's JavaScript engine.</p>

<div>{{EmbedTest262ReportResultsTable("hashbang")}}</div>

<h2 id="Ver_también">Ver también</h2>

<ul>
 <li><a href="http://whereswalden.com/2013/08/12/micro-feature-from-es6-now-in-firefox-aurora-and-nightly-binary-and-octal-numbers/">Jeff Walden: Binary and octal numbers</a></li>
 <li><a href="http://mathiasbynens.be/notes/javascript-escapes">Mathias Bynens: JavaScript character escape sequences</a></li>
 <li>{{jsxref("Boolean")}}</li>
 <li>{{jsxref("Number")}}</li>
 <li>{{jsxref("RegExp")}}</li>
 <li>{{jsxref("String")}}</li>
</ul>