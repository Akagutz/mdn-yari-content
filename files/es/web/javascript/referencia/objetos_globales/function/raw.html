<div>{{JSRef("Objetos_globales", "Function")}}</div>

<h2 id="Summary" name="Summary">Sumario</h2>

<p>Cada función en JavaScript es actualmente un objeto <code>Function</code>.</p>

<h2 id="Created_by" name="Created_by">Creado por</h2>

<p>Como todos los demás objetos, <code>Function</code> se puede crear utilizando la instrucción <code>new</code>:</p>

<pre class="syntaxbox">new Function ([<em>arg1</em>[, <em>arg2</em>[, ... <em>argN</em>]],] <em>cuerpo-de-la-función</em>)
</pre>

<dl>
 <dt><code>arg1, arg2, ... arg<em>N</em></code></dt>
 <dd>Nombres para ser utilizados por la función como nombres formales de argumento. Cada uno de ellos debe ser una cadena que corresponde a un identificador válido JavaScript o una lista de esas cadenas separadas por una coma; por ejemplo "<code>x</code>", "<code>elValor</code>", o "<code>a,b</code>".</dd>
 <dt><code><em>cuerpo-de-la-función</em></code></dt>
 <dd>Una cadena que contiene las instrucciones del código JavaScript y que conforma el cuerpo de la función.</dd>
</dl>

<p>Invocar el constructor de la <code>Function</code> como una función (sin usar el operador <code>new</code> ) tiene el mismo efecto que invocarla como un constructor.</p>

<h2 id="Description" name="Description">Descripción</h2>

<h3 id="General" name="General">General</h3>

<p>Los objectos <code>Function</code> creados con el constructor de la <code>Function</code> son evaluados cada vez que son usados. Esto no es tan eficiente como declarar una función y llamarla después dentro de tu código, porque las funciones declaradas se pasan una sola vez.</p>

<h3 id="Specifying_arguments_with_the_Function_constructor" name="Specifying_arguments_with_the_Function_constructor">Especificar argumentos con el constructor de <code>Function</code></h3>

<p>El código siguiente crea un objeto <code>Function</code> que toma dos argumentos.</p>

<pre class="brush:js">var multiplicar = new Function("x", "y", "return x * y");
</pre>

<p>Los argumentos "<code>x</code>" e "<code>y</code>" son nombres formales de argumentos que se usan en el cuerpo de la función, "<code>return x * y</code>".</p>

<p>El código precedente asigna una función a la variable <code>multiplicar</code>. Para llamar al objeto <code>Function</code>, puedes especificar el nombre de la variable como si fuera una función, como se muestra en el siguiente ejemplo.</p>

<pre class="brush:js">var laRespuesta = multiplicar(7, 6);
var miEdad = 50;

if (miEdad &gt;= 39) {
  miEdad = multiplicar(miEdad, .5);
}</pre>

<h2 id="Function_prototype_object"><code>Function</code> prototype object</h2>

<h3 id="Propriedades">Propriedades</h3>

<div>{{page('/es/docs/Web/JavaScript/Referencia/Objetos_globales/Function/prototype', 'Propriedades')}}</div>

<h3 id="Methods" name="Methods">Métodos</h3>

<div>{{page('/es/docs/Web/JavaScript/Referencia/Objetos_globales/Function/prototype', 'M.C3.A9todos')}}</div>

<h2 id="Examples" name="Examples">Ejemplos</h2>

<h3 id="Example:_Creating_.22focus.22_and_.22blur.22_event_handlers_for_a_frame" name="Example:_Creating_.22focus.22_and_.22blur.22_event_handlers_for_a_frame">Ejemplo: Crear manejador de evento "focus" y "blur" para un marco (frame)</h3>

<p>El siguiente ejemplo crea el manejador de eventos <code>onFocus</code> y <code>onBlur</code> para un marco. Este código existe en el mismo fichero que contiene la etiqueta <code>frameset</code>. Observe que este script es la única forma de crear el manejador para los eventos "focus" y "blur" para un marco, porque no se pueden especificar manejadores de eventos dentro de la etiqueta <code>frame</code>.</p>

<pre class="brush:js">var marco = frames[0];

marco.onfocus = new Function("document.body.style.backgroundColor = 'white';");
marco.onblur = new Function("document.body.style.backgroundColor = '#bbbbbb';");
</pre>

<h2 id="See_also" name="See_also">Ver También</h2>

<ul>
 <li><a href="/es/docs/JavaScript/Reference/Functions" title="JavaScript/Reference/Functions">Functions</a></li>
</ul>
