<h2 id="Introducción">Introducción</h2>

<p>¿Por qué una re-introducción? Porque <a href="https://developer.mozilla.org/en/JavaScript">JavaScript</a> tiene una fama razonable de ser <a href="http://javascript.crockford.com/javascript.html">el lenguaje de programación más incomprendido del mundo</a>. Aunque a menudo se le ha ridiculizado como un juguete, bajo su aparente sencillez residen características muy potentes. En la actualidad JavaScript se utiliza en un gran número de aplicaciones avanzadas, demostrando que un profundo conocimiento de esta tecnología es una habilidad importante para cualquier desarrollador web o móvil.</p>

<p>Suele ser útil empezar con una visión general de la historia del lenguaje. JavaScript fue creado en 1995 por Brendan Eich, ingeniero de Netscape, y fue publicado con Netscape 2 a principios de 1996. Inicialmente iba a llamarse LiveScript, pero fue renombrado en una errónea decisión de marketing para tratar de aprovechar la popularidad del lenguaje Java de Sun Microsystems, a pesar de que ambos lenguajes tienen muy poco en común. Esto ha sido un motivo de confusión que ha alcanzado hasta nuestros días.</p>

<p>Unos meses después, Microsoft lanzó Jscript, una versión compatible con la mayoría del lenguaje Javascript,  en IE 3. Netscape presentó el lenguaje a <a href="http://www.ecma-international.org/">Ecma Internacional</a>, un organismo europeo de normalización, lo que dio lugar a la primera edición de la norma <a href="https://developer.mozilla.org/en/JavaScript/Language_Resources">ECMAScript</a> en 1997. La norma ha recibido una actualización importante, la ECMAScript 3 en 1999, y se ha mantenido más o menos estable desde entonces. La cuarta edición fue abandonada, debido a diferencias políticas relativas a la complejidad del lenguaje. Muchas partes de la cuarta edición formaron la base de la nueva edición de ECMAScript 5, publicado en diciembre de 2009.</p>

<p>Esta estabilidad es una gran noticia para los desarrolladores, ya que les ha dado a las diversas implementaciones mucho tiempo para ponerse al día. Me voy a centrar casi exclusivamente en la tercera edición del lenguaje. Por familiaridad, voy a seguir con el término JavaScript de ahora en adelante.</p>

<p>A diferencia de la mayoría de los lenguajes de programación, el lenguaje JavaScript no tiene un concepto de entrada o salida. Está diseñado para funcionar como un lenguaje de script dentro de un entorno y depende de los mecanismos de este entorno para la comunicación con el mundo exterior. El entorno más común es el navegador, pero los intérpretes de JavaScript también se puede encontrar en Adobe Acrobat, Photoshop, las imágenes SVG, el motor de Widget de Yahoo!, así como entornos de servidor como <a href="http://nodejs.org/">node.js</a>. Sin embargo, la lista de las areas donde se utiliza JavaScript es mucho más extensa. También incluye las bases de datos NoSQL, el de código abierto <a href="http://couchdb.apache.org/">Apache CouchDB</a>, ordenadores integrados, o entornos de escritorio completos, como <a href="http://www.gnome.org/">GNOME</a> (una de las interfaces gráficas de usuario más populares para los sistemas operativos GNU / Linux).</p>

<h2 id="Información_general">Información general</h2>

<p>JavaScript es un lenguaje <span style="line-height: 1.5;">dinámico </span><span style="line-height: 1.5;">orientado a objetos. Tiene tipos y operadores, objetos básicos y métodos. Su sintaxis viene de los lenguajes Java y C, por lo que muchas de las estructuras de esos lenguajes se aplican también a JavaScript. Una de las principales diferencias es que JavaScript no tiene clases. En cambio, la funcionalidad de clase se consigue mediante prototipos de objetos. La otra diferencia principal es que las funciones son objetos, dando a las funciones la capacidad para contener código ejecutable y ser pasado como cualquier otro objeto.</span></p>

<p><span style="line-height: 1.5;">Vamos a empezar mirando el componente básico de cualquier lenguaje: los tipos. JavaScript manipula valores, y esos valores pertenecen a un tipo. Los tipos de JavaScript son:</span></p>

<ul>
 <li><a href="/En/Core_JavaScript_1.5_Reference/Global_Objects/Number" title="en/Core_JavaScript_1.5_Reference/Global_Objects/Number">N</a><a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/Number">úmeros</a></li>
 <li><a href="/En/Core_JavaScript_1.5_Reference/Global_Objects/String" title="en/Core_JavaScript_1.5_Reference/Global_Objects/String">C</a><a href="https://developer.mozilla.org/En/Core_JavaScript_1.5_Reference/Global_Objects/String">adenas de texto (Strings)</a></li>
 <li><a href="/en/JavaScript/Reference/Global_Objects/Boolean" title="en/Core_JavaScript_1.5_Reference/Global_Objects/Boolean">Booleanos</a></li>
 <li><a href="/en/JavaScript/Reference/Global_Objects/Function" title="en/Core_JavaScript_1.5_Reference/Global_Objects/Function">F</a><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function">unciones</a></li>
 <li><a href="/en/JavaScript/Reference/Global_Objects/Object" title="en/Core_JavaScript_1.5_Reference/Global_Objects/Object">Obje</a><a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object">tos</a></li>
</ul>

<p>...oh, y Undefined y Null, que son un poco extraños. Y <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array">Arrays</a>, que son un tipo especial de objeto. Y fechas y expresiones regulares, que son objetos que se obtienen de forma gratuita. Y para ser técnicamente preciso, las funciones son sólo un tipo especial de objeto. Así que el diagrama se parece más a esto:</p>

<ul>
 <li>Números</li>
 <li>Cadenas</li>
 <li>Booleanos</li>
 <li>Objetos
  <ul>
   <li>Funciones</li>
   <li>Array</li>
   <li>Date</li>
   <li>RegExp</li>
  </ul>
 </li>
 <li>Null</li>
 <li>Undefined</li>
</ul>

<p>Y hay algunos tipos de <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error">Error</a> pre-construidos también. Sin embargo las cosas son mucho más fáciles si nos quedamos con el primer diagrama.</p>

<h2 id="Números">Números</h2>

<p>Los números en JavaScript son "de doble precisión de 64 bits en formato IEEE 754", de acuerdo con la especificación. Esto tiene algunas consecuencias interesantes. No hay tal cosa como un entero en JavaScript, por lo que hay que ser un poco cuidadoso con la aritmética si esta acostumbrado a las matemáticas en C o Java. Tenga cuidado con cosas como:</p>

<pre class="eval">0.1 + 0.2 == 0.30000000000000004
</pre>

<p>En la práctica, los valores enteros se tratan como enteros de 32 bits (y se almacenan de esa manera en algunas implementaciones de navegadores Web), que puede ser importante para las operaciones de bit a bit. </p>

<p>Los operadores <a href="https://developer.mozilla.org/en/JavaScript/Reference/Operators/Arithmetic_Operators">numéricos estándar</a> están implementados, incluyendo suma, resta, módulo (o resto) aritmética y así sucesivamente. También hay un objeto incorporado que me olvidé de mencionar antes llamado <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Math">Math</a> para manejar las funciones y constantes matemáticas más avanzadas:</p>

<pre class="brush: js">Math.sin(3.5);
var d = Math.PI * r * r;
</pre>

<p>Se puede convertir una cadena de texto a un entero utilizando la función <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt">parseInt()</a>. Esta función  toma la base para la conversión como un segundo argumento opcional, el que siempre se deberia proporcionar:</p>

<pre class="brush: js">&gt; parseInt("123", 10)
123
&gt; parseInt("010", 10)
10
</pre>

<p>Si no se proporciona el valor base, se podría obtener resultados sorpresivos en navegadores antiguos (anteriores a 2013):</p>

<pre class="brush: js">&gt; parseInt("010")
8
</pre>

<p>Esto sucede porque la función parseInt decidió tratar la cadena de texto como un octal por la presencia del 0 inicial.</p>

<p>Si quieres convertir un número binario a entero, sólo cambia la base:</p>

<pre class="brush: js">&gt; parseInt("11", 2)
3
</pre>

<p>Igualmente puedes cambiar números flotantes usando la función <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseFloat">parseFloat()</a> que utiliza la base 10.</p>

<p>También puedes usar el operador unitario + para convertir valores a números:</p>

<pre>&gt; + "42"
42 
</pre>

<p>Si la cadena es no numérica, se devuelve un valor especial llamado <code><a href="/en/JavaScript/Reference/Global_Objects/NaN" title="en/Core_JavaScript_1.5_Reference/Global_Properties/NaN">NaN</a></code> (abreviatura para "Not a Number"):</p>

<pre class="brush: js">&gt; parseInt("hello", 10)
NaN
</pre>

<p><code>NaN</code> es tóxico: si lo ingresas como dato de cualquier operación matemática el resultado también será <code>NaN</code>:</p>

<pre class="brush: js">&gt; NaN + 5
NaN
</pre>

<p>Podes comprobar el valor de <code>NaN</code> usando la función incorporada <code><a href="/en/JavaScript/Reference/Global_Objects/isNaN" title="en/Core_JavaScript_1.5_Reference/Global_Functions/isNaN">isNaN()</a></code>:</p>

<pre class="brush: js">&gt; isNaN(NaN)
true
</pre>

<p>JavaScript también tiene los valores especiales <code><a href="/en/JavaScript/Reference/Global_Objects/Infinity" title="en/Core_JavaScript_1.5_Reference/Global_Properties/Infinity">Infinity</a></code> y <code>-Infinity</code>:</p>

<pre class="brush: js">&gt; 1 / 0
Infinity
&gt; -1 / 0
-Infinity
</pre>

<p>Podes comprobar los valores de <code>Infinity</code>, <code>-Infinity</code> y <code>NaN</code> usando la función incorporada <code><a href="/en/JavaScript/Reference/Global_Objects/isFinite" title="en/Core_JavaScript_1.5_Reference/Global_Functions/isFinite">isFinite()</a></code>:</p>

<pre class="brush: js">&gt; isFinite(1/0)
false
&gt; isFinite(-Infinity)
false
&gt; isFinite(NaN)
false
</pre>

<div class="note"><strong>Nota:</strong> Las funciones <a href="/en/JavaScript/Reference/Global_Objects/parseInt" title="en/JavaScript/Reference/Global Objects/parseInt"><code>parseInt()</code></a> y <code><a href="/en/JavaScript/Reference/Global_Objects/parseFloat" title="en/JavaScript/Reference/Global Objects/parseFloat">parseFloat()</a></code> analizan una cadena hasta que llegan a un caracter que no es válido para el formato de número especificado, luego devuelven el número analizado hasta ese punto. Sin embargo, el operador "+" simplemente convierte la cadena a <code>NaN</code> si hay algún caracter invalido en él. Trata de analizar tú mismo la cadena "10.2abc" con cada método en la consola y entenderás mejor las diferencias.</div>

<h2 id="Cadenas_de_caracteres">Cadenas de caracteres</h2>

<p>Las cadenas de caracteres en JavaScript son secuencias de caracteres. Más precisamente, son secuencias de <a href="/en/JavaScript/Guide/Values,_variables,_and_literals#Unicode" title="en/Core_JavaScript_1.5_Guide/Unicode">Caracteres Unicode</a>, con cada caracter representado por un número de 16 bits. Éstas deberían ser buenas noticias para aquellos que tuvieron que lidiar con la internacionalización.</p>

<p>Si quieres representar un simple carácter, solo usa una cadena con un largo de 1.</p>

<p>Para saber la longitud de una cadena, accede a su propiedad <code><a href="/en/JavaScript/Reference/Global_Objects/String/length" title="en/Core_JavaScript_1.5_Reference/Global_Objects/String/length">length</a></code>:</p>

<pre class="brush: js">&gt; "hola".length
4</pre>

<p>¡Ahí está nuestra primer pincelada con objetos JavaScript! ¿Mencioné que también podías usar cadenas como si fueran objetos? Ellas también tienen <a href="/En/Core_JavaScript_1.5_Reference/Global_Objects/String#Methods" title="en/Core_JavaScript_1.5_Reference/Global_Objects/String#Methods">métodos</a>:</p>

<pre class="brush: js">&gt; "hola".charAt(0)
h
&gt; "hola, mundo".replace("hola", "adiós")
adiós, mundo
&gt; "hola".toUpperCase()
HOLA
</pre>

<h2 id="Otros_tipos">Otros tipos</h2>

<p>JavaScript distingue entre <code>null</code>, que es un valor que indica un "no valor" deliberado (y es sólo accesible a través de la palabra clave <code>null</code>), y <code>undefined</code>, que es un valor de tipo 'undefined' (indefinido) que indica un valor no inicializado — esto es, un valor que todavía no ha sido asignado. Hablaremos de variables luego, pero en JavaScript es posible declarar una variable sin asignarle un valor. Si haces esto, El tipo de variable será <code>undefined</code>. <code>undefined</code> es en realidad una constante.</p>

<p>JavaScript tiene un tipo booleano, con los valores posibles <code>true</code> (verdadero) y <code>false</code> (falso - ambos son palabras claves). Cualquier valor puede convertirse a booleano de acuerdo a las siguientes reglas:</p>

<ol>
 <li><code>false</code>, <code>0</code>, la cadena vacía (<code>""</code>), <code>NaN</code>, <code>null</code>, y <code>undefined</code> todos son <code>false</code></li>
 <li>Todos los demás son <code>true</code></li>
</ol>

<p>Puedes realizar esta conversión explícitamente usando la función <code>Boolean()</code>:</p>

<pre class="brush: js">&gt; Boolean("")
false
&gt; Boolean(234)
true
</pre>

<p>Sin embargo, es raramente necesaria, ya que JavaScript realizará esta conversión silenciosamente cuando espere que el valor sea booleano, tal como sucede en una instrucción <code>if</code> (ver más abajo). Por esta razón, a veces simplemente hablamos de "valores verdaderos" y "valores falsos", queriendo decir valores que se vuelven <code>true</code> y <code>false</code>, respectivamente, al convertirse en booleanos. Alternativamente, tales valores pueden llamarse "los verdaderos" y "los falsos", respectivamente.</p>

<p>JavaScript soporta operaciones Booleanas tales como <code>&amp;&amp;</code> (<em>y </em><span style="line-height: 1.5;">lógica</span><span style="line-height: 1.5;">), </span><code style="font-style: normal; line-height: 1.5;">||</code><span style="line-height: 1.5;"> (</span><em>o </em>lógica<span style="line-height: 1.5;">), y </span><code style="font-style: normal; line-height: 1.5;">!</code><span style="line-height: 1.5;"> (</span><em>no </em><span style="line-height: 1.5;">lógico</span><span style="line-height: 1.5;">). Ver más abajo.</span></p>

<h2 id="Variables">Variables</h2>

<p>Las variables en JavaScript se declaran usando la palabra reservada <code><a href="/en/JavaScript/Reference/Statements/var" title="en/Core_JavaScript_1.5_Reference/Statements/var">var</a></code>:</p>

<pre class="brush: js">var a;
var name = "simon";
</pre>

<p>Si declaras una variable sin asirgnarle ningún valor su tipo será <code>undefined</code>. </p>

<p>Una diferencia importante de otros lenguajes como Java es que en JavaScript, los bloques no forman un ámbito. Sólo las funciones forman un ámbito. Así que si una variable es definida usando <code>var</code> en una declaración compuesta (por ejemplo dentro de una estructura de control <code>if</code>), será visible para la función entera.</p>

<h2 id="Operadores">Operadores</h2>

<p>Los operadores numericos de JavaScript son <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> y <code>%</code> (esta última es la operación módulo o resto). Los valores se asignan usando <code>=</code>, y también hay declaraciones compuestas de asignación como <code>+=</code> y <code>-= que equivalen a</code> <code>x = x <em>operador</em> y</code>.</p>

<pre class="brush: js">x += 5
x = x + 5
</pre>

<p>Puedes usar <code>++</code> y <code>--</code> para incremento y decremento respectivamente. Éstas pueden usarse como operadores prefijo o sufijo.</p>

<p>El<a href="/en/JavaScript/Reference/Operators/String_Operators" title="en/Core_JavaScript_1.5_Reference/Operators/String_Operators"> operator</a> + tambien concatena (agrupa) cadenas:</p>

<pre class="brush: js">&gt; "hola" + " mundo"
hola mundo
</pre>

<p>Si agregas una cadena a un número o a otro valor todo se convierte a cadena:</p>

<pre class="brush: js">&gt; "3" + 4 + 5
"345"
&gt; 3 + 4 + "5"
"75"
</pre>

<p>Agrega una cadena vacía a algo es una forma útil de convertirlo.</p>

<p><a href="/en/JavaScript/Reference/Operators/Comparison_Operators" title="en/Core_JavaScript_1.5_Reference/Operators/Comparison_Operators">Comparaciones</a> en JavaScript puede hacerse usando <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> y <code>&gt;=</code>. Esto funciona con cadenas y números. Con el signo igual es un poco menos sencillo. El operador doble igual realiza coerción de tipos. Si le ingresas diferentes tipos obtienes interesantes resultados:</p>

<pre class="brush: js">&gt; "perro" == "perro"
true
&gt; 1 == true
true
</pre>

<p>Para evitar la coerción de tipos, usa el operador "triple igual":</p>

<pre class="brush: js">&gt; 1 === true
false
&gt; true === true
true
</pre>

<p>También hay operadores <code>!=</code> y !<code>==</code>.</p>

<p>JavaScript también tiene <a href="/en/JavaScript/Reference/Operators/Bitwise_Operators" title="en/Core_JavaScript_1.5_Reference/Operators/Bitwise_Operators">operaciones a nivel de bits</a>, por si quieres usarlas.</p>

<h2 id="Estructuras_de_control">Estructuras de control</h2>

<p>JavaScript tiene un juego de estructuras de control similar a otros lenguajes de la familia del lenguaje C. Las declaraciones condicionales son gestionadas por <code>if</code> y <code>else</code>. Puedes encadenarlas si te gusta:</p>

<pre class="brush: js">var nombre = "gatito";
if (nombre == "mascotas") {
  nombre += "!";
} else if (nombre == "gatito") {
  nombre += "!!";
} else {
  nombre = "!" + nombre;
}
nombre == "gatito!!"
</pre>

<p>JavaScript tiene los bucles <code>while</code> y <code>do-while</code>. La primera es buena para bucles básicos. La segunda, para bucles en donde quieres asegurarte que el cuerpo del bucle se ejecute al menos una vez:</p>

<pre class="brush: js">while (true) {
  // ¡Un bucle infinito!
}

var input;
do {
  input = get_input();
} while (inputIsNotValid(input))
</pre>

<p>El bucle <span style="font-family: courier new,andale mono,monospace; line-height: 1.5;">for </span><span style="line-height: 1.5;">de JavaScript es el mismo que en </span><span style="line-height: 1.5;">C y Java: Te permite ingresar la información de control para tu ciclo en una sola linea.</span></p>

<pre class="brush: js">for (var i = 0; i &lt; 5; i++) {
  // Se ejecutará 5 veces
}
</pre>

<p>Los operadores <code>&amp;&amp;</code> y <code>||</code> usan lógica de cortocircuito, que significa que el hecho de que ejecuten el segundo operador depende del primero. Es útil para chequear objetos nulos antes de acceder a sus atributos:</p>

<pre class="brush: js">var nombre = o &amp;&amp; o.getName();
</pre>

<p>O para asignar valores por defecto:</p>

<pre class="brush: js">var nombre = otroNombre || "default";
</pre>

<p>JavaScript tiene un operador ternario para expresiones condicionales:</p>

<pre class="brush: js">var permitido = (edad &gt; 18) ? "sí" : "no";
</pre>

<p>La instrucción switch se puede usar para múltiples consecuencias derivadas de un número o cadena:</p>

<pre class="brush: js"><span style="color: #0000ff;">switch</span>(accion) {
    <span style="color: #0000ff;">case</span> 'dibujar':
        <span style="color: #ff0000;">dibujalo</span>();
        <span style="color: #0000ff;">break</span>;
    <span style="color: #0000ff;">case</span> 'comer':
        <span style="color: #ff0000;">comelo</span>();
        <span style="color: #0000ff;">break</span>;
    <span style="color: #0000ff;">default</span>:
        <span style="color: #ff0000;">nohacernada</span>();
}
</pre>

<p>Si no agregas una instrucción <code>break</code>, la ejecución "caerá" al siguiente nivel. Esto raramente sería lo que quieres — De hecho conviene etiquetar con un comentario específico una "caída" si realmente tuviste esa intención para ayudar a la mejor lectura del código:</p>

<pre class="brush: js">switch(a) {
    case 1: // fallthrough
    case 2:
        eatit();
        break;
    default:
        donothing();
}
</pre>

<p>La cláusula por defecto es opcional. Puedes tener expresiones tanto en la parte del switch y en cada uno de los casos, si lo prefieres. Las comparaciones toman lugar entre las dos usando el operador <code>===</code> :</p>

<pre class="brush: js">switch(1 + 3) {
    case 2 + 2:
        yay();
        break;
    default:
        neverhappens();
}
</pre>

<h2 id="Objetos">Objetos</h2>

<p>Los objetos en JavaScript pueden entenderse como simples colecciones de pares nombre-valor. Como tales, son similares a:</p>

<ul>
 <li>Diccionarios en Python</li>
 <li>Hashes en Perl y Ruby</li>
 <li>Tablas de Hash en C y C++</li>
 <li>Mapas de Hash en Java</li>
 <li>Matrices asociativas en PHP</li>
</ul>

<p>El hecho de que esta estructura de datos sea tan ampliamente usada es un testimonio de su versatilidad. Como todo (con excepción de los tipos primitivos) en JavaScript es un objeto, cualquier programa JavaScript involucra naturalmente un gran manejo de búsquedas en tablas de hash. ¡Es muy bueno que sean tan rápidas!</p>

<p>La parte "name" es una cadena JavaScript, mientras que el valor puede ser cualquier valor JavaScript, incluyendo más objetos. Esto te permite construir estructura de datos de complejidad arbitraria.</p>

<p>Hay dos formas básicas de crear un objeto vacío:</p>

<pre class="brush: js">var obj = new Object();
</pre>

<p>y:</p>

<pre class="brush: js">var obj = {};
</pre>

<p>Estas son semánticamente equivalentes. La segunda se llama sintaxis literal del objeto y es más apropiada. Esta sintaxis también es el núcleo del formato JSON y debería dársele prioridad en todo momento.</p>

<p>La sintaxis literal del objeto se puede usar para inicializar un objeto en su totalidad:</p>

<pre class="brush: js">var obj = {
    nombre: "Zanahoria",
    "for": "Max",
    detalles: {
        color: "naranja",
        medida: 12
    }
}
</pre>

<p>El acceso a atributos se puede juntar en una misma cadena:</p>

<pre class="brush: js">&gt; obj.detalles.color
naranja
&gt; obj["detalles"]["medida"]
12</pre>

<p>El siguiente ejemplo crea un objeto prototipo, Persona, y una instancia de ese prototipo, Tu.</p>

<pre class="brush: js">function Persona(nombre, edad) {
  this.nombre = nombre;
  this.edad = edad;
}

// Definir un objeto
var Tu = new Persona("Tu", 24); 
// Estamos creando una nueva persona llamada "Tu" 
// (que fue el primer parametro, y su edad, el segundo)

</pre>

<p>Una vez creadas las propiedades del objeto, puede accederse a ellas de dos formas:</p>

<pre class="brush: js">obj.nombre = "Simon";
var nombre = obj.nombre;
</pre>

<p>y...</p>

<pre class="brush: js">obj["nombre"] = "Simon";
var nombre = obj["nombre"];
</pre>

<p>Estas son semánticamente equivalentes. El segundo método tiene la ventaja de que el nombre de la propiedad se ingresa como cadena, lo que significa que puede ser calculado en tiempo de ejecución aunque usar este método impide que se apliquen algunas optimizaciones del motor JavaScript. También se puede usar para asignar y obtener propiedades con nombres que sean <a href="/en/JavaScript/Reference/Reserved_Words" title="en/Core_JavaScript_1.5_Reference/Reserved_Words">palabras reservadas</a>:</p>

<pre class="brush: js">obj.for = "Simon"; // Error de sintaxis, porque 'for' es una palabra reservada
obj["for"] = "Simon"; // Anda bien
</pre>

<p> </p>

<h2 id="Matrices"><span style="font-size: 2.14285714285714rem;">Matrices</span></h2>

<p>Las matrices en JavaScript son, en realidad, un tipo especial de objeto. Funcionan mucho como objetos regulares (se puede acceder a las propiedades numéricas sólo usando la sintaxis []) pero tienen una propiedad mágica llamada '<code>length</code>'. Ésta siempre es un número más que el índice más alto en una matriz.</p>

<p>La vieja forma de crear matrices es la siguiente:</p>

<pre class="brush: js">&gt; var a = new Array();
&gt; a[0] = "perro";
&gt; a[1] = "gato";
&gt; a[2] = "gallina";
&gt; a.length
3
</pre>

<p>Una forma más conveniente es usar una matriz literal:</p>

<pre class="brush: js">&gt; var a = ["perro", "gato", "gallina"];
&gt; a.length
3
</pre>

<div class="warning">
<p>Dejar comas al final de una matriz u objeto literal es inconsistente en los navegadores, aunque el comportamiento correcto es ignorar la última coma restante y asignarle el valor "<code>undefined</code>." a las otras. Por ahora, no se recomienda hacerlo.</p>
</div>

<p>Observa que <code>array.length</code> no es, necesariamente el número de items en la matriz. Considera lo siguiente:</p>

<pre class="brush: js">&gt; var a = ["perro", "gato", "gallina"];
&gt; a[100] = "zorro";
&gt; a.length
101
</pre>

<p>Recuerda que el largo de la matríz es un número más del índice más alto.</p>

<p>Si consultas el índice inexistente de una matriz , obtendrás <code>undefined</code>:</p>

<pre class="brush: js">&gt; typeof a[90]
undefined
</pre>

<p>Si tienes en cuenta lo anterior, puedes iterar una matriz usando lo siguiente:</p>

<pre class="brush: js">for (var i = 0; i &lt; a.length; i++) {
    // Hacer algo con a[i]
}
</pre>

<p>Esto es ligeramente ineficiente ya que buscas la propiedad length en cada oporunidad del ciclo. Una mejora es esta:</p>

<pre class="brush: js">for (var i = 0, len = a.length; i &lt; len; i++) {
    // hacer algo con a[i]
}
</pre>

<p>Y aun mejor:</p>

<pre class="brush: js">for (var i = 0, item; item = a[i++];) {
    // <span style="font-size: 1rem;">hacer algo con el</span><span style="font-size: 1rem;"> item</span>
}
</pre>

<p>Aquí estamos creando dos variables. A la asignación en la mitad del ciclo <code>for</code> se le testea su veracidad. Si es verdadera el ciclo continua. Como <code>i</code> se incrementa cada vez, los items de la matriz seran asignados a item en orden secuencial. El ciclo se detiene si se encuentra un item falso (como <code>undefined</code>).</p>

<p>Observa que este truco sólo se puede usarpara matrices que se sabe que no tienen valores falsos (las matrices de objetos o nodos <a href="/en/DOM" title="en/DOM">DOM</a>, por ejemplo). Si estas iterando datos numericos que podrían incluir un 0 o datos de una cadena que podría incluirla cadena vacía deberías usar la forma  <code>i, len</code> en su lugar.</p>

<p>Otra forma de iterar es usar el ciclo <code><a href="/en/JavaScript/Reference/Statements/for...in" title="en/Core_JavaScript_1.5_Reference/Statements/for...in">for...in</a></code>. Observa que si alguien agregara nuevas propiedades a <code>Array.prototype</code>, también serán iteradas por este ciclo:</p>

<pre class="brush: js">for (var i in a) {
  // Hacer algo con a[i]
}
</pre>

<p>Si quieres agregar un item a una matriz simplemente hazlo así:</p>

<pre class="brush: js">a.push(item);</pre>

<p>La matriz viene con varios métodos:</p>

<table>
 <thead>
  <tr>
   <th scope="col">Nombre del método</th>
   <th scope="col">Descripción</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>a.toString()</code></td>
   <td>Devuelve una cadena para cada elemento separado por comas.</td>
  </tr>
  <tr>
   <td><code>a.toLocaleString()</code></td>
   <td>Devuelve una cadena local para cada elemento separado por comas.</td>
  </tr>
  <tr>
   <td><code>a.concat(item[, itemN])</code></td>
   <td>Devuelve una matriz con los nuevos items agregados a ella.</td>
  </tr>
  <tr>
   <td><code>a.join(sep)</code></td>
   <td>Convierte la matriz a valores de delimitados por el parámetro <code>sep</code></td>
  </tr>
  <tr>
   <td><code>a.pop()</code></td>
   <td>Quita el último item de la matriz y lo devuelve como resultado.</td>
  </tr>
  <tr>
   <td><code>a.push(item[, itemN])</code></td>
   <td><code>Push</code> agrega uno o más items al final de la matriz.</td>
  </tr>
  <tr>
   <td><code>a.reverse()</code></td>
   <td>Revierte el orden de los elementos de la matriz.</td>
  </tr>
  <tr>
   <td><code>a.shift()</code></td>
   <td>Quita el primer item de la matriz y lo devuelve como resultado.</td>
  </tr>
  <tr>
   <td><code>a.slice(start, end)</code></td>
   <td>Devuelve una sub-matriz.</td>
  </tr>
  <tr>
   <td><code>a.sort([cmpfn])</code></td>
   <td>Toma una función opcional de comparación.</td>
  </tr>
  <tr>
   <td><code>a.splice(start, delcount[, itemN])</code></td>
   <td>Permite modificar una matriz borrando una sección y reemplazándola con más items.</td>
  </tr>
  <tr>
   <td><code>a.unshift([item])</code></td>
   <td>Antepone items al comienzo de la matriz.</td>
  </tr>
 </tbody>
</table>

<h2 id="Funciones">Funciones</h2>

<p>Junto con los objetos, las funciones son un componente principal en la comprensión de JavaScript. La función más básica no podría ser más simple:</p>

<pre class="brush: js">function add(x, y) {
    var total = x + y;
    return total;
}
</pre>

<p>Esto demuestra que hay mucho que aprender de las funciones básicas. Una función JavaScript puede tomar 0 o más parámetros. El cuerpo de la función puede contener tantas declaraciones como quieras y puede declarar sus propias variables que serán locales en la función. La instrucción <code>return</code> puede usarse para retornar un valor en cualquier momento, finalizando la función. Si no se utiliza la instrucción return (o un retorno vacío sin valor), JavaScript devuelve <code>undefined</code>.</p>

<p>Los parametros resultan ser más una guía que cualquier otra cosa. Puedes llamar una función sin pasarle los parametros que espera, en cuyo caso quedarán como <code>undefined</code>.</p>

<pre class="brush: js">&gt; add()
NaN // No puedes ejecutar una suma con undefined
</pre>

<p>También puedes ingresar más argumentos de los que la función espera:</p>

<pre class="brush: js">&gt; add(2, 3, 4)
5 // Sumó los dos primeros; 4 fue ignorado
</pre>

<p>Eso puede ser un poco tonto pero las funciones tienen acceso a una variable adicional dentro de su cuerpo llamada <a href="/en/JavaScript/Reference/Functions_and_function_scope/arguments" title="En/Core_JavaScript_1.5_Reference/Functions_and_function_scope/arguments"><code>arguments</code></a>, que es un objeto en forma de matriz que contiene todos los valores pasados a la función. Reescribamos la función add para que tome tantos valores como deseemos:</p>

<pre class="brush: js">function add() {
    var suma = 0;
    for (var i = 0, j = arguments.length; i &lt; j; i++) {
        suma += arguments[i];
    }
    return suma;
}

&gt; add(2, 3, 4, 5)
14
</pre>

<p>Sin embargo, eso no es realmente más útil que escribir <code>2 + 3 + 4 + 5</code>. Creemos una función promedio:</p>

<pre class="brush: js">function promedio() {
    var suma = 0;
    for (var i = 0, j = arguments.length; i &lt; j; i++) {
        suma += arguments[i];
    }
    return suma / arguments.length;
}
&gt; promedio(2, 3, 4, 5)
3.5
</pre>

<p>Esta es muy útil, pero tiene un nuevo problema. La función <code>promedio()</code> toma una lista de argumentos separados por coma. Pero ¿qué sucede si quieres encontrar el promedio de una matríz? Podrías reescribir la función de la siguiente manera:</p>

<pre class="brush: js">function avgArray(arr) {
    var sum = 0;
    for (var i = 0, j = arr.length; i &lt; j; i++) {
        sum += arr[i];
    }
    return sum / arr.length;
}
&gt; avgArray([2, 3, 4, 5])
3.5
</pre>

<p>Pero sería interesante poder reutilizar la función que ya hemos creado. Afortunadamente, JavaScript permite llamar a una función con una matriz arbitraria de argumentos usando el método <a href="/en/JavaScript/Reference/Global_Objects/Function/apply" title="en/Core_JavaScript_1.5_Reference/Global_Objects/Function/apply"><code>apply()</code></a> de cualquier objeto de la función.</p>

<pre class="brush: js">&gt; avg.apply(null, [2, 3, 4, 5])
3.5
</pre>

<p>El segundo argumento para <code>apply()</code> es la matriz a usar como agumentos. El primero  será tratado luego. Esto enfatiza el hecho de que las funciones también son objetos.</p>

<p>JavaScript permite crear funciones anónimas.</p>

<pre class="brush: js">var avg = function() {
    var sum = 0;
    for (var i = 0, j = arguments.length; i &lt; j; i++) {
        sum += arguments[i];
    }
    return sum / arguments.length;
}
</pre>

<p>Esto es semánticamente equivalente a la forma de <code>function avg()</code>. Es extremadamente potente, ya que te permite poner una definición de función completa en cualquier lugar en el que normalmente pondrías una expresión. Permite toda clase de trucos. Aquí hay una forma de "esconder" algunas variables locales como ámbito de bloque en C:</p>

<pre class="brush: js">&gt; var a = 1;
&gt; var b = 2;
&gt; (function() {
    var b = 3;
    a += b;
})();
&gt; a
4
&gt; b
2
</pre>

<p>JavaScript permite llamar funciones de forma recursiva. esto es particularmente útil para  manejar tres estructuras, tales como entrar en el <a href="/en/DOM" title="en/DOM">DOM</a> del navegador.</p>

<pre class="brush: js">function countChars(elm) {
    if (elm.nodeType == 3) { // TEXT_NODE
        return elm.nodeValue.length;
    }
    var count = 0;
    for (var i = 0, child; child = elm.childNodes[i]; i++) {
        count += countChars(child);
    }
    return count;
}
</pre>

<p>Esto destaca un problema potencial con las funciones anónimas: ¿Cómo las llamas recusivamente si no tienes un nombre? JavaScript te permite nombrar expresiones de función para ello. Puedes usar las IIFEs (Immediately Invoked Function Expressions -Expresiones de función invocadas inmediatamente-) como sigue:</p>

<pre class="brush: js">var charsInBody = (function counter(elm) {
    if (elm.nodeType == 3) { // TEXT_NODE
        return elm.nodeValue.length;
    }
    var count = 0;
    for (var i = 0, child; child = elm.childNodes[i]; i++) {
        count += counter(child);
    }
    return count;
})(document.body);
</pre>

<p>El nombre provisto a la función de expresión anterior sólo está disponible en el ámbito propio de la función. Esto permite tanto, que se hagan más optimizaciones por el motor y código más legible. El nombre también aparece en el 'debugger' y algunos indicadores de la pila que te pueden ahorrar tiempo.</p>

<p>Observa que las funciones JavaScript son objetos en sí mismos y puedes agregarles o cambiarles sus propiedades igual que a los objetos que hemos visto en la sección Objetos.</p>

<h2 id="Objetos_personalizados">Objetos personalizados</h2>

<div class="note"><strong>Nota:</strong> Para un tratamiento más detallado de  programación orientada a objetos en JavaScript, ver <a href="/en/JavaScript/Introduction_to_Object-Oriented_JavaScript" title="https://developer.mozilla.org/en/Introduction_to_Object-Oriented_JavaScript">Introducción a JavaScript orientado a objetos</a>.</div>

<p>En la programación orientada a objetos clásica, los objetos son colecciones de datos y métodos que operan sobre los datos. JavaScript es un lenguaje basado en prototipos que contiene declaraciones sin clase, tal como se encuentran en  C++ o Java. (Esto es, a veces, confuso para los programadores que están acostubrados a los lenguajes con declaraciones de clase). En su lugar, JavaScript utiliza las funciones como si fueran clases. Consideremos un objeto persona con los campos nombre y apellido. Hay dos formas en las que se podrían mostrar: como "nombre apellido" o como "apellido, nombre". Usando las funciones y objetos que hemos tratado previamente, aquí hay una forma de hacerlo:</p>

<pre class="brush: js">function crearPersona(nombre, apellido) {
    return {
        nombre: nombre,
        apellido: apellido
    };
}
function nombreCompletoPersona(persona) {
    return persona.nombre + ' ' + persona.apellido;
}
function nombreCompletoPersonaInvertido(persona) {
    return persona.apellido + ', ' + persona.nombre;
}
&gt; s = crearPersona("Simon", "Willison");
&gt; nombreCompletoPersona(s);
Simon Willison
&gt; nombreCompletoPersonaInvertido(s);
Willison, Simon
</pre>

<p>Ésto funciona, pero se ve bastante feo. Terminas con decenas de funciones en tu espacio de nombres global. Lo que realmente se necesita es una forma de adjuntar la función a un objeto. Como las funciones son objetos, es más fácil:</p>

<pre class="brush: js">function <span style="font-size: 1rem;">crearPersona(nombre, apellido)</span><span style="font-size: 1rem;"> {</span>
    return {
        nombre: nombre,
        apellido: apellido,
        nombreCompleto: function() {
            return this.nombre + ' ' + this.apellido;
        },
        nombreCompletoInvertido: function() {
            return this.apellido + ', ' + this.nombre;
        }
    };
}
&gt; s = crearPersona("Simon", "Willison")
&gt; s.nombreCompleto()
Simon Willison
&gt; s.nombreCompletoInvertido()
Willison, Simon
</pre>

<p>Hay algo aquí que no hemos visto antes: es la palabra clave '<code><a href="/en/JavaScript/Reference/Operators/this" title="en/Core_JavaScript_1.5_Reference/Operators/Special_Operators/this_Operator">this</a></code>'. incluída dentro de una función, '<code>this</code>' se refierre al objeto actual. Lo que realmente significa es que, estará especificado por la forma en que llames a esa función. Si la llamas usando <a href="/en/JavaScript/Reference/Operators/Member_Operators" title="en/Core_JavaScript_1.5_Reference/Operators/Member_Operators">notación de puntos o notación de paréntesis</a> en un objeto, ese objeto se convierte en '<code>this</code>'. Si no se usa notación de puntos para llamarla, '<code>this</code>' se refiere al objeto global. Esta es una causa frecuente de errores. Por ejemplo:</p>

<pre class="brush: js">&gt; s = crearPersona("Simon", "Willison");
&gt; var nombreCompleto = s.nombreCompleto;
&gt; nombreCompleto();
undefined undefined
</pre>

<p>Cuando llamamos a la función <code>nombreCompleto()</code>, '<code>this</code>' está limitado al objeto global. Como no hay variables globales llamadas <code>nombre</code> o <code>apellido</code> obtenemos <code>undefined</code> para cada una.</p>

<p>Podemos aprovechar la palabra clave '<code>this</code>' para mejorar nuestra función <code>crearPersona</code>:</p>

<pre class="brush: js">function Persona(nombre, apellido) {
    this.nombre = nombre;
    this.apellido = apellido;
    this.nombreCompleto = function() {
        return this.nombre + ' ' + this.apellido;
    };
    this.nombreCompletoInvertido = function() {
        return this.apellido + ', ' + this.nombre;
    };
}
var s = new Persona("Simon", "Willison");
</pre>

<p>Hemos introducido otra palabra clave: '<code><a href="/en/JavaScript/Reference/Operators/new" title="en/Core_JavaScript_1.5_Reference/Operators/Special_Operators/new_Operator">new</a></code>'. <code>new</code> está fuertemente relacionada con '<code>this</code>'. Lo que hace es crear un nuevo objeto vacío desde cero, y luego llama a la función especificada con '<code>this</code>' para establecer ese nuevo objeto. Observa, sin embargo, que la función especificada con '<code>this</code>' no retorna ningún valor, sino simplemente modifica el objeto <code>this</code>. Es <code>new</code> la que devuelve el objeto <code>this </code>al lugar de la llamada. Las funciones que están diseñadas para ser llamadas por '<code>new</code>' se llaman funciones constructoras. La práctica común es escribir con mayúsculas estas funciones como un recordatorio para llamarlas con <code>new</code>.</p>

<p>Nuestros objetos "persona" están mejorando , pero aún tienen algunas asperezas. Cada vez que creamos un objeto "persona" estamos creando dos objetos de funciones nuevas en su interior. ¿No sería mejor si este código se compartiera?</p>

<pre class="brush: js">function nombreCompletoPersona() {
    return this.nombre + ' ' + this.apellido;
}
function nombreCompletoPersonaInvertido() {
    return this.apellido + ', ' + this.nombre;
}
function Persona(nombre, apellido) {
    this.nombre = nombre;
    this.apellido = apellido;
    this.nombreCompleto = nombreCompletoPersona;
    this.nombreCompletoInvertido = nombreCompletoPersonaInvertido;
}
</pre>

<p>Así está mejor: estamos creando las funciones de los métodos sólo una vez y asignandoles las referencias dentro del constructor. ¿Podemos hacer algo mejor que eso? La respuesta es sí:</p>

<pre class="brush: js">function Persona(nombre, apellido) {
    this.nombre = nombre;
    this.apellido = apellido;
}
Persona.prototype.nombreCompleto = function() {
    return this.nombre + ' ' + this.apellido;
};
Persona.prototype.nombreCompletoInvertido = function() {
    return this.apellido + ', ' + this.nombre;
};
</pre>

<p><code>Persona.prototype</code> es un objeto compartido por todas las instancias de  <code>Persona</code>. Forma parte de una cadena de búsqueda (que tiene un nombre especial, "cadena de prototipos"): siempre que intentes acceder a una propiedad de <code>Persona</code> que no exista internamente, JavaScript chequeará <code>Person.prototype</code> para ver si existe allí. Como resultado, cualquier cosa asignada a <code>Person.prototype</code> quedará disponible para todas las instancias de ese constructor a través del objeto <code>this</code>.</p>

<p>Esta es una herramienta increíblemente poderosa. JavaScript te permite modificar el prototipo de algo en cualquier parte de tu programa, lo que significa que puedes agregar métodos adicionales a los objetos que existan en tiempo de ejecución:</p>

<pre class="brush: js">&gt; s = new Persona("Simon", "Willison");
&gt; s.nombreEnMayusculas();
TypeError on line 1: s.nombreEnMayusculas is not a function
&gt; Persona.prototype.nombreEnMayusculas = function() {
    return this.nombre.toUpperCase()
};
&gt; s.nombreEnMayusculas()
SIMON
</pre>

<p>Es interesante que también puedes agregar cosas al prototipo de objetos propios de JavaScript. Agregamos un método a <code>String</code> que devuelve la cadena invertida:</p>

<pre class="brush: js">&gt; var s = "Simon";
&gt; s.reversed()
TypeError on line 1: s.reversed is not a function
&gt; String.prototype.reversed = function() {
    var r = "";
    for (var i = this.length - 1; i &gt;= 0; i--) {
        r += this[i];
    }
    return r;
};
&gt; s.reversed()
nomiS
</pre>

<p>¡Nuestro método funciona bien incluso en cadenas literales!</p>

<pre class="brush: js">&gt; "Ahora se puede invertir esto".reversed()
otse ritrevni edeup es arohA
</pre>

<p>Como mencioné antes, el prototipo forma parte de una cadena. La raíz de esa cadena es <code>Object.prototype</code>, cuyos métodos incluyen a  <code>toString()</code> — Este es el método que se llama cuando tratas de representar un objeto como cadena. Es útil para corregir errores en nuestros objetos <code>Persona</code>:</p>

<pre class="brush: js">&gt; var s = new Persona("Simon", "Willison");
&gt; s
[object Object]
&gt; Persona.prototype.toString = function() {
    return '&lt;Persona: ' + this.nombreCompleto() + '&gt;';
}
&gt; s
&lt;Persona: Simon Willison&gt;
</pre>

<p>¿Recuerdas que <code>avg.apply()</code> tenía un primer argumento nulo? Podemos revisar eso ahora. El primer argumento para <code>apply()</code> es el objeto que debería tratarse como '<code>this</code>'. Por ejemplo, aquí hay una implementación trivial de '<code>new</code>':</p>

<pre class="brush: js">function trivialNew(constructor, ...args) {
    var o = {}; // Crear un objeto
    constructor.apply(o, ...args);
    return o;
}
</pre>

<p>No es una réplica exacta de <code>new</code> porque no establece la cadena de prototipos (sería difícil de ilustrar). No es algo que utilizaras muy amenudo, pero es útil para aprender. En este código, <code>...args</code> (incluyendo la elipsis) se llama "<a href="/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/rest_parameters">argumentos restantes</a>" – como su nombre lo indica, contiene el resto de los argumentos. Actualmente, esta característica es experimental y no está disponible en Firefox; Se recomienda utilizar <code>arguments</code> por ahora.</p>

<p>Llamar...</p>

<pre class="brush: js">var bill = trivialNew(Person, "William", "Orange");</pre>

<p>...es, por lo tanto, casi equivalente a...</p>

<pre class="brush: js">var bill = new Person("William", "Orange");</pre>

<p><code>apply()</code> tiene una función hermana llamada <a href="/en/JavaScript/Reference/Global_Objects/Function/call" title="en/Core_JavaScript_1.5_Reference/Global_Objects/Function/call"><code>call</code></a>, que de nuevo te permite establecer '<code>this</code>' pero toma una lista de argumentos expandida al contrario que una matriz.</p>

<pre class="brush: js">function lastNameCaps() {
    return this.last.toUpperCase();
}
var s = new Person("Simon", "Willison");
lastNameCaps.call(s);
// Is the same as:
s.lastNameCaps = lastNameCaps;
s.lastNameCaps();
</pre>

<p><strong style="font-size: 2.14285714285714rem; font-weight: 700; letter-spacing: -1px; line-height: 30px;">Funciones internas</strong></p>

<p>Se permiten declaraciones de funciones javascript dentro de otras funciones. Hemos visto esto antes, con una primera función <code>crearPersona()</code>. Un detalle importante de las funciones anidadas en JavaScript es que pueden acceder a las variables del entorno de sus funciones padres:</p>

<pre class="brush: js">function betterExampleNeeded() {
    var a = 1;
    function oneMoreThanA() {
        return a + 1;
    }
    return oneMoreThanA();
}
</pre>

<p>Esto provee un gran manejo de utilidad para escribir un código más flexible. Si una función se apoya en una o dos funciones que no son útiles para ninguna otra parte de tu código, puedes anidar esas funciones de utilidad dentro de la función que será llamada desde otro lugar. Esto mantiene bajo el número de funciones que están en el entorno global, lo que siempre es bueno.</p>

<p><span>Esto es un gran contador para engañar a las variables globales. Cuando escribimos código complejo es tentador usar a veces variables globales para compartir su valor entre múltiples</span><span> funciones — lo que conduce a un código difícil de mantener. Las funciones anidadas pueden compartir</span><span> variables de sus padres, también tú puedes usar ese mecanismo </span><span>para emparejar funciones cuando esto tiene sentido sin contaminar tus espacios de nombres globales — 'globales locales' si prefieres. Esta técnica debe ser usada con precaución</span><span>, pero es una capacidad muy útil de</span> considerar.</p>

<h2 id="Cerraduras_(closures)">Cerraduras (closures)</h2>

<p>Esto nos lleva a una de las abstracciones más poderosas que Javascript tiene para ofrecer, pero además potencialmente confusa. ¿Qué hace ésta?</p>

<pre class="brush: js">function hacerSumadora(a) {
    return function(b) {
        return a + b;
    };
}
x = hacerSumadora(5);
y = hacerSumadora(20);
x(6)
?
y(7)
?
</pre>

<p>El nombre de la función <code>hacerSumadora</code> debería aclararlo: crea nuevas funciones 'sumadoras', que al ser llamadas con un argumento, lo agregan al argumento con las que fueron creadas.</p>

<p>Lo que pasa acá es muy similar a lo que pasaba con las funciones internas vistas anteriormente: una función definida dentro de otra, tiene acceso a las variables de la función externa. La única diferencia aquí ha vuelto y, por lo tanto, el sentido común parecería dictar que las variables locales ya no existen. Pero aún sí existen. de otra manera, sería imposible que anden las funciones sumadoras. ¡Y lo que es más! Hay dos copias diferentes de las variables locales de  <code>hacerSumadora</code>. Una en la que <code>a</code> es 5 y una en la que <code>a</code> es 20. Así que el resultado de esas llamadas a la función queda de la siguiente manera:</p>

<pre class="brush: js">x(6) // devuelve 11
y(7) // devuelve 27
</pre>

<p>Esto es lo que pasa en realidad. Cuando JavaScript ejecute una función, un objeto de entorno se crea para mantener las variables locales creadas dentro de esa función. Se inicializa con cualquier variable pasada a la función como parámetro. Esto es similar al objeto global en el que todas las variables locales residen, pero con un par de diferencias importantes: primeramente, se crea un nuevo objeto de entorno cada vez que una función comienza a ejecutarse y, segundo, a diferencia del objeto global (que es accesible como <code>this</code> y en los navegadores es accesible como <code>window</code>), a estos objetos de entorno no se puede acceder directamente desde tu código JavaScript. No hay mecanismo para iterar las propiedades del objeto de entorno actual, por ejemplo.</p>

<p>Así que cuando se llama a <span style="font-family: consolas,monaco,andale mono,monospace; line-height: 1.5;">hacerSumadora</span><span style="line-height: 1.5;">, a se crea un objeto de entorno con una propiedad: </span><code style="font-style: normal; line-height: 1.5;">a</code><span style="line-height: 1.5;">, que es el argumento pasado a la función </span><span style="font-family: consolas,monaco,andale mono,monospace; line-height: 1.5;">hacerSumadora</span><span style="line-height: 1.5;">. Luego</span><span style="line-height: 1.5;"> </span><span style="font-family: consolas,monaco,andale mono,monospace; line-height: 1.5;">hacerSumadora</span><span style="line-height: 1.5;"> devuelve una función creada recientemente. Normalmente el recolector de basura de JavaScript limpiaría el objeto de entorno creado por </span><span style="font-family: consolas,monaco,andale mono,monospace;">hacerSumadora</span><span style="line-height: 1.5;"> en este punto, pero la función devuelta mantiene una referencia al objeto de entorno. Como resultado, el objeto de entorno no será recolectado como basura hasta que no hayan más referencias al objeto de la función que </span><span style="font-family: consolas,monaco,andale mono,monospace; line-height: 1.5;">hacerSumadora</span><span style="line-height: 1.5;"> devolvió.</span></p>

<p>Los objetos de entorno forman una cadena llamada cadena de entorno similar a la cadena de prototipos usada por el sistema de objetos de JavaScript.</p>

<p>Una cerradura es la combinación de una función y el objeto de entorno en el que fue creada.</p>

<p>Las cerraduras permiten guardar el estado. Como tales, suelen ser usadas en lugar de los objetos. <a href="http://stackoverflow.com/questions/111102/how-do-javascript-closures-work" style="line-height: 1.5;">Aquí</a><span style="line-height: 1.5;"> se pueden encontrar varias introducciones a las cerraduras</span><span style="line-height: 1.5;">.</span></p>

<h3 id="Pérdidas_de_memoria">Pérdidas de memoria</h3>

<p>Un efecto colateral desafortunado de las cerraduras ocasionan pérdidas de memoria muy fácilmente en Internet Explorer. JavaScript es un lenguaje con recolección de basura. Los objetos memoria asignada a su creación y esa memoria es reclamada por el navegador cuando no quedan referencias a un objeto. Los objetos provistos por el entorno del host son manipulados por ese entorno.</p>

<p>Los hosts de navegador necesitan manipular un gran número de objetos que representan la página HTML que se está mostrando, objetos del <a href="/en/DOM" title="en/DOM">DOM</a>. Depende del navegador la gestión de asignación y recupero de éstos.</p>

<p>Internet Explorer usa su propio esquema de recolección de basura para esto, separado del esquema usado para JavaScript. Es la interacción entre los dos la que puede causar pérdidas de memoria.</p>

<p>Una pérdida de memoria en IE ocurre cada vez que se forma una referencia circular entre un objeto de JavaScript y uno nativo. Considera lo siguiente:</p>

<pre class="brush: js">function leakMemory() {
    var el = document.getElementById('el');
    var o = { 'el': el };
    el.o = o;
}
</pre>

<p>La referencia circular formada anteriormente origina pérdida de memoria. IE no liberará la memoria utilizada por <code>el</code> y <code>o</code> hasta que el navegador sea reiniciado completamente.</p>

<p>Es probable que el caso anterior pase desapercibido. Las pérdidas de memoria sólo se vuelven una preocupación real en aplicaciones de extensa ejecución o aplicaciones que pierden mucha memoria debido a grandes estructuras de datos o patrones de pérdida dentro de ciclos repetitivos.</p>

<p>Raramente las pérdidas de memorias sean tan obvias como en el ejemplo. A menudo, la estructura de datos perdidos puede tener muchas capas de referencias, escondiendo la referencia circular.</p>

<p>Las cerraduras hacen que sea fácil crear pérdidas de memoria sin que se tenga intención. Considera esto:</p>

<pre class="brush: js">function addHandler() {
    var el = document.getElementById('el');
    el.onclick = function() {
        el.style.backgroundColor = 'red';
    };
}
</pre>

<p>El anterior código configura a un elemento para que se vuelva rojo al hacer clic sobre él. También crea pérdida de memoria. ¿Por qué? Porque la referencia a <code>el</code> es atrapada inadvertidamente por la cerradura creada por la función interna anónima. Esta crea una referencia circular entre un objeto JavaScript (la función) y el objeto nativo (<code>el</code>).</p>

<p>Hay algunas soluciones para este problema. La más simple es no usar la variable <code>el</code>:</p>

<pre class="brush: js">function addHandler(){
    document.getElementById('el').onclick = function(){
        this.style.backgroundColor = 'red';
    };
}
</pre>

<p>Sorprendentemente, un truco para romper las referencias circulares introducidas por una cerradura es agregar otra cerradura:</p>

<pre class="brush: js">function addHandler() {
    var clickHandler = function() {
        this.style.backgroundColor = 'red';
    };
    (function() {
        var el = document.getElementById('el');
        el.onclick = clickHandler;
    })();
}
</pre>

<p>La función interna se ejecuta inmediatamente y esconde sus contenidos de la cerradura creada con <code>clickHandler</code>.</p>

<p>Otro buen truco para evitar las cerraduras es romper las referencias circulares durante el evento <code>window.onunload</code>. Muchas bibliotecas de eventos harán esto por tí. Observa que al hacer eso se desactive <a href="/En/Using_Firefox_1.5_caching" title="En/Using_Firefox_1.5_caching">bfcache en Firefox 1.5</a>, así no debes registrar un sensor (listener) <code>unload</code> en Firefox, a menos que tengas otras razones para hacerlo así.</p>

<div class="note">
<p><span style="line-height: 1.5;">Nota: Algunas características han sido agregadas al lenguaje JavaScript desde que este documento fue escrito. Aún así, es un recurso muy relevante.</span></p>
</div>

<p> </p>

<p> </p>