<div>{{JSRef}}</div>

<p>JavaScript の <strong><code>Array</code></strong> オブジェクトは、配列を構築するためのグローバルオブジェクトで、配列とは複数の要素の集合を格納管理するリスト構造です。</p>

<p><strong>配列を作成する</strong></p>

<pre class="brush: js">var fruits = ["りんご", "バナナ"];

console.log(fruits.length);
// 2
</pre>

<p><strong>配列の要素を取得する</strong></p>

<pre class="brush: js">var first = fruits[0];
// りんご

var last = fruits[fruits.length - 1];
// バナナ
</pre>

<p><strong>配列のループ処理</strong></p>

<pre class="brush: js">fruits.forEach(function(item, index, array) {
  console.log(item, index);
});
// りんご 0
// バナナ 1
</pre>

<p><strong>配列の末尾に要素を追加する</strong></p>

<pre class="brush: js">var newLength = fruits.push("みかん");
// ["りんご", "バナナ", "みかん"]
</pre>

<p><strong>配列の末尾の要素を削除する</strong></p>

<pre class="brush: js">var last = fruits.pop(); // 配列の末尾の要素 "みかん" を削除
// ["りんご", "バナナ"];
</pre>

<p><strong>配列の先頭の要素を削除する</strong></p>

<pre class="brush: js">var first = fruits.shift(); // 配列の先頭の要素"りんご" を削除
// ["バナナ"];
</pre>

<p><strong>配列の先頭に要素を追加する</strong></p>

<pre class="brush: js">var newLength = fruits.unshift("いちご") // 配列の先頭に追加
// ["いちご", "バナナ"];
</pre>

<p><strong>要素のインデックスを取得する</strong></p>

<pre class="brush: js">fruits.push("マンゴー");
// ["いちご", "バナナ", "マンゴー"]

var pos = fruits.indexOf("バナナ");
// 1
</pre>

<p><strong>インデックス位置を指定して要素を削除する</strong></p>

<pre class="brush: js">var removedItem = fruits.splice(pos, 1); // 指定位置の要素を削除できます

// ["いちご", "マンゴー"]</pre>

<p><strong>インデックス位置から複数の要素を削除する</strong></p>

<pre class="brush: js">var vegetables = ['Cabbage', 'Turnip', 'Radish', 'Carrot'];
console.log(vegetables); 
// ["Cabbage", "Turnip", "Radish", "Carrot"]

var pos = 1, n = 2;

var removedItems = vegetables.splice(pos, n); 
// 複数の要素を削除するには、n で削除する要素数を定義します
// 指定位置（pos）以降から n 個分の要素が削除されます

console.log(vegetables); 
// ["Cabbage", "Carrot"] (元の配列が変化)

console.log(removedItems); 
// ["Turnip", "Radish"]</pre>

<p><strong>配列をコピーする</strong></p>

<pre class="brush: js">var shallowCopy = fruits.slice(); // 配列のコピーを作成できます
// ["いちご", "マンゴー"]
</pre>

<h2 id="Syntax" name="Syntax">構文</h2>

<pre class="syntaxbox">[<var>element0</var>, <var>element1</var>, ..., <var>elementN</var>] new Array(<var>element0</var>, <var>element1</var>[, ...[, <var>elementN</var>]]) new Array(<var>arrayLength</var>)</pre>

<h3 id="Parameters" name="Parameters">引数</h3>

<dl>
 <dt><code>element<em>N</em></code></dt>
 <dd>JavaScript の配列は、与えられた要素で初期化されます。ただし、<code>Array</code> コンストラクタに引数が 1 個だけ与えられ、それが数値である場合を除きます (下記の arrayLength 引数を参照)。これは、<code>Array</code> コンストラクタで作成された JavaScript 配列にのみ当てはまる特殊なケースで、ブラケット構文 ("[]") で生成された配列リテラルには当てはまらないことに注意してください。</dd>
 <dt><code>arrayLength</code></dt>
 <dd><code>Array</code> コンストラクタに 0 から 2<sup>32</sup>-1 までの間の整数値 1 個が与えられた場合、その数値の要素数を持つ新しい JavaScript 配列が生成されます（<strong>注:</strong> これは<strong> </strong><code>arrayLength</code> 分の空のスロットがある配列を意味します。スロットに実際の <code>undefined</code> 値があるわけではありません）。それ以外の数値が与えられた場合、{{jsxref("RangeError")}} が throw されます。</dd>
</dl>

<h2 id="Description" name="Description">説明</h2>

<p>配列は、リストのようなオブジェクトであり、配列に対して横断的な操作や変更を行う組み込みのメソッドを持ちます。JavaScript の配列は、要素数も要素の型も固定されていません。配列のサイズは常に可変であり、データを連続しない位置に格納できるため、JavaScript の配列は密であることが保証されていません (プログラマの使い方次第です)。一般に、これらは便利な特性ではありますが、固定された配列が必要であれば、Typed Array の使用を検討するのも良いでしょう。</p>

<p>配列は（連想配列のように）要素のインデックスに文字列を使うことはできず、整数を使う必要があります。<a href="/ja/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties">ブラケット構文</a>（または<a href="/ja/docs/Web/JavaScript/Reference/Operators/Property_Accessors">ドット構文</a>）を使った非整数の設定・取得は、配列リストそのものからではなく、その配列の<a href="/ja/docs/Web/JavaScript/Data_structures#Properties">オブジェクトプロパティコレクション</a>に紐付いた変数に対して行われます。配列のオブジェクトプロパティと配列リストの要素は異なり、配列の<a href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Indexed_collections#Array_methods">走査や変換の操作</a>は名前付きプロパティに適用されません。</p>

<h3 id="Accessing_array_elements" name="Accessing_array_elements">配列要素へのアクセス</h3>

<p>JavaScript の配列のインデックスは 0 から始まるので、配列の最初の要素はインデックス <code>0</code> にあります。そして、最後の要素のインデックスは {{jsxref("Array.length", "length")}} プロパティの値から 1 を引いた値になります。不正なインデックス番号を使った場合は <code>undefined</code> を返します。</p>

<pre class="brush: js">var arr = ["最初の要素", "2 番目の要素", "最後の要素"];
console.log(arr[0]);              // ログ : "最初の要素"
console.log(arr[1]);              // ログ : "2 番目の要素"
console.log(arr[arr.length - 1]); // ログ : "最後の要素"
</pre>

<p><code>toString</code> が一つのプロパティであるように、配列における配列要素は Array オブジェクトのプロパティです。しかし、次のように配列にアクセスしようとすると、プロパティ名が正しくないため、構文エラーが投げられる事に注意してください:</p>

<pre class="brush: js">console.log(arr.0); // 構文エラー
</pre>

<p>これは、JavaScript の配列とそのプロパティに限った話ではありません。数字から始まるプロパティは、ドット演算子を用いて参照できないため、ブラケット記法を用いる必要があります。例えば <code>'3d'</code> というプロパティを持つオブジェクトがある場合は、ドット記法ではなくブラケット記法を用いて参照しなければなりません。この類似点を、以下 2 つのコード例で示します:</p>

<pre class="brush: js">var years = [1950, 1960, 1970, 1980, 1990, 2000, 2010];
console.log(years.0); // 構文エラー
console.log(years[0]); // 正しく動作
</pre>

<pre class="brush: js">renderer.3d.setTexture(model, 'character.png');     // 構文エラー
renderer['3d'].setTexture(model, 'character.png');  // 正しく動作
</pre>

<p><code>3d</code> の例で、<code>'3d'</code> は引用符で括らなければなりません。配列要素へのアクセスにも <code>years[2]</code> でなく <code>years['2']</code> を使う事ができますが、必要になることはないでしょう。<code>years[2]</code> の 2 は最終的に、JavaScript エンジンが内部的に <code>toString</code> メソッドで型変換することで文字列にされます。これは '2' と '02' が <code>years</code> オブジェクトの異なる場所を指すようにするためでです。このため、以下の例は <code>true</code> がログ出力されます:</p>

<pre class="brush: js">console.log(years['2'] != years['02']);
</pre>

<p>同様に、オブジェクトのプロパティ名が偶然にも予約語だった(!) 場合は、ブラケット記法で文字列リテラルを使うことでのみアクセスできます (ただ、少なくとも FireFox 40.0a2 では、ドット記法でアクセスできてしまいます):</p>

<pre class="brush: js">var promise = {
  'var'  : 'text',
  'array': [1, 2, 3, 4]
};

console.log(promise['var']);
</pre>

<h3 id="Relationship_between_length_and_numerical_properties" name="Relationship_between_length_and_numerical_properties"><code>length</code> と数値プロパティとの関係</h3>

<p>JavaScript 配列の {{jsxref("Array.length", "length")}} プロパティと数値プロパティは関連しています。配列の組み込みメソッド ({{jsxref("Array.join", "join()")}}、{{jsxref("Array.slice", "slice()")}}、{{jsxref("Array.indexOf", "indexOf()")}} 等) は、呼び出された時、配列の {{jsxref("Array.length", "length")}} プロパティの値を考慮します。また、{{jsxref("Array.push", "push()")}}、{{jsxref("Array.splice", "splice()")}}等の他のメソッドも、配列の {{jsxref("Array.length", "length")}} プロパティを更新します。</p>

<pre class="brush: js">var fruits = [];
fruits.push('バナナ', 'りんご', 'もも');

console.log(fruits.length); // 3
</pre>

<p>有効なインデックスを持つ JavaScript 配列の現在のサイズに収まらない位置に要素を追加すると、配列はそれを収められるサイズに拡張され、{{jsxref("Array.length", "length")}} プロパティも更新されます。</p>

<pre class="brush: js">fruits[5] = 'マンゴー';
console.log(fruits[5]);  // 'マンゴー'
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 6
</pre>

<p>{{jsxref("Array.length", "length")}} プロパティを直接設定して増やすと以下のように隙間ができます。</p>

<pre class="brush: js">fruits.length = 10;
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
</pre>

<p>{{jsxref("Array.length", "length")}} プロパティの数を減らすと、要素が削除されます。</p>

<pre class="brush: js">fruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2
</pre>

<p>これらについては {{jsxref("Array.length")}} ページで詳しく解説します。</p>

<h3 id="Creating_an_array_using_the_result_of_a_match" name="Creating_an_array_using_the_result_of_a_match">match の結果を利用して配列を作成</h3>

<p>正規表現と文字列の match の結果から配列を生成できます。この配列には、プロパティと、マッチに関する情報を提供する要素を持ちます。このような配列は、{{jsxref("RegExp.exec")}}、{{jsxref("String.match")}}、そして {{jsxref("String.replace")}} の戻り値です。これらのプロパティと要素を理解するために、以下の例を見て表を参照してください。</p>

<pre class="brush: js">// 1 文字の d、1 文字以上の b、1 文字の d にマッチします
// マッチした b およびそれに続く d を記憶します
// 大文字小文字は区別しません

var myRe = /d(b+)(d)/i;
var myArray = myRe.exec('cdbBdbsbz');
</pre>

<p>このマッチから返されるプロパティと要素は次の通りです:</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <td class="header">プロパティまたは要素</td>
   <td class="header">説明</td>
   <td class="header">例</td>
  </tr>
  <tr>
   <td><code>input</code></td>
   <td>正規表現がマッチした、元の文字列を反映する読み取り専用プロパティです。</td>
   <td>cdbBdbsbz</td>
  </tr>
  <tr>
   <td><code>index</code></td>
   <td>文字列中でマッチした場所を、0 から始まるインデックスで示す読み取り専用プロパティです。</td>
   <td>1</td>
  </tr>
  <tr>
   <td><code>[0]</code></td>
   <td>最後にマッチした文字列を指定する読み取り専用の要素です。</td>
   <td>dbBd</td>
  </tr>
  <tr>
   <td><code>[1], ...[n]</code></td>
   <td>正規表現に含まれる場合、括弧で囲まれたマッチした部分文字列を指定する読み取り専用の要素です。括弧で囲まれた部分文字列の数は無制限です。</td>
   <td>[1]: bB<br>
    [2]: d</td>
  </tr>
 </tbody>
</table>

<h2 id="Properties" name="Properties">プロパティ</h2>

<dl>
 <dt><code>Array.length</code></dt>
 <dd><code>Array</code> コンストラクタの長さ。値は 1 です。</dd>
 <dt>{{jsxref("Array.@@species", "get Array[@@species]")}}</dt>
 <dd>コンストラクタ関数。派生オブジェクトを生成する時に使われます。</dd>
 <dt>{{jsxref("Array.prototype")}}</dt>
 <dd>これを使うとすべての Array オブジェクトにプロパティを追加することができます。</dd>
</dl>

<h2 id="Methods" name="Methods">メソッド</h2>

<dl>
 <dt>{{jsxref("Array.from()")}}</dt>
 <dd>配列型 (array-like) や反復型 (iterable) オブジェクトから、新しい <code>Array</code> インスタンスを生成します。</dd>
 <dt>{{jsxref("Array.isArray()")}}</dt>
 <dd>配列であれば true を、配列でなければ false を返します。</dd>
 <dt>{{jsxref("Array.of()")}}</dt>
 <dd>可変個の引数から新しい <code>Array</code> インスタンスを生成します。引数の数や型による特別処理はありません。</dd>
</dl>

<h2 id="Array_instances" name="Array_instances"><code>Array</code> インスタンス</h2>

<p>すべての <code>Array</code> インスタンスは、{{jsxref("Array.prototype")}} から継承します。コンストラクタの prototype オブジェクトを変更すると、すべての <code>Array</code> インスタンスに影響を及ぼすことができます。</p>

<h3 id="Properties_2" name="Properties_2">プロパティ</h3>

<div>{{page('/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', 'Properties')}}</div>

<h3 id="Methods_2" name="Methods_2">メソッド</h3>

<h4 id="Mutator_methods" name="Mutator_methods">変更メソッド</h4>

<div>{{page('/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', 'Mutator_methods')}}</div>

<h4 id="Accessor_methods" name="Accessor_methods">アクセサ メソッド</h4>

<div>{{page('/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', 'Accessor_methods')}}</div>

<h4 id="Iteration_methods" name="Iteration_methods">反復メソッド</h4>

<div>{{page('/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', 'Iteration_methods')}}</div>

<h2 id="Array_generic_methods" name="Array_generic_methods"><code>Array</code> ジェネリックメソッド</h2>

<div class="warning">
<p><strong>Array ジェネリックは非標準、非推奨であり、近い将来に削除される見込みです</strong>。</p>
</div>

<p>文字列や他の配列のようなオブジェクト (関数の {{jsxref("Functions/arguments", "arguments", "", 1)}} など) に Array のメソッドを適用したいと考える場合があります。こうすると、文字列を文字の配列として扱えます (あるいは、配列ではないものを配列として扱う)。例えば、変数 <var>str</var> に含まれる文字がすべて英字であることをチェックするには、次のように書きます:</p>

<pre class="brush: js">function isLetter(character) {
  return character &gt;= 'a' &amp;&amp; character &lt;= 'z';
}

if (Array.prototype.every.call(str, isLetter)) {
  console.log("The string '" + str + "' contains only letters!");
}
</pre>

<p>この記法は、どちらかというと無駄であるため、JavaScript 1.6 で汎用的な簡易表記が導入されました:</p>

<pre class="brush: js">if (Array.every(str, isLetter)) {
  console.log("The string '" + str + "' contains only letters!");
}
</pre>

<p>{{jsxref("Global_Objects/String", "ジェネリックメソッド", "#String_generic_methods", 1)}} は {{jsxref("String")}} でも使用できます。</p>

<p>これらは現在 ECMAScript 標準に<strong>含まれていません</strong>し、Gecko以外のブラウザーではサポートされていません。標準による代替手段としては、{{jsxref("Array.from()")}} を使って正規の配列に変換することです。と言っても、<code>Array.from()</code> は古いブラウザーではサポートされていませんけど。</p>

<pre class="brush: js">if (Array.from(str).every(isLetter)) { 
  console.log("The string '" + str + "' contains only letters!"); 
}
</pre>

<h2 id="Examples" name="Examples">例</h2>

<h3 id="Creating_an_array" name="Creating_an_array">配列を生成する</h3>

<p>次の例では、空の配列「<code><var>msgArray</var></code>」を生成し、<code>msgArray[0]</code> と <code>msgArray[99]</code> に値を設定、その後配列の要素数が 100 である事を確認しています。</p>

<pre class="brush: js">var msgArray = [];
msgArray[0] = 'Hello';
msgArray[99] = 'world';

if (msgArray.length === 100) {
  console.log("配列の length は 100 です。");
}
</pre>

<h3 id="Creating_a_two-dimensional_array" name="Creating_a_two-dimensional_array">2 次元配列を生成する</h3>

<p>以下では、文字列の 2 次元配列としてチェスボードを生成しています。最初の動きは (6,4) の 'P' を (4,4) にコピーすることでなされます。古い位置 (6,4) は空白にされます。</p>

<pre class="brush: js">var board = [ 
  ['R','N','B','Q','K','B','N','R'],
  ['P','P','P','P','P','P','P','P'],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  ['p','p','p','p','p','p','p','p'],
  ['r','n','b','q','k','b','n','r'] ];

console.log(board.join('\n') + '\n\n');

// キングの前のポーンを 2 つ前へ移動
board[4][4] = board[6][4];
board[6][4] = ' ';
console.log(board.join('\n'));
</pre>

<p>出力を以下に示します:</p>

<pre class="eval">R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , , 
 , , , , , , , 
 , , , , , , , 
 , , , , , , , 
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , , 
 , , , , , , , 
 , , , ,p, , , 
 , , , , , , , 
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
</pre>

<h3 id="Using_an_array_to_tabulate_a_set_of_values" name="Using_an_array_to_tabulate_a_set_of_values">配列を使って値のセットを表にする</h3>

<pre class="brush: js">values = [];
for (var x = 0; x &lt; 10; x++){
 values.push([
  2 ** x,
  2 * x ** 2
 ])
};
console.table(values)</pre>

<p>結果は次のようになります。</p>

<pre class="eval">0	1	0
1	2	2
2	4	8
3	8	18
4	16	32
5	32	50
6	64	72
7	128	98
8	256	128
9	512	162</pre>

<p>(最初の列は要素のインデックスです)</p>

<h2 id="Specifications" name="Specifications">仕様</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">仕様</th>
   <th scope="col">策定状況</th>
   <th scope="col">コメント</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>初期定義</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.4', 'Array')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>新メソッド追加: {{jsxref("Array.isArray")}}, {{jsxref("Array.prototype.indexOf", "indexOf")}}, {{jsxref("Array.prototype.lastIndexOf", "lastIndexOf")}}, {{jsxref("Array.prototype.every", "every")}}, {{jsxref("Array.prototype.some", "some")}}, {{jsxref("Array.prototype.forEach", "forEach")}}, {{jsxref("Array.prototype.map", "map")}}, {{jsxref("Array.prototype.filter", "filter")}}, {{jsxref("Array.prototype.reduce", "reduce")}}, {{jsxref("Array.prototype.reduceRight", "reduceRight")}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-array-objects', 'Array')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>新メソッド追加: {{jsxref("Array.from")}}, {{jsxref("Array.of")}}, {{jsxref("Array.prototype.find", "find")}}, {{jsxref("Array.prototype.findIndex", "findIndex")}}, {{jsxref("Array.prototype.fill", "fill")}}, {{jsxref("Array.prototype.copyWithin", "copyWithin")}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ES7', '#sec-array-objects', 'Array')}}</td>
   <td>{{Spec2('ES7')}}</td>
   <td>新メソッド追加: {{jsxref("Array.prototype.includes()")}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-array-objects', 'Array')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">ブラウザー実装状況</h2>

<div class="hidden">The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<p>{{Compat("javascript.builtins.Array")}}</p>

<h2 id="See_also" name="See_also">関連情報</h2>

<ul>
 <li><a href="/ja/docs/JavaScript/Guide/Working_with_Objects#Indexing_object_properties">JavaScript ガイド “Working with objects: オブジェクトプロパティのインデックス付け”</a></li>
 <li><a href="/ja/docs/Web/JavaScript/Guide/Predefined_Core_Objects#Array_Object">JavaScript ガイド “Predefined Core Objects: <code>Array</code> オブジェクト”</a></li>
 <li><a href="/ja/docs/Web/JavaScript/Reference/Operators/Array_comprehensions">配列内包 (Array comprehensions)</a></li>
 <li><a href="https://github.com/plusdude/array-generics">Polyfill for JavaScript 1.8.5 Array Generics and ECMAScript 5 Array Extras</a></li>
 <li><a href="/ja/docs/JavaScript_typed_arrays">Typed Arrays</a></li>
</ul>