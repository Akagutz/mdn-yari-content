<div>{{JSRef}}</div>

<p><span class="seoSummary"><strong><code>Map</code></strong> オブジェクトは単純なキー/値写像（マップ）です。</span>キーあるいは値として任意の値（オブジェクト、{{Glossary("primitive", "プリミティブ値")}}とも）を使うことができます。</p>

<h2 id="構文">構文</h2>

<pre class="syntaxbox">new Map([<em>iterable</em>])</pre>

<h3 id="引数">引数</h3>

<dl>
 <dt><code>iterable</code></dt>
 <dd>要素がキー・値の対（2 要素の配列）である {{jsxref("Array")}} または他の<a href="/ja/docs/Web/JavaScript/Guide/iterable">反復処理可能</a>なオブジェクトです(例: <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>)。それぞれのキー・値ペアが新しい Map に追加されます。<code>null</code> は <code>undefined</code> と同じに扱われます(訳注:つまり引数を指定しない場合と同じに扱われます)。</dd>
</dl>

<h2 id="解説">解説</h2>

<p>Map オブジェクトはその要素について挿入順で反復処理を行うことができます。{{jsxref("Statements/for...of", "for...of")}} ループは各処理で <code>[キー, 値]</code> の配列を返します。<br>
 <br>
 <code>Object</code>の<code>Map</code>、特に辞書の辞書である<code>Map</code>は、<code>Object</code>の挿入順にのみマップされることに注意してください。これは、ランダムで順序付けられていません。</p>

<h3 id="キーの等価性">キーの等価性</h3>

<p>キーの等価性は「same-value」アルゴリズムに基づきます：（<code>NaN !== NaN</code> であるにもかかわらず）<code>NaN</code> は <code>NaN</code> と同一と見なされ、他のすべての値は === 演算子の動作に従って等しいと見なされます。ECMAScript 6 ドラフトの以前の版では（<code>-0 === +0</code> であるにもかかわらず） <code>-0</code> と <code>+0</code> は異なると見なされていましたが、後の版で変更され、Gecko 29 {{geckoRelease("29")}} ({{bug("952870")}}) と<a href="https://code.google.com/p/v8/issues/detail?id=3069">最近の nightly Chrome</a> で適用されています。</p>

<h3 id="オブジェクトとマップの比較">オブジェクトとマップの比較</h3>

<p>{{jsxref("Object", "Objects")}} と <code>Map</code> は、両者とも値へのキーを設定したり、それらの値を取り出したり、キーを削除したり、また何かがあるキーに格納されているかを判定したりすることができるという点で似ています。このため、歴史的に <code>Object</code> は <code>Map</code> として使われてきました。しかし、<code>Map</code> の使用を望ましくする <code>Object</code> と <code>Map</code> 間の重要な違いが存在します。</p>

<ul>
 <li><code>Object</code> のキーは {{jsxref("String", "Strings")}} と {{jsxref("Symbol", "Symbols")}} ですが、<code>Map</code> では任意の値がキーとなり得ます。</li>
 <li><code>Map</code> の大きさは <code>size</code> プロパティで簡単に得ることができます。一方、<code>Object</code> の大きさは手動で保つ必要があります。</li>
 <li><code>Map</code> は <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/iterable">iterable</a> で ダイレクトに反復処理できる一方、オブジェクトを反復処理するには、何らかの方法でキーを取得し、それらのキーを元に反復処理する必要があります。</li>
 <li><code>Object</code> はプロトタイプを持つため、既定のキーがマップ中に存在します。ES5ではこれを <code>map = Object.create(null)</code> を使うことで回避することができますが、推奨しません。</li>
 <li><code>Map</code> は、頻繁に要素を追加したり削除したりするシナリオでは、パフォーマンスが<code>Object</code> に比べて良い場合があります。</li>
</ul>

<h2 id="プロパティ">プロパティ</h2>

<dl>
 <dt><code>Map.length</code></dt>
 <dd><code>length</code> プロパティの値は 0 です。</dd>
 <dt>{{jsxref("Map.@@species", "get Map[@@species]")}}</dt>
 <dd>派生クラスを生成するためのコンストラクタ関数です。</dd>
 <dt>{{jsxref("Map.prototype")}}</dt>
 <dd><code>Map</code> コンストラクタのプロトタイプを表します。すべての <code>Map</code> オブジェクトに追加のプロパティを定義できます。</dd>
</dl>

<h2 id="Map_インスタンス"><code>Map</code> インスタンス</h2>

<p>すべての <code>Map</code> インスタンスは {{jsxref("Map.prototype")}} を継承します。</p>

<h3 id="プロパティ_2">プロパティ</h3>

<p>{{page('ja/docs/Web/JavaScript/Reference/Global_Objects/Map/prototype','プロパティ')}}</p>

<h3 id="メソッド">メソッド</h3>

<p>{{page('ja/docs/Web/JavaScript/Reference/Global_Objects/Map/prototype','メソッド')}}</p>

<h2 id="例">例</h2>

<h3 id="Map_オブジェクトの使用"><code>Map</code> オブジェクトの使用</h3>

<pre class="brush: js">var myMap = new Map();

var keyString = "文字列",
    keyObj = {},
    keyFunc = function() {};

// 値を設定する
myMap.set(keyString, "'文字列' と関連付けられた値");
myMap.set(keyObj, "keyObj と関連付けられた値");
myMap.set(keyFunc, "keyFunc と関連付けられた値");

myMap.size; // 3

// 値を取得する
myMap.get(keyString);    // "'文字列' と関連付けられた値"
myMap.get(keyObj);       // "keyObj と関連付けられた値"
myMap.get(keyFunc);      // "keyFunc と関連付けられた値"

myMap.get("文字列");   // "'文字列' と関連付けられた値"
                         // keyString === '文字列' であるため
myMap.get({});           // undefined, keyObj !== {} であるため
myMap.get(function() {}) // undefined, keyFunc !== function () {} であるため
</pre>

<h3 id="Map_のキーとしての_NaN_の_使用"><code>Map</code> のキーとしての <code>NaN</code> の 使用</h3>

<p><code>NaN</code> もまたキーとして使うことができます。すべての <code>NaN</code> は自身と等しくない（<code>NaN !== NaN</code> は真）にもかかわらず、以下の例は動作します。これは <code>NaN</code> が互いに区別できないためです。</p>

<pre class="brush: js">var myMap = new Map();
myMap.set(NaN, 'not a number');

myMap.get(NaN); // "not a number"

var otherNaN = Number('foo');
myMap.get(otherNaN); // "not a number"
</pre>

<h3 id="for..of_を使用する_Map_の反復処理"><code>for..of</code> を使用する <code>Map</code> の反復処理</h3>

<p>Map は <code>for..of</code> ループを使用して反復処理を行うことができます。</p>

<pre class="brush: js">var myMap = new Map();
myMap.set(0, 'zero');
myMap.set(1, 'one');
for (var [key, value] of myMap) {
  console.log(key + ' = ' + value);
}
// 0 = zero
// 1 = one

for (var key of myMap.keys()) {
  console.log(key);
}
// 0
// 1

for (var value of myMap.values()) {
  console.log(value);
}
// zero
// one

for (var [key, value] of myMap.entries()) {
  console.log(key + ' = ' + value);
}
// 0 = zero
// 1 = one
</pre>

<h3 id="forEach()_で_Maps_を反復処理"><code>forEach()</code> で <code>Maps</code> を反復処理</h3>

<p>Map は <code>forEach()</code> メソッドを使用して反復できます:</p>

<pre class="brush: js">myMap.forEach(function(value, key) {
  console.log(key + ' = ' + value);
});
// 1行目に"0 = zero"、2行目に"1 = one"が出力されます。
</pre>

<h3 id="Array_オブジェクトとの関係"><code>Array</code> オブジェクトとの関係</h3>

<pre class="brush: js">var kvArray = [["キー1", "値1"], ["キー2", "値2"]];

// 通常の Map コンストラクタを使って、キー・値の 2 次元配列をマップに変換する
var myMap = new Map(kvArray);

myMap.get("キー1"); // "値1" を返す

// 展開演算子を使って、マップをキー・値の 2 次元配列に変換する
console.log(Array.from(myMap)); // kvArray とまったく同じ Array を表示する

// あるいは展開演算子をキーまたは値のイテレータに使って、キーまたは値のみの配列を得る
console.log(Array.from(myMap.keys())); // ["key1", "key2"] が出力される
</pre>

<h2 id="標準仕様">標準仕様</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">仕様書</th>
   <th scope="col">策定状況</th>
   <th scope="col">コメント</th>
  </tr>
  <tr>
   <td>{{SpecName('ES2015', '#sec-map-objects', 'Map')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td>初期定義。</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-map-objects', 'Map')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="ブラウザ互換性">ブラウザ互換性</h2>

<div class="hidden">The compatibility table on this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<p>{{Compat("javascript.builtins.Map")}}</p>

<h2 id="関連情報">関連情報</h2>

<ul>
 <li><a class="link-https" href="https://bugzilla.mozilla.org/show_bug.cgi?id=697479">Map and Set bug at Mozilla</a></li>
 <li><a class="external" href="http://wiki.ecmascript.org/doku.php?id=harmony:simple_maps_and_sets">ECMAScript Harmony proposal</a></li>
 <li>{{jsxref("Set")}}</li>
 <li>{{jsxref("WeakMap")}}</li>
 <li>{{jsxref("WeakSet")}}</li>
</ul>