<div>{{jsSidebar("Operators")}}</div>

<p><strong>class 式</strong>は、ECMAScript 2015 でクラスを定義する方法の 1 つです。<a href="/docs/Web/JavaScript/Reference/Operators/function">function 式</a>と同じように、class 式は名前を付けることも付けないこともできます。名前を付ける場合、クラス名はクラス内部のみローカルです。 JavaScript のクラスはプロトタイプベースの継承が使われます。</p>

<p>{{EmbedInteractiveExample("pages/js/expressions-classexpression.html")}}</p>

<div class="hidden">
<p>The source for this interactive example is stored in a GitHub repository. If you'd like to contribute to the interactive examples project, please　clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> and send us a pull request.</p>
</div>

<p> </p>

<h2 id="Syntax" name="Syntax">構文</h2>

<pre class="syntaxbox">var MyClass = class <em>[className]</em> [extends] {  // class body };</pre>

<h2 id="Description" name="Description">説明</h2>

<p>class 式の構文は、<a href="/docs/Web/JavaScript/Reference/Statements/class">class 文(宣言)</a> と似ています。ただし、class 式ではクラス名 (束縛識別子; "binding identifier") を省略できますが、class 文では省略できません。また、class 式は、class の再定義/再宣言が可能で、<a href="/ja/docs/Web/JavaScript/Reference/Statements/class">class 文</a> のように型エラーを<strong>スローしません</strong>。コンストラクタプロパティはオプションです。また、このキーワードを使って生成したクラスの <em>typeof</em> は常に "functions" になります。</p>

<p>class 文のように、class 式のクラス内部は <a href="/ja/docs/Web/JavaScript/Reference/Strict_mode">strict モード</a> で実行されます。</p>

<pre class="brush: js">'use strict';
var Foo = class {}; // コンストラクタプロパティはオプション
var Foo = class {}; // 再宣言は可能

typeof Foo; // "function" を返す
typeof class {}; // "function" を返す

Foo instanceof Object; // true
Foo instanceof Function; // true
class Foo {}; // 再宣言は不可能で、TypeError を投げる
</pre>

<h2 id="Examples" name="Examples">例</h2>

<h3 id="A_simple_class_expression" name="A_simple_class_expression">簡単な class 式</h3>

<p>以下は、名前のない簡単な class 式です。変数 "Foo" を使って参照できます。</p>

<pre class="brush: js">var Foo = class {
  constructor() {}
  bar() {
    return "Hello World!";
  }
};

var instance = new Foo();
instance.bar(); // "Hello World!"
Foo.name; // "Foo"
</pre>

<h3 id="Named_class_expressions" name="Named_class_expressions">名前付き class 式</h3>

<p>クラス内部で現在のクラスを参照したい場合は、名前付きクラス式を作成してください。この名前は、その class 式自身のスコープ内でだけ見えます。</p>

<pre class="brush: js">var Foo = class NamedFoo {
  constructor() {}
  whoIsThere() {
    return NamedFoo.name;
  }
}
var bar = new Foo();
bar.whoIsThere(); // "NamedFoo"
NamedFoo.name; // ReferenceError: NamedFoo is not defined
Foo.name; // "NamedFoo"
</pre>

<h2 id="Specifications" name="Specifications">仕様</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">仕様</th>
   <th scope="col">状態</th>
   <th scope="col">コメント</th>
  </tr>
  <tr>
   <td>{{SpecName('ES2015', '#sec-class-definitions', 'Class definitions')}}</td>
   <td>{{Spec2('ES2015')}}</td>
   <td>最初の定義。</td>
  </tr>
  <tr>
   <td>{{SpecName('ES2016', '#sec-class-definitions', 'Class definitions')}}</td>
   <td>{{Spec2('ES2016')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES2017', '#sec-class-definitions', 'Class definitions')}}</td>
   <td>{{Spec2('ES2017')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-class-definitions', 'Class definitions')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">ブラウザ実装状況</h2>

<div class="hidden">
<p>The compatibility table on this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>
</div>

<p>{{Compat("javascript.operators.class")}}</p>

<div id="compat-desktop"> </div>

<h2 id="See_also" name="See_also">関連項目</h2>

<ul>
 <li><a href="/ja/docs/Web/JavaScript/Reference/Operators/function"><code>function</code> 式</a></li>
 <li><a href="/ja/docs/Web/JavaScript/Reference/Statements/class"><code>class</code> 文</a></li>
 <li><a href="/ja/docs/Web/JavaScript/Reference/Classes">クラス</a></li>
</ul>