<div>{{JSRef}}</div>

<p>JavaScript <strong><code>Array</code></strong> 전역 객체는 배열을 생성할 때 사용하는 리스트 형태의 고수준 객체입니다.</p>

<p><strong>배열 만들기</strong></p>

<pre class="brush: js">var fruits = ['사과', '바나나'];

console.log(fruits.length);
// 2
</pre>

<p><strong>인덱스로 배열의 항목에 접근하기</strong></p>

<pre class="brush: js">var first = fruits[0];
// 사과

var last = fruits[fruits.length - 1];
// 바나나
</pre>

<p><strong>배열의 항목들을 순환하며 처리하기</strong></p>

<pre class="brush: js">fruits.forEach(function (item, index, array) {
  console.log(item, index);
});
// 사과 0
// 바나나 1
</pre>

<p><strong>배열 끝에 항목 추가하기</strong></p>

<pre class="brush: js">var newLength = fruits.push('오렌지');
// ["사과", "바나나", "오렌지"]
</pre>

<p><strong>배열 끝에서부터 항목 제거하기</strong></p>

<pre class="brush: js">var last = fruits.pop(); // 끝에있던 '오렌지'를 제거
// ["사과", "바나나"];
</pre>

<p><strong>배열 앞에서부터 항목 제거하기</strong></p>

<pre class="brush: js">var first = fruits.shift(); // 제일 앞의 '사과'를 제거
// ["바나나"];
</pre>

<p><strong>배열 앞에 항목 추가하기</strong></p>

<pre class="brush: js">var newLength = fruits.unshift('딸기') // 앞에 추가
// ["딸기", "바나나"];
</pre>

<p><strong>배열 안 항목의 인덱스 찾기</strong></p>

<pre class="brush: js">fruits.push('망고');
// ["딸기", "바나나", "망고"]

var pos = fruits.indexOf("바나나");
// 1
</pre>

<p><strong>인덱스 위치에 있는 항목 제거하기</strong></p>

<pre class="brush: js">var removedItem = fruits.splice(pos, 1); // 항목을 제거하는 방법

// ["딸기", "망고"]
</pre>

<p><strong>인덱스 위치에서부터 여러개의 항목 제거하기</strong></p>

<pre class="brush: js">var vegetables = ['양배추', '순무', '무', '당근'];
console.log(vegetables); 
// ["양배추", "순무", "무", "당근"]

var pos = 1, n = 2;

var removedItems = vegetables.splice(pos, n); 
// 배열에서 항목을 제거하는 방법
// pos 인덱스부터 n개의 항목을 제거함

console.log(vegetables); 
// ["양배추", "당근"] (원 배열 vegetables의 값이 변함)

console.log(removedItems); 
// ["순무", "무"]
</pre>

<p><strong>배열 복사하기</strong></p>

<pre class="brush: js">var shallowCopy = fruits.slice(); // 사본을 만드는 방법
// ["딸기", "망고"]
</pre>

<h2 id="구문">구문</h2>

<pre class="syntaxbox">[<var>element0</var>, <var>element1</var>, ..., <var>elementN</var>]
new Array(<var>element0</var>, <var>element1</var>[, ...[, <var>elementN</var>]])
new Array(<var>arrayLength</var>)</pre>

<h3 id="매개변수">매개변수</h3>

<dl>
 <dt><code>elementN</code></dt>
 <dd>JavaScript 배열을 초기화하고 넣을 요소. 예외적으로 하나의 숫자 인수만 <code>Array</code> 생성자에 전달하는 경우는 다르게 처리합니다. 아래 <code>arrayLength</code>를 참고하세요. 이는 <code>Array</code> 생성자에만 적용되고, 대괄호 구문으로 만드는 배열 리터럴은 해당하지 않습니다.</dd>
 <dt><code>arrayLength</code></dt>
 <dd>만약 <code>Array</code> 생성자에 전달한 인수가 0과 2<sup>32</sup>-1 사이의 정수(끝값 포함) 하나뿐이라면 새로운 JavaScript 배열을 생성하고 <code>length</code> 속성을 그 숫자로 설정해서 반환합니다. 이 외의 수를 받으면 {{jsxref("RangeError")}} 예외가 발생합니다.</dd>
</dl>

<h2 id="설명">설명</h2>

<p>배열은 프로토타입으로 탐색과 변형 작업을 수행하는 메서드를 갖는, 리스트와 비슷한 객체입니다. JavaScript에서 배열의 길이와 요소의 자료형은 고정되어 있지 않습니다. 배열의 길이가 언제든지 늘어나거나 줄어들 수 있기 때문에 JavaScript 배열들은 밀집도가 보장되지 않습니다. 보통 이 성질은 편리하지만, 목적에 맞지 않는다면 형식화 배열<sup>typed array</sup>을 사용하는 것을 고려해보세요.</p>

<p>배열은 요소 인덱스로 문자열(<a href="https://ko.wikipedia.org/wiki/%EC%97%B0%EA%B4%80_%EB%B0%B0%EC%97%B4">연관 배열</a>)을 사용할 수 없으며 무조건 정수만 허용합니다. <a href="/ko/docs/Web/JavaScript/Reference/Operators/Property_Accessors">속성 접근자</a>를 사용해 정수 외 키에 접근할 경우 배열 리스트의 요소가 아니라 배열 객체의 속성 변수를 설정하거나 회수합니다. 배열 객체의 속성과 배열 요소의 리스트의 요소는 서로 다른 별개의 항목으로, <a href="/ko/docs/Web/JavaScript/Guide/Indexed_collections#배열_객체의_메서드">순회 및 변형 작업</a>은 객체 속성에 적용되지 않습니다.</p>

<h3 id="배열_요소에_접근하기">배열 요소에 접근하기</h3>

<p>JavaScript 배열의 인덱스는 0부터 시작합니다. 즉, 배열의 첫 번째 요소의 인덱스는 0이고, 마지막 요소의 인덱스는 배열의 {{jsxref("Array.length", "length")}} 속성에서 1을 뺀 것과 같습니다. 잘못된 인덱스를 사용하면 <code>undefined</code>를 반환합니다.</p>

<pre class="brush: js">var arr = ['첫 번재 요소입니다', '두 번째 요소입니다', '마지막 요소입니다'];
console.log(arr[0]);              // '첫 번재 요소입니다'를 기록
console.log(arr[1]);              // '두 번재 요소입니다'를 기록
console.log(arr[arr.length - 1]); // '마지막 요소입니다'를 기록
</pre>

<p><code>toString</code>이 속성인 것과 마찬가지로 배열의 요소도 속성입니다. 하지만 아래의 예시같이 배열 요소에 접근하려 하면, 속성 이름이 잘못되었기 때문에 구문 오류가 발생합니다.</p>

<pre class="brush: js">console.log(arr.0); // 구문 오류
</pre>

<p>JavaScript 배열과 속성에 대해서도 특별한 점이 없습니다. 숫자로 시작하는 JavaScript 속성은 점 표현으로 참조할 수 없고 대괄호 표현을 사용해서만 참조할 수 있습니다. 만약 '<code>3d</code>'라는 속성을 가진 객체가 있다면, 그 속성은 대괄호 표현으로만 참조할 수 있습니다. 예를 들면,</p>

<pre class="brush: js">var years = [1950, 1960, 1970, 1980, 1990, 2000, 2010];
console.log(years.0);   // 구문 오류
console.log(years[0]);  // 정상 작동
</pre>

<pre class="brush: js">renderer.3d.setTexture(model, 'character.png');     // 구문 오류
renderer['3d'].setTexture(model, 'character.png');  // 정상 작동
</pre>

<p><code>3d</code> 예시에서 <code>'3d'</code>가 따옴표로 둘러싸여야 함에 유의하십시오. JavaScript 배열 인덱스도 따옴표로 둘러쌀 수 있지만(<code>years[2]</code> 대신에 <code>years['2']</code>처럼) 꼭 필요하지는 않습니다. <code>years[2]</code>의 2는 JavaScript 엔진이 <code>toString</code> 변환을 사용해 강제로 문자열로 변환합니다. <code>'2'</code>와 <code>'02'</code>가 <code>years</code> 객체의 서로 다른 두 개의 칸을 가리켜서 다음 예시가 <code>true</code>일 수 있기 때문입니다.</p>

<pre class="brush: js">console.log(years['2'] != years['02']);
</pre>

<p>마찬가지로, 객체가 예약어를 속성으로 갖게 되었을 때(!) 그 속성은 대괄호 표현의 문자열 값으로만 접근할 수 있습니다(하지만 Firefox 40.0a2까지는 점 표현으로 접근할 수 있습니다).</p>

<pre class="brush: js">var promise = {
  'var'  : 'text',
  'array': [1, 2, 3, 4]
};

console.log(promise['array']);
</pre>

<h3 id="length_와_숫자형_속성의_관계"><code>length</code> 와 숫자형 속성의 관계</h3>

<p>JavaScript 배열의 {{jsxref("Array.length", "length")}} 속성과 숫자형 속성은 연결되어 있습니다. 몇몇 배열 내장 메서드들(예: {{jsxref("Array.join", "join")}}, {{jsxref("Array.slice", "slice")}}, {{jsxref("Array.indexOf", "indexOf")}}, 등등.)은 호출되었을 때 배열의 {{jsxref("Array.length", "length")}} 속성의 값을 참조합니다. 다른 메서드들(예: {{jsxref("Array.push", "push")}}, {{jsxref("Array.splice", "splice")}}, 등등.) 또한 배열의 {{jsxref("Array.length", "length")}} 속성을 업데이트을 유발합니다.</p>

<pre class="brush: js">var fruits = [];
fruits.push('banana', 'apple', 'peach');

console.log(fruits.length); // 3
</pre>

<p>JavaScript 배열의 속성을 설정할 때 그 속성이 유효한 배열 인덱스이고 그 인덱스가 현재 배열의 경계(bounds)를 넘어간다면, 엔진은 배열의 {{jsxref("Array.length", "length")}} 속성을 그에 맞춰 업데이트 합니다:</p>

<pre class="brush: js">fruits[5] = 'mango';
console.log(fruits[5]); // 'mango'
console.log(Object.keys(fruits));  // ['0', '1', '2', '5']
console.log(fruits.length); // 6
</pre>

<p>{{jsxref("Array.length", "length")}} 증가.</p>

<pre class="brush: js">fruits.length = 10;
console.log(Object.keys(fruits)); // ['0', '1', '2', '5']
console.log(fruits.length); // 10
</pre>

<p>하지만, {{jsxref("Array.length", "length")}} 속성을 감소시키면 요소(element)를 지웁니다.</p>

<pre class="brush: js">fruits.length = 2;
console.log(Object.keys(fruits)); // ['0', '1']
console.log(fruits.length); // 2
</pre>

<p>이것은 {{jsxref("Array.length")}} 페이지에 더 설명되어있습니다.</p>

<h3 id="매치_결과를_이용한_배열_생성">매치 결과를 이용한 배열 생성</h3>

<p>정규표현식과 문자열 사이의 매치 결과로 JavaScript 배열을 만들 수 있습니다. 이 배열은 매치에 대한 정보를 제공하는 속성들과 요소들을 가집니다. 이러한 배열은 {{jsxref("RegExp.exec")}}, {{jsxref("String.match")}}, {{jsxref("String.replace")}}로부터 반환됩니다. 이 속성들과 요소들에 대한 설명을 돕기위해, 다음 예제를 보고 아래 테이블을 참조해주세요.</p>

<pre class="brush: js">// 하나의 d와 하나 이상의 b에 하나의 d가 뒤따라 일치해야 합니다.
// 일치한 b와 다음 d를 기억하십시오.
// 대소문자 구분은 무시됩니다.

var myRe = /d(b+)(d)/i;
var myArray = myRe.exec('cdbBdbsbz');
</pre>

<p>매치로부터 반환되는 속성들과 요소들은 다음과 같습니다:</p>

<table class="fullwidth-table">
 <tbody>
  <tr>
   <td class="header">속성/요소</td>
   <td class="header">설명</td>
   <td class="header">예</td>
  </tr>
  <tr>
   <td><code>input</code></td>
   <td>정규 표현식과 일치시키는 원본 문자열을 나타내는 읽기 전용 속성입니다.</td>
   <td>cdbBdbsbz</td>
  </tr>
  <tr>
   <td><code>index</code></td>
   <td>원본 문자열에서 정규 표현식이 처음 일치하는 문자열의 위치(원본 문자열의 첫 문자 위치를 0으로 하는)를 나타내는 읽기 전용 속성입니다.</td>
   <td>1</td>
  </tr>
  <tr>
   <td><code>[0]</code></td>
   <td>원본 문자열에서 정규 표현식이 처음 일치하는 문자열을 지정하는 읽기 전용 요소입니다.</td>
   <td>dbBd</td>
  </tr>
  <tr>
   <td><code>[1], ...[n]</code></td>
   <td>만약 정규 표현식에 괄호가 포함돼 있다면 괄호에 일치하는 부분 문자열을 나타내는 읽기 전용 요소들입니다. 가능한 괄호 안의 부분 문자열의 수는 무제한입니다.</td>
   <td>[1]: bB<br>
    [2]: d</td>
  </tr>
 </tbody>
</table>

<h2 id="속성">속성</h2>

<dl>
 <dt><code>Array.length</code></dt>
 <dd>값이 1인 <code>Array</code> 생성자의 길이 속성입니다.</dd>
 <dt>{{jsxref("Array.@@species", "get Array[@@species]")}}</dt>
 <dd>파생 객체를 생성하는데 사용하는 생성자 함수입니다.</dd>
 <dt>{{jsxref("Array.prototype")}}</dt>
 <dd>모든 배열 객체에 속성 추가를 할 수 있습니다.</dd>
</dl>

<h2 id="메서드">메서드</h2>

<dl>
 <dt>{{jsxref("Array.from()")}}</dt>
 <dd>유사 배열 또는 반복 가능한 객체로부터 새로운 <code>Array</code> 인스턴스를 생성합니다.</dd>
 <dt>{{jsxref("Array.isArray()")}}</dt>
 <dd>만약 변수가 배열이면 참을, 아니면 거짓을 반환합니다.</dd>
 <dt>{{jsxref("Array.of()")}}</dt>
 <dd>전달인자의 개수나 데이터 타입에 관계없이 새 <code>Array</code> 인스턴스를 생성합니다.</dd>
</dl>

<h2 id="Array_인스턴스"><code>Array</code> 인스턴스</h2>

<p>모든 <code>Array</code> 인스턴스는 {{jsxref("Array.prototype")}}로부터 상속을 받습니다. <code>Array</code> 생성자의 프로토타입 객체는 모든 <code>Array</code> 인스턴스에 영향을 주도록 수정될 수 있습니다.</p>

<h3 id="속성_2">속성</h3>

<div>{{page('/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', '속성')}}</div>

<h3 id="메서드_2">메서드</h3>

<h4 id="변경자_메서드">변경자 메서드</h4>

<div>{{page('/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', '변경자_메서드')}}</div>

<h4 id="접근자_메서드">접근자 메서드</h4>

<div>{{page('/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', '접근자_메서드')}}</div>

<h4 id="순회_메서드">순회 메서드</h4>

<div>{{page('/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype', '순회_메서드')}}</div>

<h2 id="예제">예제</h2>

<h3 id="배열_생성">배열 생성</h3>

<p>아래 예제는 길이 0의 배열 <code>msgArray</code> 을 생성하고, <code>msgArray[0]</code> 와 <code>msgArray[99]</code> 에 값을 할당하여, 배열의 길이를 100으로 변경합니다.</p>

<pre class="brush: js">var msgArray = [];
msgArray[0] = 'Hello';
msgArray[99] = 'world';

if (msgArray.length === 100) {
  console.log('The length is 100.');
}
</pre>

<h3 id="2차원_배열_생성">2차원 배열 생성</h3>

<p>아래의 예제는 2차원 문자열 배열로 체스보드를 생성합니다. 첫번째 이동은 (6,4)의 'p'를 (4,4)로 복사하여 이루어집니다. 이전 위치 (6,4)는 빈공간으로 만듭니다.</p>

<pre class="brush: js">var board = [ 
  ['R','N','B','Q','K','B','N','R'],
  ['P','P','P','P','P','P','P','P'],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  [' ',' ',' ',' ',' ',' ',' ',' '],
  ['p','p','p','p','p','p','p','p'],
  ['r','n','b','q','k','b','n','r'] ];

console.log(board.join('\n') + '\n\n');

// Move King's Pawn forward 2
board[4][4] = board[6][4];
board[6][4] = ' ';
console.log(board.join('\n'));
</pre>

<p>결과는 다음과 같습니다.</p>

<pre class="eval">R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , , 
 , , , , , , , 
 , , , , , , , 
 , , , , , , , 
p,p,p,p,p,p,p,p
r,n,b,q,k,b,n,r

R,N,B,Q,K,B,N,R
P,P,P,P,P,P,P,P
 , , , , , , , 
 , , , , , , , 
 , , , ,p, , , 
 , , , , , , , 
p,p,p,p, ,p,p,p
r,n,b,q,k,b,n,r
</pre>

<h3 id="배열을_사용하여_일련의_값을_테이블처럼_표시하기">배열을 사용하여 일련의 값을 테이블처럼 표시하기</h3>

<pre class="brush: js line-numbers  language-js">values = [];
for (var x = 0; x &lt; 10; x++){
  values.push([
    2 ** x,
    2 * x ** 2
  ]);
};
console.table(values);</pre>

<p>결과는 다음과 같습니다.</p>

<pre class="eval line-numbers  language-html">0    1    0
1    2    2
2    4    8
3    8    18
4    16    32
5    32    50
6    64    72
7    128    98
8    256    128
9    512    162
</pre>

<p>(첫번째 열은 (인덱스))</p>

<h2 id="명세">명세</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Initial definition.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.4', 'Array')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>New methods added: {{jsxref("Array.isArray")}}, {{jsxref("Array.prototype.indexOf", "indexOf")}}, {{jsxref("Array.prototype.lastIndexOf", "lastIndexOf")}}, {{jsxref("Array.prototype.every", "every")}}, {{jsxref("Array.prototype.some", "some")}}, {{jsxref("Array.prototype.forEach", "forEach")}}, {{jsxref("Array.prototype.map", "map")}}, {{jsxref("Array.prototype.filter", "filter")}}, {{jsxref("Array.prototype.reduce", "reduce")}}, {{jsxref("Array.prototype.reduceRight", "reduceRight")}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-array-objects', 'Array')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td>New methods added: {{jsxref("Array.from")}}, {{jsxref("Array.of")}}, {{jsxref("Array.prototype.find", "find")}}, {{jsxref("Array.prototype.findIndex", "findIndex")}}, {{jsxref("Array.prototype.fill", "fill")}}, {{jsxref("Array.prototype.copyWithin", "copyWithin")}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ES7', '#sec-array-objects', 'Array')}}</td>
   <td>{{Spec2('ES7')}}</td>
   <td>New method added: {{jsxref("Array.prototype.includes()")}}</td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-array-objects', 'Array')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="브라우저_호환성">브라우저 호환성</h2>

<div class="hidden">The compatibility table in this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<p>{{Compat("javascript.builtins.Array")}}</p>

<h2 id="같이_보기">같이 보기</h2>

<ul>
 <li><a href="/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Indexing_object_properties">JavaScript Guide: “Indexing object properties”</a></li>
 <li><a href="/en-US/docs/Web/JavaScript/Guide/Predefined_Core_Objects#Array_Object">JavaScript Guide: “Predefined Core Objects: <code>Array</code> Object”</a></li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions">Array comprehensions</a></li>
 <li><a href="https://github.com/plusdude/array-generics">Polyfill for JavaScript 1.8.5 Array Generics and ECMAScript 5 Array Extras</a></li>
 <li><a href="/en-US/docs/JavaScript_typed_arrays">Typed Arrays</a></li>
</ul>