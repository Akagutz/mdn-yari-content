<div>{{JSRef}}</div>

<p>De <code><strong>Object.defineProperty()</strong></code> functie definiëert een nieuwe eigenschap in een object, of bewerkt een bestaande eigenschap van een object, en geeft het object terug.</p>

<h2 id="Syntaxis">Syntaxis</h2>

<pre class="syntaxbox"><code>Object.defineProperty(<var>obj</var>, <var>prop</var>, <var>descriptor</var>)</code></pre>

<h3 id="Parameters">Parameters</h3>

<dl>
 <dt><code>obj</code></dt>
 <dd>Het object waarin de eigenschap wordt gedefiniëerd.</dd>
 <dt><code>prop</code></dt>
 <dd>De naam van de eigenschap die bewerkt of gedefiniëerd moet worden.</dd>
 <dt><code>descriptor</code></dt>
 <dd>De definitie van de te definiëren of wijzigen eigenschap.</dd>
</dl>

<h3 id="Return-waarde">Return-waarde</h3>

<p>Het object dat gegeven is in de <code>obj</code> parameter</p>

<h2 id="Beschrijving">Beschrijving</h2>

<p>Met deze methode kan een eigenschap op een nauwkeurige manier worden toegevoegd of veranderd. Als u een eigenschap op de normale manier, door een toekenning, aan een object toevoegt, verschijnt deze in eigenschap-enumeraties zoals een {{jsxref("Statements/for...in", "for...in")}} loop of de {{jsxref("Object.keys")}} methode. Waarden kunnen dan veranderd of {{jsxref("Operators/delete", "verwijderd", "", 1)}} worden. Standaard gedrag van eigenschappen die met <code>Object.defineProperty()</code>  worden toegevoegd is daarentegen dat zij onveranderbaar zijn.</p>

<p>Eigenschapbeschrijvingen zijn er in twee smaken: data-beschrijvingen en accessor-beschrijvingen. Een <em>data-beschrijving</em> is een eigenschap die een waarde heeft, die al of niet herschrijfbaar is. Een <em>accessor-beschrijving</em> bestaat uit een getter-setter-paar van functies. Een beschrijving is een van de twee; het kan niet allebei tegelijk zijn.</p>

<p lang="nl">Data- en accessor-beschrijvingen zijn objecten. Zij hebben beiden de volgende verplichte keys:</p>

<p><code>configurable</code></p>

<dl>
 <dd><code>true</code> uitsluitend wanneer het type van deze eigenschapbeschrijving gewijzigd mag worden en de eigenschap verwijderd mag worden uit het betreffende object.<br>
 <strong>Defaultwaarde is <code>false</code>.</strong></dd>
 <dt><code>enumerable</code></dt>
 <dd><code>true</code> uitsluitend wanneer de eigenschap verschijnt in enumeraties van de eigenschappen van het betreffende object.<br>
 <strong>Defaults to <code>false</code>.</strong></dd>
</dl>

<p>Een data-beschrijving heeft daarnaast ook de volgende optionele keys:</p>

<dl>
 <dt><code>value</code></dt>
 <dd>De waarde van de eigenschap. Kan iedere geldige JavaScriptwaarde zijn: nummer, object, functie, etc.<br>
 <strong>Default: {{jsxref("undefined")}}.</strong></dd>
 <dt><code>writable</code></dt>
 <dd><code>true</code> uitlsuitend wanneer de waarde van de eigenschap veranderd mag worden door een {{jsxref("Operators/Assignment_Operators", "assignment operator", "", 1)}}.<br>
 <strong>Default: <code>false</code>.</strong></dd>
</dl>

<p>Een accessor-beschrijving heeft ook de volgende optionele keys:</p>

<dl>
 <dt><code>get</code></dt>
 <dd>Een functie die dient als een getter voor de eigenschap, of {{jsxref("undefined")}} als er geen getter is. Wat deze functie teruggeeft geldt als de waarde van de eigenschap.<br>
 <strong>Default: {{jsxref("undefined")}}.</strong></dd>
 <dt><code>set</code></dt>
 <dd>Een functie die dient als een setter voor de eigenschap, of {{jsxref("undefined")}} als er geen setter is. Als aan de eigenschap een nieuwe waarde wordt toegekend wordt deze functie aangeroepem met de nieuwe waarde als argument. <code>this</code> is dan het object waardoor de eigenschap is toegekend.<br>
 <strong>Default: {{jsxref("undefined")}}.</strong></dd>
</dl>

<p>Als een beschrijving geen <code>value</code>, <code>writable</code>, <code>get</code> and <code>set </code>keys bevat wordt hij als een data-beschrijving behandeld. Als een beschrijving zowel <code>value</code> of <code>writable</code>, en ook <code>get</code> en <code>set</code> keys bevat, wordt een exceptie geworpen.</p>

<p>Houd er rekening mee dat deze opties niet de eigen eigenschappen van de beschrijving hoeven te zijn. Eigenschappen die geerfd worden van de prototypeketen worden ook meegenomen. Om er zeker van te zijn dat deze defaults bewaard blijven kunt u het  {{jsxref("Object.prototype")}} van tevoren bevriezen, alle eigenschappen expliciet benoemen, of verwijzen naar {{jsxref("null")}} als {{jsxref("Object.prototype.__proto__", "__proto__")}} eigenschap.</p>

<pre class="brush: js">// met __proto__
var obj = {};
Object.defineProperty(obj, 'key', {
  __proto__: null, // geen overgenomen eigendommen
  value: 'static'  // niet enumerable
                   // niet bewerkbaar
                   // niet herschrijfbaar
                   // als standaard
});

// expliciet
Object.defineProperty(obj, 'key', {
  enumerable: false,
  configurable: false,
  writable: false,
  value: 'static'
});

// hetzelfde object bewaren
function withValue(value) {
  var d = withValue.d || (
    withValue.d = {
      enumerable: false,
      writable: false,
      configurable: false,
      value: null
    }
  );
  d.value = value;
  return d;
}
// ... en ...
Object.defineProperty(obj, 'key', withValue('static'));
</pre>

<h2 id="Voorbeelden">Voorbeelden</h2>

<p>Als je de <code>Object.defineProperty</code> functie wilt gebruiken met een <em>binaire-vlaggen-achtige</em> syntax, zie <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples">andere voorbeelden</a>.</p>

<h3 id="Een_eigenschap_maken">Een eigenschap maken</h3>

<p>When the property specified doesn't exist in the object, <code>Object.defineProperty()</code> creates a new property as described. Fields may be omitted from the descriptor, and default values for those fields are imputed. All of the Boolean-valued fields default to <code>false</code>. The <code>value</code>, <code>get</code>, and <code>set</code> fields default to {{jsxref("undefined")}}. A property which is defined without <code>get</code>/<code>set</code>/<code>value</code>/<code>writable</code> is called “generic” and is “typed” as a data descriptor.</p>

<pre class="brush: js">var o = {}; // Creates a new object

// Example of an object property added
// with defineProperty with a data property descriptor
Object.defineProperty(o, 'a', {
  value: 37,
  writable: true,
  enumerable: true,
  configurable: true
});
// 'a' property exists in the o object and its value is 37

// Example of an object property added
// with defineProperty with an accessor property descriptor
var bValue = 38;
Object.defineProperty(o, 'b', {
  get: function() { return bValue; },
  set: function(newValue) { bValue = newValue; },
  enumerable: true,
  configurable: true
});
o.b; // 38
// 'b' property exists in the o object and its value is 38
// The value of o.b is now always identical to bValue,
// unless o.b is redefined

// You cannot try to mix both:
Object.defineProperty(o, 'conflict', {
  value: 0x9f91102,
  get: function() { return 0xdeadbeef; }
});
// throws a TypeError: value appears
// only in data descriptors,
// get appears only in accessor descriptors
</pre>

<h3 id="Een_eigenschap_bewerken">Een eigenschap bewerken</h3>

<p>When the property already exists, <code>Object.defineProperty()</code> attempts to modify the property according to the values in the descriptor and the object's current configuration. If the old descriptor had its <code>configurable</code> attribute set to <code>false</code> (the property is said to be “non-configurable”), then no attribute besides <code>writable</code> can be changed. In that case, it is also not possible to switch back and forth between the data and accessor property types.</p>

<p>If a property is non-configurable, its <code>writable</code> attribute can only be changed to <code>false</code>.</p>

<p>A {{jsxref("TypeError")}} is thrown when attempts are made to change non-configurable property attributes (besides the <code>writable</code> attribute) unless the current and new values are the same.</p>

<h4 id="Writable_attribute">Writable attribute</h4>

<p>When the <code>writable</code> property attribute is set to <code>false</code>, the property is said to be “non-writable”. It cannot be reassigned.</p>

<pre class="brush: js">var o = {}; // Creates a new object

Object.defineProperty(o, 'a', {
  value: 37,
  writable: false
});

console.log(o.a); // logs 37
o.a = 25; // No error thrown
// (it would throw in strict mode,
// even if the value had been the same)
console.log(o.a); // logs 37. The assignment didn't work.
</pre>

<p>As seen in the example, trying to write into the non-writable property doesn't change it but doesn't throw an error either.</p>

<h4 id="Enumerable_attribute">Enumerable attribute</h4>

<p>The <code>enumerable</code> property attribute defines whether the property shows up in a {{jsxref("Statements/for...in", "for...in")}} loop and {{jsxref("Object.keys()")}} or not.</p>

<pre class="brush: js">var o = {};
Object.defineProperty(o, 'a', {
  value: 1,
  enumerable: true
});
Object.defineProperty(o, 'b', {
 value: 2,
 enumerable: false
});
Object.defineProperty(o, 'c', {
  value: 3
}); // enumerable defaults to false
o.d = 4; // enumerable defaults to true
         // when creating a property by setting it

for (var i in o) {
  console.log(i);
}
// logs 'a' and 'd' (in undefined order)

Object.keys(o); // ['a', 'd']

o.propertyIsEnumerable('a'); // true
o.propertyIsEnumerable('b'); // false
o.propertyIsEnumerable('c'); // false
</pre>

<h4 id="Configurable_attribute">Configurable attribute</h4>

<p>The <code>configurable</code> attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than <code>writable</code>) can be changed.</p>

<pre class="brush: js">var o = {};
Object.defineProperty(o, 'a', {
  get: function() { return 1; },
  configurable: false
});

Object.defineProperty(o, 'a', {
  configurable: true
}); // throws a TypeError
Object.defineProperty(o, 'a', {
  enumerable: true
}); // throws a TypeError
Object.defineProperty(o, 'a', {
  set: function() {}
}); // throws a TypeError (set was undefined previously)
Object.defineProperty(o, 'a', {
  get: function() { return 1; }
}); // throws a TypeError
// (even though the new get does exactly the same thing)
Object.defineProperty(o, 'a', {
  value: 12
}); // throws a TypeError

console.log(o.a); // logs 1
delete o.a; // Nothing happens
console.log(o.a); // logs 1
</pre>

<p>If the <code>configurable</code> attribute of <code>o.a</code> had been <code>true</code>, none of the errors would be thrown and the property would be deleted at the end.</p>

<h3 id="Eigenschappen_toevoegen_en_standaardwaarden_instellen">Eigenschappen toevoegen en standaardwaarden instellen</h3>

<p>It's important to consider the way default values of attributes are applied. There is often a difference between simply using dot notation to assign a value and using <code>Object.defineProperty()</code>, as shown in the example below.</p>

<pre class="brush: js">var o = {};

o.a = 1;
// is equivalent to:
Object.defineProperty(o, 'a', {
  value: 1,
  writable: true,
  configurable: true,
  enumerable: true
});


// On the other hand,
Object.defineProperty(o, 'a', { value: 1 });
// is equivalent to:
Object.defineProperty(o, 'a', {
  value: 1,
  writable: false,
  configurable: false,
  enumerable: false
});
</pre>

<h3 id="Eigen_getters_en_setters">Eigen getters en setters</h3>

<p>Example below shows how to implement a self-archiving object. When <code>temperature</code> property is set, the <code>archive</code> array gets a log entry.</p>

<pre class="brush: js">function Archiver() {
  var temperature = null;
  var archive = [];

  Object.defineProperty(this, 'temperature', {
    get: function() {
      console.log('get!');
      return temperature;
    },
    set: function(value) {
      temperature = value;
      archive.push({ val: temperature });
    }
  });

  this.getArchive = function() { return archive; };
}

var arc = new Archiver();
arc.temperature; // 'get!'
arc.temperature = 11;
arc.temperature = 13;
arc.getArchive(); // [{ val: 11 }, { val: 13 }]
</pre>

<p>or</p>

<pre class="brush: js">var pattern = {
    get: function () {
        return 'I always return this string, ' +
               'whatever you have assigned';
    },
    set: function () {
        this.myname = 'this is my name string';
    }
};


function TestDefineSetAndGet() {
    Object.defineProperty(this, 'myproperty', pattern);
}


var instance = new TestDefineSetAndGet();
instance.myproperty = 'test';
console.log(instance.myproperty);
// I always return this string, whatever you have assigned

console.log(instance.myname); // this is my name string

</pre>

<h2 id="Specificaties">Specificaties</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specificatie</th>
   <th scope="col">Status</th>
   <th scope="col">Commentaar</th>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.2.3.6', 'Object.defineProperty')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td>Initial definition. Implemented in JavaScript 1.8.5.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-object.defineproperty', 'Object.defineProperty')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-object.defineproperty', 'Object.defineProperty')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browsercompatibiliteit">Browsercompatibiliteit</h2>

<div>{{CompatibilityTable}}</div>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Firefox (Gecko)</th>
   <th>Chrome</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari</th>
  </tr>
  <tr>
   <td>Standaardondersteuning</td>
   <td>{{CompatGeckoDesktop("2")}}</td>
   <td>{{CompatChrome("5")}}</td>
   <td>{{CompatIE("9")}} [1]</td>
   <td>{{CompatOpera("11.60")}}</td>
   <td>{{CompatSafari("5.1")}} [2]</td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>Android</th>
   <th>IE Mobile</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td>Standaardondersteuning</td>
   <td>{{CompatGeckoMobile("2")}}</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatIE("9")}}</td>
   <td>{{CompatOperaMobile("11.5")}}</td>
   <td>{{CompatVersionUnknown}}</td>
  </tr>
 </tbody>
</table>
</div>

<p>[1] In Internet Explorer 8 only on DOM objects and with some non-standard behaviors.</p>

<p>[2] Also supported in Safari 5, but not on DOM objects.</p>

<h2 id="Compatibiliteitsnotieties">Compatibiliteitsnotieties</h2>

<h3 id="Redefining_the_length_property_of_an_Array_object">Redefining the <code>length</code> property of an <code>Array</code> object</h3>

<p>It is possible to redefine the {{jsxref("Array.length", "length")}} property of arrays, subject to the usual redefinition restrictions. (The {{jsxref("Array.length", "length")}} property is initially non-configurable, non-enumerable, and writable. Thus on an unaltered array it is possible to change the {{jsxref("Array.length", "length")}} property's value, or to make it non-writable. It is not allowed to change its enumerability or configurability, or if it is non-writable to change its value or writability.) However, not all browsers permit this redefinition.</p>

<p>Firefox 4 through 22 will throw a {{jsxref("TypeError")}} on any attempt whatsoever (whether permitted or not) to redefine the {{jsxref("Array.length", "length")}} property of an array.</p>

<p>Versions of Chrome which implement <code>Object.defineProperty()</code> in some circumstances ignore a length value different from the array's current {{jsxref("Array.length", "length")}} property. In some circumstances changing writability seems to silently not work (and not throw an exception). Also, relatedly, some array-mutating methods like {{jsxref("Array.prototype.push")}} don't respect a non-writable length.</p>

<p>Versions of Safari which implement <code>Object.defineProperty()</code> ignore a <code>length</code> value different from the array's current {{jsxref("Array.length", "length")}} property, and attempts to change writability execute without error but do not actually change the property's writability.</p>

<p>Only Internet Explorer 9 and later, and Firefox 23 and later, appear to fully and correctly implement redefinition of the {{jsxref("Array.length", "length")}} property of arrays. For now, don't rely on redefining the {{jsxref("Array.length", "length")}} property of an array to either work, or to work in a particular manner. And even when you <em>can</em> rely on it, <a href="http://whereswalden.com/2013/08/05/new-in-firefox-23-the-length-property-of-an-array-can-be-made-non-writable-but-you-shouldnt-do-it/">there's really no good reason to do so</a>.</p>

<h3 id="Internet_Explorer_8_specific_notes">Internet Explorer 8 specific notes</h3>

<p>Internet Explorer 8 implemented a <code>Object.defineProperty()</code> method that could <a class="external" href="https://msdn.microsoft.com/en-us/library/dd229916%28VS.85%29.aspx">only be used on DOM objects</a>. A few things need to be noted:</p>

<ul>
 <li>Trying to use <code>Object.defineProperty()</code> on native objects throws an error.</li>
 <li>Property attributes must be set to some values. The <code>configurable</code>, <code>enumerable</code> and <code>writable</code> attributes should all be set to <code>true</code> for data descriptor and <code>true</code> for <code>configurable</code>, <code>false</code> for <code>enumerable</code> for accessor descriptor.(?) Any attempt to provide other value(?) will result in an error being thrown.</li>
 <li>Reconfiguring a property requires first deleting the property. If the property isn't deleted, it stays as it was before the reconfiguration attempt.</li>
</ul>

<h2 id="See_also">See also</h2>

<ul>
 <li><a href="/en-US/docs/Enumerability_and_ownership_of_properties">Enumerability and ownership of properties</a></li>
 <li>{{jsxref("Object.defineProperties()")}}</li>
 <li>{{jsxref("Object.propertyIsEnumerable()")}}</li>
 <li>{{jsxref("Object.getOwnPropertyDescriptor()")}}</li>
 <li>{{jsxref("Object.prototype.watch()")}}</li>
 <li>{{jsxref("Object.prototype.unwatch()")}}</li>
 <li>{{jsxref("Operators/get", "get")}}</li>
 <li>{{jsxref("Operators/set", "set")}}</li>
 <li>{{jsxref("Object.create()")}}</li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty/Additional_examples">Additional <code>Object.defineProperty</code> examples</a></li>
 <li>{{jsxref("Reflect.defineProperty()")}}</li>
</ul>