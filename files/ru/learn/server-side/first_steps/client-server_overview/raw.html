<div>{{LearnSidebar}}</div>

<div>{{PreviousMenuNext("Learn/Server-side/First_steps/Introduction", "Learn/Server-side/First_steps/Web_frameworks", "Learn/Server-side/First_steps")}}</div>

<p class="summary">Теперь, когда вы знаете цель и потенциальные преимущества программирования на стороне сервера, мы подробно рассмотрим, что происходит, когда сервер получает «динамический запрос» от браузера. Поскольку большая часть серверного кода веб-сайта обрабатывает запросы и ответы аналогичным образом, это поможет вам понять, что нужно делать при написании большей части собственного кода.</p>

<table class="learn-box standard-table">
 <tbody>
  <tr>
   <th scope="row">Перед стартом:</th>
   <td>Базовая компьютерная грамотность. Базовое понимание того, что такое веб-сервер.</td>
  </tr>
  <tr>
   <th scope="row">Цель:</th>
   <td>Изучить взаимодействие между клиентом и сервером на динамическом веб-сайте и в частности узнать, какие действия нужно произвести в коде серверной части.</td>
  </tr>
 </tbody>
</table>

<p>В обсуждении нет реального кода, поскольку мы еще не выбрали, какой веб-фреймворк мы будем использовать для написания нашего кода! Это обсуждение, тем не менее, очень актуально, поскольку описанное поведение должно быть реализовано вашим серверным кодом независимо от того, какой язык программирования или веб-фреймворк вы выбираете.</p>

<h2 id="Web-серверы_и_HTTP_(для_начинающих)">Web-серверы и HTTP (для начинающих)</h2>

<p>Веб-браузеры взаимодействуют с <a href="https://developer.mozilla.org/ru/docs/Learn/Common_questions/What_is_a_web_server">веб-серверами</a> при помощи протокола передачи гипертекста (HTTP). Когда вы кликаете на ссылку на странице, заполняете форму или запускаете поиск, браузер отправляет на сервер <em>HTTP-запрос</em>.</p>

<p>Этот запрос включает:</p>

<ul>
 <li>Путь, определяющий целевой сервер и ресурс (например, файл, определенная точка данных на сервере, запускаемый сервис, и т.д.).</li>
 <li>Метод, который определяет необходимое действие (например, получить файл, сохранить или обновить некоторые данные). Различные методы/команды и связанные с ними действия перечислены ниже:
  <ul style="list-style-type: circle;">
   <li>
    <p><code>GET</code> – получить определенный ресурс (например, HTML-файл, содержащий информацию о товаре или список товаров).</p>
   </li>
   <li><code>POST</code> – создать новый ресурс (например, новую статью на вики, добавить новый контакт в базу данных).</li>
   <li><code>HEAD</code> – получить метаданные об определенном ресурсе без получения содержания, как делает <code>GET</code>. Вы, например, можете использовать запрос <code>HEAD</code>, чтобы узнать, когда в последний раз ресурс обновлялся и только потом использовать (более «затратный») запрос <code>GET</code>, чтобы загрузить ресурс, который был изменен.</li>
   <li><code>PUT</code> – обновить существующий ресурс (или создать новый, если таковой не существует).</li>
   <li><code>DELETE</code> – удалить указанный ресурс.</li>
   <li><code>TRACE</code>, <code>OPTIONS</code>, <code>CONNECT</code>, <code>PATCH </code>– эти команды используются для менее популярных/продвинутых задач, поэтому мы их не будем рассматривать.</li>
  </ul>
 </li>
 <li>Дополнительная информация может быть закодирована в запросе (например, данные формы). Информация может быть закодирована как:
  <ul style="list-style-type: circle;">
   <li>Параметры URL:  <code>GET</code> запросы зашифровывают данные в  URL-адресе, отправляемом на сервер, добавляя пары имя/значение в его конец, например, http://mysite.com<strong>?name=Fred&amp;age=11</strong>. У вас всегда есть знак вопроса (<code>?</code>), отделяющий остальную часть URL-адреса от параметров URL-адреса, знак равно (=), отделяющий каждое имя от соответствующего ему значения, и амперсанд (&amp;), разделяющий пары. URL-параметры по своей сути «небезопасны», так как они могут быть изменены пользователями и затем отправлены заново. В результате параметры /<code>GET</code> запросы не используются для запросов, которые обновляют данные на сервере.</li>
   <li><code>POST</code> данные. <code>POST</code> запросы добавляют новые ресурсы, данные которых зашифрованы в теле запроса.</li>
   <li>Куки-файлы клиентской части. Куки-файлы содержат данные сессий о клиенте, включая ключевые слова, которые сервер может использовать для определения его авторизационный статус и права доступа к ресурсам.</li>
  </ul>
 </li>
</ul>

<p>Веб-серверы ожидают сообщений с запросами от клиентов, обрабатывают их, когда они приходят и отвечают веб-браузеру через сообщение с HTTP-ответом. Ответ содержит <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Status">Код статуса HTTP-ответа</a>, который показывает, был ли запрос успешным (например, «200 OK» означает успех, «404 Not Found» если ресурс не может быть найден, «403 Forbidden», если пользователь не имеет права просматривать ресурс, и т.д.). Тело успешного ответа на запрос GET будет содержать запрашиваемый ресурс.</p>

<p>После того, как HTML страница была возвращена, она обрабатывается браузером. Далее браузер может исследовать ссылки на другие ресурсы (например, HTML страница обычно использует JavaScript и CSS файлы), и послать отдельный HTTP запрос на загрузку этих файлов.</p>

<p>Как статические, так и динамические веб-сайты (обсуждаемые в следующих разделах) используют точно такой же протокол / шаблоны связи.</p>

<h3 id="Пример_запроса_ответа_GET">Пример запроса / ответа GET</h3>

<p>Вы можете сформировать простой <code>GET</code> запрос кликнув по ссылку или через поиск по сайту (например, страница механизма поиска). Например, HTTP  запрос, посланный во время выполнения запроса "client server overview" на сайте MDN, будет во многом похож на текст ниже (он не будет идентичным, потому что части сообщения зависят от Вашего браузера\настроек.</p>

<div class="note">
<p>Формат HTTP сообщения определен в веб-стандарте(<a href="http://www.rfc-editor.org/rfc/rfc7230.txt">RFC7230</a>).Вам не нужно знать этот уровень детализации, но, по крайней мере, теперь Вы знаете откуда это появилось!</p>
</div>

<h4 id="Запрос">Запрос</h4>

<p>Каждая строка запроса содержит информацию о запросе. Первая часть называется <strong>заголовок</strong>, он содержит важную информацию о запросе, точно так же как <a href="/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML">HTML head</a> содержит важную информацию о HTML документе (но не содержимое документа, которое расположено в body):</p>

<pre>GET https://developer.mozilla.org/en-US/search?q=client+server+overview&amp;topic=apps&amp;topic=html&amp;topic=css&amp;topic=js&amp;topic=api&amp;topic=webdev HTTP/1.1
Host: developer.mozilla.org
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: https://developer.mozilla.org/en-US/
Accept-Encoding: gzip, deflate, sdch, br
Accept-Language: en-US,en;q=0.8,es;q=0.6
Cookie: sessionid=6ynxs23n521lu21b1t136rhbv7ezngie; csrftoken=zIPUJsAZv6pcgCBJSCj1zU6pQZbfMUAT; dwf_section_edit=False; dwf_sg_task_completion=False; _gat=1; _ga=GA1.2.1688886003.1471911953; ffo=true
</pre>

<p>Первая и вторая строки содержат большую часть информации, о которой говорилось выше:</p>

<ul>
 <li>Тип запроса (<code>GET</code>).</li>
 <li>URL целевого ресурса (<code>/en-US/search</code>).</li>
 <li>Параметры URL (<code>q=client%2Bserver%2Boverview&amp;topic=apps&amp;topic=html&amp;topic=css&amp;topic=js&amp;topic=api&amp;topic=webdev</code>).</li>
 <li>Целевой вебсайт (developer.mozilla.org).</li>
 <li>Конец первой строки так же содержит короткую строку, идентифицирующую версию протокола (<code>HTTP/1.1</code>).</li>
</ul>

<p>Последняя строка содержит информацию о клиентских куки - в данном случае можно увидеть куки, включающие id для управления сессиями (<code>Cookie: sessionid=6ynxs23n521lu21b1t136rhbv7ezngie; ...</code>).</p>

<p>Оставшиеся строки содержат информацию о используемом браузере и о его некоторых поддерживаемых возможностях Например, здесь Вы можете увидеть:</p>

<ul>
 <li>Мой браузер (<code>User-Agent</code>) Mozilla Firefox (<code>Mozilla/5.0</code>).</li>
 <li>Он может принимать информацию упакованную gzip (<code>Accept-Encoding: gzip</code>).</li>
 <li>Он может принимать указанные кодировки  (<code>Accept-Charset: ISO-8859-1,UTF-8;q=0.7,*;q=0.7</code>) и языков (<code>Accept-Language: de,en;q=0.7,en-us;q=0.3</code>).</li>
 <li>Строка <code>Referer</code> идентифицирует адрес веб страницы, содержащей ссылку на этот ресурс (т.е. источник оригинального запроса, <code>https://developer.mozilla.org/en-US/</code>).</li>
</ul>

<p>HTTP запрос так же может содержать body, но в данном случае оно пусто.</p>

<h4 id="Ответ">Ответ</h4>

<p>Первая часть ответа на запрос показана ниже. Заголовок содержит информацию, описанную ниже:</p>

<ul>
 <li>Первая строка содержит код ответа <code>200 OK</code>, говорящий о том, что запрос выполнен успешно.</li>
 <li>Мы можем видеть, что ответ имеет <code>text/html</code> формат(<code>Content-Type</code>).</li>
 <li>Так же мы видим, что ответ использует кодировку UTF-8 (<code>Content-Type: text/html; charset=utf-8</code>).</li>
 <li>Заголовок так же содержит размер ответа (<code>Content-Length: 41823</code>).</li>
</ul>

<p>В конце сообщения мы видим содержимое <strong>body, </strong>содержащее HTML код возвращаемого ответа.</p>

<pre class="brush: html">HTTP/1.1 200 OK
Server: Apache
X-Backend-Server: developer1.webapp.scl3.mozilla.com
Vary: Accept,Cookie, Accept-Encoding
Content-Type: text/html; charset=utf-8
Date: Wed, 07 Sep 2016 00:11:31 GMT
Keep-Alive: timeout=5, max=999
Connection: Keep-Alive
X-Frame-Options: DENY
Allow: GET
X-Cache-Info: caching
Content-Length: 41823



&lt;!DOCTYPE html&gt;
&lt;html lang="en-US" dir="ltr" class="redesign no-js"  data-ffo-opensanslight=false data-ffo-opensans=false &gt;
&lt;head prefix="og: http://ogp.me/ns#"&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt;
  &lt;script&gt;(function(d) { d.className = d.className.replace(/\bno-js/, ''); })(document.documentElement);&lt;/script&gt;
  ...
</pre>

<p>Остальная часть заголовка ответа содержит информацию об ответе (например, когда он был сгенерирован), сервере и о том, как он ожидает, что браузер обрабатывает страницу (например, строка X-Frame-Options: DENY говорит браузеру не допускать внедрения этой страницы, если она будет внедрена в {{htmlelement ("iframe")}} на другом сайте).</p>

<h3 id="Пример_запроса_ответа_POST">Пример запроса / ответа POST</h3>

<p>HTTP <code>POST</code> создается, когда вы отправляете форму, содержащую информацию, которая должна быть сохранена на сервере.</p>

<h4 id="Запрос_2">Запрос</h4>

<p>В приведенном ниже тексте показан HTTP-запрос, сделанный, когда пользователь представляет новые данные профиля на этом сайте. Формат запроса почти такой же, как пример запроса <code>GET</code> , показанный ранее, хотя первая строка идентифицирует этот запрос как <code>POST</code> .</p>

<pre class="brush: html">POST https://developer.mozilla.org/en-US/profiles/hamishwillee/edit HTTP/1.1
Host: developer.mozilla.org
Connection: keep-alive
Content-Length: 432
Pragma: no-cache
Cache-Control: no-cache
Origin: https://developer.mozilla.org
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.116 Safari/537.36
Content-Type: application/x-www-form-urlencoded
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Referer: https://developer.mozilla.org/en-US/profiles/hamishwillee/edit
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.8,es;q=0.6
Cookie: sessionid=6ynxs23n521lu21b1t136rhbv7ezngie; _gat=1; csrftoken=zIPUJsAZv6pcgCBJSCj1zU6pQZbfMUAT; dwf_section_edit=False; dwf_sg_task_completion=False; _ga=GA1.2.1688886003.1471911953; ffo=true

csrfmiddlewaretoken=zIPUJsAZv6pcgCBJSCj1zU6pQZbfMUAT&amp;user-username=hamishwillee&amp;user-fullname=Hamish+Willee&amp;user-title=&amp;user-organization=&amp;user-location=Australia&amp;user-locale=en-US&amp;user-timezone=Australia%2FMelbourne&amp;user-irc_nickname=&amp;user-interests=&amp;user-expertise=&amp;user-twitter_url=&amp;user-stackoverflow_url=&amp;user-linkedin_url=&amp;user-mozillians_url=&amp;user-facebook_url=</pre>

<p>Основное различие заключается в том, что URL-адрес не имеет параметров. Как вы можете видеть, информация из формы закодирована в теле запроса (например, новое полное имя пользователя устанавливается с использованием: <code>&amp;user-fullname=Hamish+Willee</code>).</p>

<h4 id="Ответ_2">Ответ</h4>

<p>Ответ от запроса показан ниже. Код состояния « <code>302 Found</code> » сообщает браузеру, что сообщение удалось, и что он должен выдать второй HTTP-запрос для загрузки страницы, указанной в поле «Место». В противном случае информация аналогична информации для ответа на запрос <code>GET</code> .</p>

<pre class="brush: html">HTTP/1.1 302 FOUND
Server: Apache
X-Backend-Server: developer3.webapp.scl3.mozilla.com
Vary: Cookie
Vary: Accept-Encoding
Content-Type: text/html; charset=utf-8
Date: Wed, 07 Sep 2016 00:38:13 GMT
Location: https://developer.mozilla.org/en-US/profiles/hamishwillee
Keep-Alive: timeout=5, max=1000
Connection: Keep-Alive
X-Frame-Options: DENY
X-Cache-Info: not cacheable; request wasn't a GET or HEAD
Content-Length: 0
</pre>

<div class="note">
<p><strong>Note</strong>: HTTP-ответы и запросы, показанные в этих примерах, были захвачены с использованием приложения <a href="https://www.telerik.com/download/fiddler">Fiddler</a>, но вы можете получить аналогичную информацию с помощью веб-снифферов (например, <a href="http://web-sniffer.net/">http://web-sniffer.net/</a> ) или с помощью расширений браузера, таких как HttpFox. Вы можете попробовать это сами. Используйте любой из связанных инструментов, а затем перейдите по сайту и отредактируйте информацию профиля, чтобы увидеть различные запросы и ответы. В большинстве современных браузеров также есть инструменты, которые отслеживают сетевые запросы (например, инструмент <a href="https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor">Network Monitor</a> в Firefox).</p>
</div>

<h2 id="Статические_сайты">Статические сайты</h2>

<p><em>Статический сайт</em> - это тот, который возвращает тот же жесткий кодированный контент с сервера всякий раз, когда запрашивается конкретный ресурс. Например, если у вас есть страница о продукте в <code>/static/myproduct1.html</code> , эта же страница будет возвращена каждому пользователю. Если вы добавите еще один подобный продукт на свой сайт, вам нужно будет добавить еще одну страницу (например, <code>myproduct2.html</code> ) и так далее. Это может стать действительно неэффективным - что происходит, когда вы попадаете на тысячи страниц продукта? Вы повторяли бы много кода на каждой странице (основной шаблон страницы, структуру и т. Д.), И если бы вы хотели изменить что-либо о структуре страницы - например, добавить новый раздел «связанные продукты» - тогда вы приходится менять каждую страницу отдельно.</p>

<div class="note">
<p><strong>Note</strong>: Статические сайты превосходны, когда у вас небольшое количество страниц, и вы хотите отправить один и тот же контент каждому пользователю. Однако они могут иметь значительную стоимость для поддержания, поскольку количество страниц становится больше.</p>
</div>

<p>Давайте вспомним, как это работает, снова взглянув на диаграмму архитектуры статического сайта, на которую мы смотрели в последней статье.</p>

<p><img alt="A simplified diagram of a static web server." src="https://mdn.mozillademos.org/files/13841/Basic%20Static%20App%20Server.png"></p>

<p>Когда пользователь хочет перейти на страницу, браузер отправляет HTTP-запрос <code>GET</code> с указанием URL-адреса его страницы HTML. Сервер извлекает запрошенный документ из своей файловой системы и возвращает ответ HTTP, содержащий документ, и код состояния <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status">HTTP Response status code</a> of "<code>200 OK</code> » (успех). Сервер может вернуть другой код состояния, например « <code>404 Not Found</code>», если файл отсутствует на сервере или « <code>301 Moved Permanently</code>», если файл существует, но был перенаправлен в другое место.</p>

<p>Серверу для статического сайта будет только нужно обрабатывать запросы GET, потому что сервер не сохраняет никаких модифицируемых данных. Он также не изменяет свои ответы на основе данных HTTP-запроса (например, параметров URL-адреса или файлов cookie).</p>

<p>Понимание того, как работают статические сайты, тем не менее полезно при изучении программирования на стороне сервера, поскольку динамические сайты обрабатывают запросы на статические файлы (CSS, JavaScript, статические изображения и т. д.) Точно так же.</p>

<h2 id="Динамические_сайты">Динамические сайты</h2>

<p><em>Динамический сайт</em> - это тот, который может генерировать и возвращать контент на основе конкретного URL-адреса запроса и данных (а не всегда возвращать один и тот же жесткий код для определенного URL-адреса). Используя пример сайта продукта, сервер будет хранить «данные» продукта в базе данных, а не отдельные файлы HTML. При получении запроса HTTP <code>GET</code> для продукта сервер определяет идентификатор продукта, извлекает данные из базы данных и затем создает HTML-страницу для ответа, вставляя данные в шаблон HTML. Это имеет большие преимущества перед статическим сайтом:</p>

<p>Использование базы данных позволяет эффективно хранить информацию о продукте с помощью легко расширяемого, изменяемого и доступного для поиска способа.</p>

<p>Использование HTML-шаблонов позволяет очень легко изменить структуру HTML, потому что это нужно делать только в одном месте, в одном шаблоне, а не через потенциально тысячи статических страниц.</p>

<h3 id="Анатомия_динамического_запроса">Анатомия динамического запроса</h3>

<p>В этом разделе представлен пошаговый обзор «динамического» цикла HTTP-запроса и ответа, основываясь на том, что мы рассмотрели в последней статье, с гораздо более подробной информацией. Чтобы «сохранить реальность», мы будем использовать контекст веб-сайта менеджера спортивной команды, где тренер может выбрать имя своей команды и размер команды в форме HTML и вернуться к предлагаемому «лучшему составу» для своей следующей игры.</p>

<p>На приведенной ниже диаграмме показаны основные элементы веб-сайта «team coach», а также пронумерованные ярлыки для последовательности операций, когда тренер обращается к списку «лучших команд». Части сайта, которые делают его динамичным, являются <em>веб-приложением</em> (так мы будем ссылаться на серверный код, обрабатывающий HTTP-запросы и возвращающие ответы HTTP), базу данных, которая содержит информацию об игроках, командах, тренерах и их отношения и HTML-<em>шаблоны</em>.</p>

<p><img alt="This is a diagram of a simple web server with step numbers for each of step of the client-server interaction." src="https://mdn.mozillademos.org/files/13829/Web%20Application%20with%20HTML%20and%20Steps.png" style="height: 584px; width: 1226px;"></p>

<p>После того, как тренер отправит форму с именем команды и количеством игроков, последовательность операций:</p>

<ol>
 <li>Веб-браузер создает HTTP-запрос <code>GET</code> на сервер с использованием базового URL-адреса ресурса (<code>/best</code>) и кодирования номера команды и игрока как параметров URL (например,<code> /best?team=my_team_name&amp;show=11)</code> или как часть URL-адреса (например, <code>/best/my_team_name/11/</code>). Запрос <code>GET</code>используется, потому что запрос - только выборка данных (не изменение данных).</li>
 <li><em>Веб-сервер</em> обнаруживает, что запрос является «динамическим» и пересылает его в <em>веб-приложение</em> для обработки (веб-сервер определяет, как обрабатывать разные URL-адреса на основе правил сопоставления шаблонов, определенных в его конфигурации).</li>
 <li><em>Веб-приложение</em> определяет, что цель запроса состоит в том, чтобы <em>получить</em> «лучший список команд» на основе URL (<code>/best/</code>) и узнать имя команды и количество игроков из URL-адреса. Затем веб-приложение получает требуемую информацию из базы данных (используя дополнительные «внутренние» параметры, чтобы определить, какие игроки являются «лучшими», и, возможно, также получить личность зарегистрированного тренера из файла cookie на стороне клиента).</li>
 <li>Веб-приложение динамически создает HTML-страницу, помещая данные (из базы данных) в заполнители внутри HTML-шаблона.</li>
 <li><em>Веб-приложение</em> возвращает сгенерированный HTML в веб-браузер (через <em>веб-сервер</em>) вместе с кодом состояния HTTP 200 («успех»). Если что-либо препятствует возврату HTML, <em>веб-приложение</em> вернет другой код - например, «404», чтобы указать, что команда не существует.</li>
 <li>Затем веб-браузер начнет обрабатывать возвращенный HTML, отправив отдельные запросы, чтобы получить любые другие файлы CSS или JavaScript, на которые он ссылается (см. шаг 7).</li>
 <li>Веб-сервер загружает статические файлы из файловой системы и возвращает их непосредственно в браузер (опять же, правильная обработка файлов основана на правилах конфигурации и сопоставлении шаблонов URL).</li>
</ol>

<p>Операция по обновлению записи в базе данных будет обрабатываться аналогичным образом, за исключением того, что, как и любое обновление базы данных, HTTP-запрос из браузера должен быть закодирован как запрос <font face="consolas, Liberation Mono, courier, monospace"><span style="background-color: rgba(220, 220, 220, 0.5);">POST</span></font>.</p>

<h3 id="Выполнение_другой_работы">Выполнение другой работы</h3>

<p>Задача <em>веб-приложения</em> - получать HTTP-запросы и возвращать ответы HTTP. Хотя взаимодействие с базой данных для получения или обновления информации является очень распространенными задачами, код может делать другие вещи одновременно или вообще не взаимодействовать с базой данных.</p>

<p>Хорошим примером дополнительной задачи, которую может выполнять <em>веб-приложение</em>, является отправка электронной почты пользователям для подтверждения их регистрации на сайте. Сайт также может выполнять протоколирование или другие операции.</p>

<h3 id="Возвращение_чего-то_другого_кроме_HTML">Возвращение чего-то другого, кроме HTML</h3>

<p>Серверный код сайта может возвращать не только HTML-фрагменты / файлы в ответе. Он может динамически создавать и возвращать другие типы файлов (текст, PDF, CSV и т. Д.) Или даже данные (JSON, XML и т. Д.).</p>

<p>Идея вернуть данные в веб-браузер, чтобы он мог динамически обновлять свой собственный контент ({{glossary("AJAX")}}) существует довольно давно. Совсем недавно «Одностраничные приложения» стали популярными, где весь сайт написан с одним HTML-файлом, который динамически обновляется по мере необходимости. Веб-сайты, созданные с использованием этого стиля приложения, выталкивают множество вычислительных затрат с сервера на веб-браузер и могут привести к тому, что веб-сайты, ведут себя больше как нативные приложения (очень отзывчивые и т. д.).</p>

<h2 id="Веб-структуры_упрощают_веб-программирование_на_стороне_сервера">Веб-структуры упрощают веб-программирование на стороне сервера</h2>

<p>Веб-фреймворки на стороне сервера делают код записи для обработки описанных выше операций намного проще.</p>

<p>Одной из наиболее важных операций, которые они выполняют, является предоставление простых механизмов для сопоставления URL-адресов для разных ресурсов / страниц с конкретными функциями обработчика. Это упрощает сохранение отдельного кода, связанного с каждым типом ресурса. Он также имеет преимущества в плане обслуживания, поскольку вы можете изменить URL-адрес, используемый для доставки определенной функции в одном месте, без необходимости изменять функцию обработчика.</p>

<p>Например, рассмотрим следующий код Django (Python), который отображает два шаблона URL для двух функций просмотра. Первый шаблон гарантирует, что HTTP-запрос с URL-адресом ресурса <code>/best</code>будет передан функции с именем <code>index()</code>в модуле views. Запрос, который имеет шаблон «<code>/best/junior</code>», вместо этого будет передан функции просмотра <code>junior()</code>.</p>

<pre class="brush: python"># file: best/urls.py
#

from django.conf.urls import url

from . import views

urlpatterns = [
    # example: /best/
    url(r'^$', views.index),
    # example: /best/junior/
    url(r'^junior/$', views.junior),
]</pre>

<div class="note">
<p><strong>Note</strong>: Первые параметры в функциях <code>url()</code> могут выглядеть немного необычно (например, <code>r'^junior/$'</code>потому что они используют метод сопоставления шаблонов под названием «регулярные выражения» (RegEx или RE). Вам не нужно знать, как работают регулярные выражения на этом этапе, кроме того, что они позволяют нам сопоставлять шаблоны в URL-адресе (а не жестко закодированные значения выше) и использовать их в качестве параметров в наших функциях просмотра. В качестве примера, действительно простой RegEx может говорить «соответствовать одной заглавной букве, за которой следуют от 4 до 7 строчных букв».</p>
</div>

<p>Веб-инфраструктура также упрощает функцию получения информации из базы данных. Структура наших данных определяется в моделях, которые являются классами Python, которые определяют поля, которые должны храниться в базовой базе данных. Если у нас есть модель с именем Team с полем «<em>team_type</em>», мы можем использовать простой синтаксис запроса, чтобы вернуть все команды, имеющие определенный тип.</p>

<p>В приведенном ниже примере представлен список всех команд, у которых есть точный (с учетом регистра) <code>team_type</code>«junior» - обратите внимание на формат: имя поля (<code>team_type</code>), за которым следует двойной знак подчеркивания, а затем тип соответствия для использования (в этом случае точное ). Существует много других типов совпадений, и мы можем объединить их. Мы также можем контролировать порядок и количество возвращаемых результатов.</p>

<pre class="brush: python">#best/views.py

from django.shortcuts import render

from .models import Team 


def junior(request):
    list_teams = Team.objects.filter(team_type__exact="junior")
    context = {'list': list_teams}
    return render(request, 'best/index.html', context)
</pre>

<p>После того, как функция <code>junior()</code>получает список младших команд, она вызывает функцию <code>junior()</code> , передавая исходный <code>HttpRequest</code>, HTML-шаблон и объект «context», определяющий информацию, которая должна быть включена в шаблон. Функция render () - это функция удобства, которая генерирует HTML с использованием контекста и HTML-шаблона и возвращает его в объект <code>HttpResponse</code>.</p>

<p>Очевидно, что веб-фреймворки могут помочь вам в решении многих других задач. В следующей статье мы обсудим намного больше преимуществ и некоторые популярные варианты веб-фреймворков.</p>

<h2 id="Резюме">Резюме</h2>

<p>На этом этапе вы должны хорошо ознакомиться с операциями, которые должен выполнять серверный код, и знать некоторые способы, с помощью которых веб-среда на стороне сервера может сделать это проще.</p>

<p>В следующем модуле мы поможем вам выбрать лучшую веб-платформу для вашего первого сайта.</p>

<p>{{PreviousMenuNext ("Learn/Server-side/First_steps/Introduction", "Learn/Server-side/First_steps/Web_frameworks", "Learn/Server-side/First_steps")}}</p>

<div class="TnITTtw-tooltip-main-wrap TnITTtw-tooltip-90 TnITTtw-t" id="TnITTtw-tooltip-wrap" style="max-width: 450px; left: 179px; top: 11966.7px;">
<div class="TnITTtw-t TnITTtw-arr0w TnITTtw-top-arr0w"></div>

<div class="TnITTtw-t TnITTtw-inside-layout">
<div class="TnITTtw-t TnITTtw-content">
<div class="TnITTtw-t TnITTtw-help-selected-wrap TnITTtw-hsw-90 TnITTtw-has-bottom-arr0w">
<div class="TnITTtw-t TnITTtw-help-inside-layout TnITTtw-hil-90">
<div class="TnITTtw-unpinned-utils TnITTtw-t">
<div class="TnITTtw-pro-img TnITTtw-t"></div>

<div class="TnITTtw-close-unpinned TnITTtw-t"></div>
</div>

<div class="TnITTtw-utils TnITTtw-t">
<div class="TnITTtw-util-butt0n TnITTtw-listen-original TnITTtw-t" title=""></div>

<div class="TnITTtw-util-butt0n TnITTtw-unpin TnITTtw-t" title=""></div>

<div class="TnITTtw-show-reversed TnITTtw-t" title="">
<div class="TnITTtw-swap-arrow TnITTtw-t"></div>
</div>
</div>

<div class="TnITTtw-trVisibleLayout TnITTtw-t" id="TnITTtw-trVisibleLayout-90">
<div class="TnITTtw-trEntireLayout TnITTtw-t" id="TnITTtw-trEntireLayout-90">
<div class="TnITTtw-t TnITTtw-content-layout TnITTtw-content-layout-90"></div>
</div>
</div>

<div class="TnITTtw-tr-scrollbar TnITTtw-t" id="TnITTtw-tr-scrollbar-90">
<div class="TnITTtw-track TnITTtw-t" id="TnITTtw-track-90">
<div class="TnITTtw-dragBar TnITTtw-t" id="TnITTtw-dragBar-90"></div>
</div>
</div>
</div>

<div class="TnITTtw-translate-human TnITTtw-t">Перевести с помощью профессионала</div>

<div class="TnITTtw-info-warn TnITTtw-iw-90 TnITTtw-hide TnITTtw-t"><a class="TnITTtw-t" title="Существует локализованная версия этого веб-сайта">Проверьте локализованную версию сайта</a>

<div class="TnITTtw-close-info-warn TnITTtw-t"></div>
</div>

<div class="TnITTtw-loading TnITTtw-t" style="display: block;">
<div class="TnITTtw-mate-loading TnITTtw-t"></div>
</div>

<div class="TnITTtw-offline TnITTtw-t"><span class="TnITTtw-t">Нет подключения к сети Интернет</span></div>
</div>
</div>
</div>

<div class="TnITTtw-t TnITTtw-arr0w TnITTtw-bottom-arr0w" style="margin-left: 159px; display: block;"></div>
</div>