<div>{{HTTPSidebar}}</div>

<p><strong>Производительность веб-сайтов и приложений можно значительно повысить за счет повторного использования ранее собранных ресурсов. Кеши веб сокращают задержку и снижают сетевой траффик, уменьшая тем самым время, необходимое для отображения ресурсов. Используя HTTP-кеширование, сайты становятся более отзывчивыми.</strong></p>

<p><br>
 <br>
  </p>

<h2 id="Различные_виды_кэширования">Различные виды кэширования</h2>

<p>Кеширование - этот метод, заключающийся в сохранении копии полученного ресурса, чтобы вернуть ее по запросу. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается производительность - кеш ближе к клиенту, и ресурс передается быстрее. Кеширование является  основным источником повышения производительности веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными, так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.</p>

<p>Существует несколько видов кешей, которые можно разделить на две основные категории: приватные кеши и кеши совместного использования. В кешах совместного использования (shared cache) хранятся копии, которые могут направляться разным пользователями. Приватный кеш (private cache) предназначен для отдельного пользователя. Здесь будет говориться в основном о кешах браузеров и прокси, но существуют также кеши шлюзов, CDN, реверсные прокси кеши и балансировщики нагрузки, разворачиваемые на серверах для повышения надежности, производительности и масштабируемости веб-сайтов и веб-приложений.</p>

<p><br>
 <br>
  </p>

<p><img alt="What a cache provide, advantages/disadvantages of shared/private caches." src="https://mdn.mozillademos.org/files/13777/HTTPCachtType.png" style="height: 573px; width: 910px;"></p>

<h3 id="Приватный_(private)_кэш_браузера">Приватный (private) кэш браузера</h3>

<p>Приватный кеш предназначен для отдельного пользователя. Вы, возможно, уже видели параметры "кеширования" в настройках своего браузера. Кеш браузера содержит все документы, загруженные пользователем через HTTP. Он используется, чтобы можно было пролистывать назад/вперед загруженные ранее страницы, сохранять или использовать их в качестве ресурса, не обращаясь лишний раз к серверу. Кроме того, кеш полезен при отключении от сети.</p>

<h3 id="Общий_(shared)_прокси-кэш">Общий (shared) прокси-кэш</h3>

<p>Кеш совместного использования - это кеш, который сохраняет отклики, чтобы их потом могли использовать разные пользователи. Прокси, обслуживающий множество пользователей, может установить, например, ваш провайдер или компания в своей  локальной сети,  чтобы можно было повторно использовать популярные ресурсы, сокращая тем самым сетевой траффик и время ожидания.</p>

<h2 id="Цели_кэширования">Цели кэширования</h2>

<p>Кеширование в HTTP не является обязательным, однако в большинстве случаев бывает полезно повторно использовать ранее сохраненных ресурсов. Тем не менее, стандартные кеши HTTP обычно способны кешировать только отклики метода {{HTTPMethod("GET")}}, а другие отклоняют.</p>

<p>Первичный ключ состоит из метода запроса и запрашивемого URI (зачастую используется только URI, поскольку целью кеширования являются только запросы метода GET ). Вот примеры того, что обычно записывается в кеш:</p>

<ul>
 <li>Сообщение об успехе запроса: отклик {{HTTPStatus(200)}} (OK) на запрос методом {{HTTPMethod("GET")}} HTML-документов, изображений или файлов.</li>
 <li>Постоянная переадресация: отклик {{HTTPStatus (301)}} (Moved Permanently - Перемещен).</li>
 <li>Сообщение об ошибке: страница {{HTTPStatus(404)}} (Not Found - Не найдено).</li>
 <li>Сообщение, что результат не полон: отклик {{HTTPStatus(206)}} (Partial Content - Часть содержимого).</li>
 <li>
  <p>Отклики методов, отличных от {{HTTPMethod("GET")}}, если есть что-либо, подходящее для использования в качестве ключа кеша.</p>
 </li>
</ul>

<p>Запись в кеше может также состоять из множества откликов, различаемых по вторичному ключу, если целью запроса является согласование данных. Подробнее об этом рассказано <a href="#Varying_responses">ниже</a>, в разделе, посвященному заголовку {{HTTPHeader("Vary")}}.</p>

<h2 id="Управление_кэшированием"><span class="long_text short_text" id="result_box" lang="ru"><span>Управление</span> <span>кэшированием</span></span></h2>

<h3 id="Заголовок_Cache-control">Заголовок <code>Cache-control</code></h3>

<p>Поле {{HTTPHeader("Cache-Control")}} общего заголовка HTTP/1.1 используется для задания инструкций по механизму кеширования как в запросах, так и в ответах. Применяется для задания политик кеширования.</p>

<h4 id="Полное_отсутствие_кеширования">Полное отсутствие кеширования</h4>

<p>В кеше не должно сохраняться ничего - ни по запросам клиента, ни по откликам сервера. Запрос всегда отправляется на сервер, ответ всегда загружается полностью.</p>

<pre>Cache-Control: no-store
Cache-Control: no-cache, no-store, must-revalidate
</pre>

<h4 id="Не_кешировать">Не кешировать</h4>

<p>Перед тем, как выдать копию, кеш запрашивает исходный сервер на предмет актуальности ресурса.</p>

<pre>Cache-Control: no-cache</pre>

<h4 id="Приватные_(private)_и_общие_(public)_кеши">Приватные (private) и общие (public) кеши</h4>

<p>Директива "public" указывает, что ответ можно сохранять в любом кеше. Это бывает полезно, если возникает потребность сохранить страницы с аутентификационной информацией HTTP или кодами статуса, которые обычно не кешируются. Директива же "private" указывает, что ответ предназначен отдельному пользователю и не должен, таким образом, храниться в кеше совместного использования. В этом случае ответ может  сохраняться приватным кешем браузера.</p>

<pre>Cache-Control: private
Cache-Control: public
</pre>

<h4 id="Срок_действия_(Expiration)">Срок действия (Expiration)</h4>

<p>Самой важной является директива "max-age=&lt;seconds&gt;" - максимальное время, в течение которого ресурс  считается "свежим". В отличие от директивы {{HTTPHeader("Expires")}}, она привязана к моменту запроса. Для тех файлов, которые не должны меняться, можно использовать "агрессивное" кеширование. Сюда входят статичные файлы, такие как изображения, файлы стилей (CSS) или скриптов (JavaScript).</p>

<p>Подробнее об этом рассказывается в разделе <a href="#Freshness">Свежесть ресурса</a>.</p>

<pre>Cache-Control: max-age=31536000</pre>

<h4 id="Проверка_актуальности">Проверка актуальности</h4>

<p>При использовании инструкции "must-revalidate" кеш обязан проверять статус ресурса с истекшим сроком действия. Те копии, что утратили актуальность, использоваться не должны. Подробнее об этом рассказано ниже, в соответствующем разделе</p>

<pre>Cache-Control: must-revalidate</pre>

<h3 id="Заголовок_Pragma">Заголовок <code>Pragma </code></h3>

<p>{{HTTPHeader("Pragma")}} является заголовком HTTP/1.0. Он не задан для ответов HTTP,  таким образом, не может служить надежной заменой заголовку "Cache-Control: no-cache" протокола HTTP/1.1 Cache-Control, хотя и ведет себя аналогичным образом когда поле заголовка Cache-Control опущено в запросе. Использовать его следует только для совместимости с клиентами HTTP/1.0.</p>

<h2 id="Свежесть_сохраненной_копии">Свежесть сохраненной копии</h2>

<p>Однажды попав в кеш, ресурс, теоретически, может храниться там вечно. Однако, поскольку объем хранилища конечен, записи периодически приходится оттуда удалять.  Этот процесс называют вытеснением данных из кеша (cache eviction). Кроме того, на сервере ресурсы могут изменяться, поэтому кеш требуется обновлять. Поскольку HTTP является клиент-серверным протоколом, сервера не могут сами обращаться к кешам и клиентам при изменении ресурса; им необходимо договориться о сроке действия  сохраненной копии. До его истечения ресурс считается свежим (fresh), после - устаревшим (stale). Алгоритмы вытеснения отдают предпочтение "свежим" ресурсам. Тем не менее, копия ресурса не удаляется из кеша сразу же по истечению ее срока действия. При получении запроса на соответствующий ресурс кеш предваряет его с заголовком {{HTTPHeader("If-None-Match")}} на случай, если его копия все еще актуальна. Если это так, сервер возвращает заголовок {{HTTPStatus("304")}} (Not Modified - Не изменен), а тело ресурса не посылает, экономя тем самым траффик.</p>

<p>Вот пример того, как протекает этот процесс при использовании совместного кеша прокси:</p>

<p><br>
 <br>
  </p>

<p><img alt="Show how a proxy cache acts when a doc is not cache, in the cache and fresh, in the cache and stale." src="https://mdn.mozillademos.org/files/13771/HTTPStaleness.png" style="height: 910px; width: 822px;"></p>

<p>Время устаревания (freshnessLifetime) вычисляется на основании нескольких заголовков. Если задан заголовок "Cache-control: max-age=N", то время устаревания равно N. Если его нет, а это бывает очень часто, проверяется заголовок {{HTTPHeader("Expires")}}, и, если он есть, то время устаревания берется равным значению заголовка Expires минус значение заголовка Date. Наконец, если нет ни того ни другого, смотрят заголовок Last-Modified.  Если он есть, то время устаревания равно значению заголовка Date минус значение заголовка Last-modified разделить на 10.<br>
 Срок действия вычисляется следующим образом:</p>

<pre>expirationTime (срок действия) = responseTime + freshnessLifetime - currentAge (текущий возраст)
</pre>

<p>где responseTime - это время получения ответа по часам браузера.</p>

<h3 id="Обновление_статичных_ресурсов_(Revved_resources)">Обновление статичных ресурсов (Revved resources)</h3>

<p>Чем больше ресурсов кешируется, тем быстрее сайт реагирует на запросы и тем выше его производительность. Из этих соображений их "срок годности" имеет смысл делать как можно большим. Однако, возникает проблема с ресурсами, которые обновляются редко и нерегулярно. Их выгоднее всего кешировать, но трудно обновлять. Такие ресурсы можно найти в любой веб-странице:  файлы скриптов (JavaScript) и стилей (CSS) изменяются редко, но уж если это произошло, обновление надо произвести как можно быстрее.</p>

<p>Веб разработчики разработали метод, который Стив Сандерс (Steve Sounders) назвал оборачиваемостью (<em>revving</em><sup><a href="https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/">[1]</a></sup>).</p>

<p>Для редко обновляемых файлов используют особый способ именования: в их URL, обычно в имя файла, добавляют номер релиза или версии. Таким образом, каждый новый релиз считается отдельным отдельным ресурсом, срок устаревания которого отодвинут далеко в будущее, как правило, на год или больше. Недостатком этого метода является то, что для получения новых версий ресурса приходится обновлять все ссылки на него - это некоторое усложнение, справиться с которым разработчику помогает цепочка инструментов. Обновление статичных ресурсов влечет за собой обновление часто изменяемых ресурсов. Когда считываются те, считываются и новые версии этих.</p>

<p>Этот метод имеет дополнительное достоинство: одновременное обновление двух кешированных ресурсов не приводт к ситуации, при которой устаревшая версия одного ресурса используется вместе новой версией другого. Это очень важно для сайтов с взаимосвязанными файлами стилей CSS или JS-скриптов - связь может возникнуть, например, из-за ссылок на одни и те же элементы HTML-страницы.</p>

<p><br>
 <br>
  </p>

<p><img alt="" src="https://mdn.mozillademos.org/files/13779/HTTPRevved.png"></p>

<p>Номер версии, добавляемый к статическому ресурсу, не обязательно записывать в виде стандартного номера версии наподобие 1.1.3, или даже в порядке возрастания. Это может быть что угодно, позволяющее избежеть совпадений - например, дата.</p>

<h2 id="Валидация_кеша">Валидация кеша</h2>

<p>Валидация кеша запускается при нажатии пользователем кнопки перезагрузки. Кроме того, она может выполняться в ходе обычного режима просмотра, если кешированный ответ включает заголовок "Cache-control: must-revalidate". Другим фактором являются настройки кеширования (окно  Advanced-&gt;Cache preferences) - можно потребовать принудительной валидации при каждой загрузке документа.</p>

<p>При истечении срока годности документа он либо проходит валидацию, либо повторно доставляется с сервера. Валидация может выполняться только если у сервера есть <em>сильный валидатор </em>или <em>слабый валидатор</em>.</p>

<p><br>
 <br>
  </p>

<h3 id="Заголовки_ETag">Заголовки ETag</h3>

<p><br>
 <br>
  </p>

<p>Заголовок ответа {{HTTPHeader("ETag")}} является непрозрачным для агента пользователя значением, которое можно использовать в качестве сильного валидатора. Агент пользователя, например, браузер, не знает, что представляет эта строка и не может предсказать, каким будет ее значение. Если заголовок ETag был частью ответа, клиент может вывести If-None-Match в заголовок будущих запросов для валидации кешированных ресурсов.</p>

<p>Заголовок ответа {{HTTPHeader("Last-Modified")}} можно использовать в качестве слабого валидатора. Слабым он считается из-за того, что имеет 1-секундное разрешение. Если в ответе присутствует заголовок Last-Modified, то для валидации кешированного документа клиент может выводить в запросах заголовок  {{HTTPHeader("If-Modified-Since")}}.</p>

<p>При запросе на валидацию сервер может либо проигнорировать его и послать стандартный ответ {{HTTPStatus(200)}} OK, либо вернуть ответ {{HTTPStatus(304)}} Not Modified (с пустым телом), указывая, таким образом, чтобы браузер взял копию из кеша. В последнем случае в ответ могут входить также заголовки для обновления срока действия кешированного ресурса.</p>

<h2 id="Изменяющиеся_ответы">Изменяющиеся ответы</h2>

<p>Заголовок HTTP-ответов {{HTTPHeader("Vary")}} определяет, как по заголовкам будущих ответов понять, что вместо ресурса с исходного сервера следует взять копию из кеша.</p>

<p>Если кеш получает запрос, который можно удовлетворить сохраненным в кеше ответом с заголовком <code>Vary</code>, то использовать этот ответ можно только при совпадении всех полей заголовка, названных заголовком <code>Vary</code>, в исходном (сохраненном в кеше) запроса и новом запросе.</p>

<p><img alt="The Vary header leads cache to use more HTTP headers as key for the cache." src="https://mdn.mozillademos.org/files/13769/HTTPVary.png" style="height: 817px; width: 752px;"></p>

<p>Это может быть полезно, например, при динамическом обслуживании контента. При использовании заколовка <code>Vary: User-Agent</code> header кеширующие сервера, принимая решение о том, использовать ли страницу из кеша, дожны учитывать агент пользователя. Так можно избежать ситуации, когда пользователи мобильных устройств по ошибке получат десктоповую версию вашего сайта. Кроме того, это может помочь Google и другим поисковым системам обнаружить версию страницы, предназначенную для мобильных устройств, и, возможно, подскажет им, что не предполагается никакой маскировки (<a href="https://en.wikipedia.org/wiki/Cloaking">Cloaking</a>).</p>

<pre>Vary: User-Agent</pre>

<p>Посколько значение заголовка {{HTTPHeader("User-Agent")}} различается ("varies") у мобильных и десктоповых клиентов, кеши не станут по ошибке отсылать мобильные версии для десктоповых клиентов, и наоборот.</p>

<h2 id="Смотрите_также">Смотрите также</h2>

<ul>
 <li><a href="https://tools.ietf.org/html/rfc7234">RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</a></li>
 <li><a href="https://www.mnot.net/cache_docs">Caching Tutorial – Mark Nottingham</a></li>
 <li><a href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching">HTTP caching – Ilya Grigorik</a></li>
 <li><a href="https://redbot.org/">RedBot</a>, инструмент для проверки относящихся к кешу заголовков HTTP .</li>
</ul>

<p><br>
  </p>