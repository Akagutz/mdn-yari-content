<div>{{jsSidebar("More")}}</div>

<p>В ECMAScript 5 введен <a href="/ru/docs/JavaScript/Strict_mode" title="/en-US/docs/JavaScript/Strict_mode">строгий режим</a>, который реализован во всех основных браузерах (включая IE10). В то время как включение интерпретации кода браузерами в строгом режиме делается очень просто (достаточно добавить <code>"use strict";</code> в верхней части вашего кода), для адаптации уже существующего кода к строгому режиму потребуется немного больше работы.</p>

<p>Цель этой статьи: предоставить для разработчиков руководство по переходу к строгому режиму.</p>

<h2 id="Постепенный_переход">Постепенный переход</h2>

<p>Строгий режим был спроектирован таким образом, чтобы переход к нему  можно было сделать постепенно.  Каждый файл можно переводить к строгому режиму поодиночке, и даже есть возможность включить строгий режим для каждой функции по отдельности.</p>

<h2 id="Различия_non-strict_и_strict_режимов">Различия non-strict и strict режимов</h2>

<h3 id="Синтаксические_ошибки">Синтаксические ошибки</h3>

<p>При добавлении <code>"use strict";</code> следующие случаи вызывают {{jsxref("SyntaxError")}} до выполнения скрипта:</p>

<ul>
 <li>Восьмиричное представление числа <code>var n = 023;</code></li>
 <li>Использование оператора <code><a href="/ru/docs/Web/JavaScript/Reference/Statements/with" title="/en-US/docs/JavaScript/Reference/Statements/with">with</a></code> </li>
 <li><font face="Open Sans, Arial, sans-serif">Использование </font><code><a href="/ru/docs/Web/JavaScript/Reference/Operators/delete" title="/en-US/docs/JavaScript/Reference/Operators/delete">delete</a></code> на имени переменной <code>delete myVariable</code>;</li>
 <li>Использование <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/eval"><code>eval</code></a> or <a href="/ru/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a> как переменную или аргумент функции</li>
 <li>Использование одного из новых <a href="/ru/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords">зарезервированных ключевых слов</a> (Зарезервированных для ECMAScript 6): <code>implements</code>, <code>interface</code>, <code>let</code>, <code>package</code>, <code>private</code>, <code>protected</code>, <code>public</code>, <code>static</code>, и <code>yield</code></li>
 <li>Объявление фукнций в блоках <code>if (a &lt; b) { function f() {} }</code></li>
 <li>Очевидные ошибки
  <ul>
   <li>Объявление дважды свойства с одним и тем же именем в литерале объекта <code>{a: 1, b: 3, a: 7}</code>. Это уже изменилось в ECMAScript 6 ({{bug(1041128)}}).</li>
   <li>Объявление нескольких аргументов функции с одним и тем же именем <code>function f(a, b, b) {}</code></li>
  </ul>
 </li>
</ul>

<p>Эти ошибки хороши тем, что обличают скользкие, едва уловимые ошибки и плохие практики написания кода. </p>

<h3 id="Новые_ошибки_во_время_выполнения_(runtime_errors)">Новые ошибки во время выполнения (runtime errors)</h3>

<p>JavaScript  не показывал никаких ошибок и предупреждений в некоторых случаях выполнения некорректного кода. Строгий режим выбрасывает ошибки в таких случаях. Если в вашем коде есть такие случаи, тестирование будет необходимо, чтобы убедиться, что ничего не сломалось после перехода к строгому режиму.  Повторюсь,  эта ошибка может случится на уровне реализации функции.</p>

<h4 id="Установка_значения_необъявленной_переменной">Установка значения необъявленной переменной</h4>

<pre class="brush: js">function f(x) {
  "use strict";
  var a = 12;
  b = a + x * 35; // error!
}
f(42);
</pre>

<p>Здесь изменяется значение глобального объекта, что редко носит ожидаемый характер. Если вы хотите изменить значение глобального объекта, передайте его в качестве аргумента функции и явно присвойте его как свойство:</p>

<pre class="brush: js">var global = this; // в верхнем контексте "this" всегда
                   // ссылается на глобальный объект
function f(x) {
  "use strict";
  var a = 12;
  global.b = a + x * 35;
}
f(42);
</pre>

<h4 id="Попытка_удалить_неконфигурируемое_свойство">Попытка удалить неконфигурируемое свойство</h4>

<pre class="brush: js">"use strict";
delete Object.prototype; // error!
</pre>

<p>В нестрогом режиме этот код может молчаливо выполниться и ничего не сделать, вопреки ожиданием.</p>

<h4 id="Отравленные_аргументы_(arguments)_и_свойства_функции">Отравленные аргументы (arguments) и свойства функции</h4>

<p>Обращение к <code>arguments.callee</code>, <code>arguments.caller</code>, <code>anyFunction.caller</code>, или <code>anyFunction.arguments</code> выбросит ошибку в строгом режиме. Единственный законный способ повторного использования функции как в:</p>

<pre class="brush: js">// Пример взят с vanillajs: http://vanilla-js.com/
var s = document.getElementById('thing').style;
s.opacity = 1;
(function() { 
  if((s.opacity-=.1) &lt; 0)
    s.display = "none";
  else
    setTimeout(arguments.callee, 40);
})();</pre>

<p>может быть переписан как:</p>

<pre class="brush: js">"use strict";
var s = document.getElementById('thing').style;
s.opacity = 1;
(function fadeOut() { // имя функции
  if((s.opacity-=.1) &lt; 0)
    s.display = "none";
  else
    setTimeout(fadeOut, 40); // используется имя функции
})();</pre>

<h3 id="Семантические_различия">Семантические различия</h3>

<p>Эти различия очень тонкие. Вполне возможно, что тесты не поймают этот тип едва уловимых отличий. Тщательный обзор кода, вероятно, будет необходим, чтобы удостовериться, что эти различия не влияют на семантику вашего кода. К счастью, этот анализ может быть сделан постепенно, спускаясь вниз к реализации каждой конкретной функции.</p>

<h4 id="this_в_вызовах_фукнции"><code>this</code> в вызовах фукнции</h4>

<p><font face="Open Sans, Arial, sans-serif">В функциях как </font><code>f()</code>,  значением <code>this</code> является глобальный объект. В строгом режиме он теперь равен <code>undefined</code>.  Когда функция была вызвана с помощью <code><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="/en-US/docs/Core_JavaScript_1.5_Reference/Global_Objects/Function/call">call</a></code> или <code><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="/en-US/docs/Core_JavaScript_1.5_Reference/Global_Objects/Function/apply">apply</a></code>,  если значением был примитив, он упаковывался в соответствующий объект (или в глобальный объект для <code>undefined</code> и <code>null</code>). В строгом режиме значение передается без каких - либо преобразований и замен.</p>

<h4 id="arguments_не_является_псевдонимом_аргументов_именнованной_функции"><code>arguments</code> не является псевдонимом аргументов именнованной функции</h4>

<p>В нестрогом режиме изменение значения в объекте <code>arguments</code> изменяло соответствующий именованный параметр функции.  Это усложняло оптимизацию кода для движков JavaScript и сам код становился менее читабельным и понятным.  В строгом режиме объект <code>arguments</code>  создается и инициализируется с теми же значениями, что и именованные аргументы, но изменения объекта arguments и именнованных аругментов теперь никак не влияют друг на друга.</p>

<h4 id="Изменения_в_eval">Изменения в <code>eval</code></h4>

<p>В строгом режиме eval не создает новой переменной в той области видимости, где был вызван. Так же, конечно, в строгом режиме, строка выполняется с правилами строгого режима. Хотя для уверенности, что ничего не сломалось, тестирование будет необходимо. Не используйте eval, если он вам на самом деле не нужен, возможно, есть более практичное решение.</p>

<h2 id="Строго_нейтральный_код">Строго нейтральный код</h2>

<p>Потенциальный "недостаток" перевода кода в строгий режим - это отличия в семантике старых браузеров, в которых он не реализован. В некоторых редких случаях (как при конкатенации и минификации) ваш код может не запускаться. Здесь несколько правил, как сделать ваш код строго нейтральным:</p>

<ol>
 <li>Пишите ваш код в строгом режиме и убедитесь в отсутствии ошибок только строго режима (из секции выше "Новые ошибки во время выполнения").</li>
 <li>Держитесь подальше от семантических различий
  <ol>
   <li><code>eval</code>: использовать только тогда, когда вы знаете что делаете</li>
   <li><code>arguments</code>: всегда обращайтесь в фукнции к объекту arguments через его имя или сделайте его копию :<br>
    <code>var args = Array.prototype.slice.call(arguments)</code><br>
    в первой строчке вашей функции</li>
   <li><code>this</code>: использовать <code>this</code> только тогда, когда он ссылается на объект, созданный вами</li>
  </ol>
 </li>
</ol>

<h2 id="Смотрите_также">Смотрите также</h2>

<ul>
 <li><a href="/ru/docs/Web/JavaScript/Reference/Strict_mode">Строгий режим</a></li>
</ul>