<p>บทนี้อธิบายนิพจน์จาวาสคริปต์ และตัวดำเนินการต่างๆซึ่งประกอบด้วย การให้ค่า, การเปรียบเทียบ, เลขคณิต, บิท, ตรรกะ, สตริง, และตัวดำเนินการพิเศษ</p>

<h2 id="นิพจน์_(Expressions)">นิพจน์ (Expressions)</h2>

<p>นิพจน์คือ ส่วนของโค้ดที่หาค่าได้</p>

<p>แนวคิดพื้นฐาน, มีนิพจน์อยู่สองชนิด แบบแรกคือการให้ค่ากับตัวแปร และอีกแบบคือการหาค่าให้ได้</p>

<p>นิพจน์  <code>x = 7</code>,  คือตัวอย่างแบบแรก นิพจน์นี้ใช้ตัวดำเนินการ <code>=</code> เพื่อให้ค่าเจ็ดกับตัวแปร <code>x</code> โดยตัวนิพจน์เองจะมีค่าเป็นเจ็ด</p>

<p>นิพจน์  <code>3 + 4</code>,  คือตัวอย่างแบบที่สอง นิพจน์นี้ใช้ตัวดำเนินการ <code>+</code> ทำการรวมค่าสามและสี่เข้าด้วยกัน โดยไม่มีการให้ค่าผลลัพธ์เจ็ดกับตัวแปรใดๆ<br>
 <br>
 จาวาสคริปต์ประกอบด้วยนิพจน์ประเภทต่างๆดังนี้</p>

<ul>
 <li>คณิตศาสตร์: หาค่าตัวเลข เช่น, <code>3.14159</code> (โดยทั่วไปใช้ {{ web.link("#Arithmetic_operators", "ตัวดำเนินการคณิตศาสตร์") }})</li>
 <li>สตริง: หาค่าสตริงของอักขระ เช่น, <code>"Fred"</code> หรือ <code>"234"</code> (โดยทั่วไปใช้ {{ web.link("#String_operators", "ตัวดำเนินการสตริง") }})</li>
 <li>ตรรกะ: หาค่าจริง (<code>true</code>) หรือเท็จ (<code>false</code>) (มักใช้กับ {{ web.link("#Logical_operators", "ตัวดำเนินการตรรกะ") }})</li>
 <li>อ็อบเจกต์: หาค่าอ็อบเจกต์ (ดูเพิ่มที่ {{ web.link("#Special_operators", "ตัวดำเนินการพิเศษ") }} แบบต่างๆที่คืนค่าเป็นอ็อบเจกต์)</li>
</ul>

<h2 id="ตัวดำเนินการ_(Operators)">ตัวดำเนินการ (Operators)</h2>

<p>ในส่วนนี้เป็นการอธิบายตัวดำเนินการชนิดต่างๆ และลำดับความสำคัญของตัวดำเนินการ โดยจาวาสคริปต์มีตัวดำเนินการชนิดต่างๆดังนี้</p>

<ul>
 <li>{{ web.link("#Assignment_operators", "ตัวดำเนินการให้ค่า") }}</li>
 <li>{{ web.link("#Comparison_operators", "ตัวดำเนินการเปรียบเทียบ") }}</li>
 <li>{{ web.link("#Arithmetic_operators", "ตัวดำเนินการคณิตศาสตร์") }}</li>
 <li>{{ web.link("#Bitwise_operators", "ตัวดำเนินการบิท") }}</li>
 <li>{{ web.link("#Logical_operators", "ตัวดำเนินการตรรกะ") }}</li>
 <li>{{ web.link("#String_operators", "ตัวดำเนินการสตริง") }}</li>
 <li>{{ web.link("#Special_operators", "ตัวดำเนินการพิเศษ") }}</li>
</ul>

<p>จาวาสคริปต์มีตัวดำเนินการแบบเดี่ยว แบบคู่, และแบบพิเศษ (ตัวดำเนินการเงื่อนไข) โดยตัวดำเนินการแบบคู่ ใช้กับตัวถูกดำเนินการสองตัว, อยู่ข้างหน้าและข้างหลังตัวดำเนินการ ดังนี้</p>

<pre><em>ตัวถูกดำเนินการ</em> <strong><em>ตัวดำเนินการ</em></strong> <em>ตัวถูกดำเนินการ</em>
</pre>

<p>ตัวอย่างเช่น, <code>3+4</code> หรือ <code>x*y</code>.</p>

<p>ตัวดำเนินการเดี่ยว ใช้กับตัวถูกดำเนินการตัวเดียว ไม่อยู่ข้างหน้าก็อยู่ข้างหลังตัวดำเนินการ</p>

<pre><em>ตัวถูกดำเนินการ</em> <strong><em>ตัวดำเนินการ</em></strong>
</pre>

<p>หรือ</p>

<pre><strong><em>ตัวดำเนินการ</em></strong> <em>ตัวถูกดำเนินการ</em>
</pre>

<p>ตัวอย่างเช่น, <code>x++</code> หรือ <code>++x</code>.</p>

<h3 id="ตัวดำเนินการให้ค่า">ตัวดำเนินการให้ค่า</h3>

<p>ตัวดำเนินการให้ค่า ทำหน้าที่กำหนดค่าให้กับตัวแปรด้านซ้าย ด้วยค่าจากผลลัพธ์ด้านขวา โดยตัวดำเนินการให้ค่าแบบพื้นฐานแทนด้วยเครื่องหมายเท่ากับ (<code>=</code>) จะนำค่าที่อยู่ด้านขวาไปให้ตัวแปรที่อยู่ด้านซ้าย นั่นคือ <code>x = y</code> หมายถึงการนำค่า <code>y</code> ไปให้ <code>x</code></p>

<p>ตัวดำเนินการให้ค่าแบบอื่นๆ มีรูปแบบอย่างย่อตามตารางต่อไปนี้</p>

<table class="standard-table">
 <caption>ตาราง 3.1 ตัวดำเนินการให้ค่าแบบอื่นๆ</caption>
 <thead>
  <tr>
   <th scope="col">รูปแบบย่อตัวดำเนินการ</th>
   <th scope="col">ความหมาย</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>x += y</code></td>
   <td><code>x = x + y</code></td>
  </tr>
  <tr>
   <td><code>x -= y</code></td>
   <td><code>x = x - y</code></td>
  </tr>
  <tr>
   <td><code>x *= y</code></td>
   <td><code>x = x * y</code></td>
  </tr>
  <tr>
   <td><code>x /= y</code></td>
   <td><code>x = x / y</code></td>
  </tr>
  <tr>
   <td><code>x %= y</code></td>
   <td><code>x = x % y</code></td>
  </tr>
  <tr>
   <td><code>x &lt;&lt;= y</code></td>
   <td><code>x = x &lt;&lt; y</code></td>
  </tr>
  <tr>
   <td><code>x &gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><code>x &gt;&gt;&gt;= y</code></td>
   <td><code>x = x &gt;&gt;&gt; y</code></td>
  </tr>
  <tr>
   <td><code>x &amp;= y</code></td>
   <td><code>x = x &amp; y</code></td>
  </tr>
  <tr>
   <td><code>x ^= y</code></td>
   <td><code>x = x ^ y</code></td>
  </tr>
  <tr>
   <td><code>x |= y</code></td>
   <td><code>x = x | y</code></td>
  </tr>
 </tbody>
</table>

<h3 id="ตัวดำเนินการเปรียบเทียบ">ตัวดำเนินการเปรียบเทียบ</h3>

<p><span class="comment">This seems to me kind of poorly explained, mostly the difference betwen "==" and "==="...</span> ตัวดำเนินการเปรียบเทียบ ทำหน้าที่เปรียบเทียบตัวถูกดำเนินการทั้งสองว่ามีค่าเป็นจริงตามนั้นหรือไม่ และคืนค่าผลลัพธ์เป็นค่าข้อมูลตรรกะ โดยตัวถูกดำเนินการเป็นได้ทั้งตัวเลข, สตริง,  ตรรกะ, หรืออ็อบเจกต์ ที่เป็นสตริงจะถูกเปรียบเทียบจากลำดับในพจนานุกรมมาตรฐานด้วยค่ายูนิโค้ด โดยส่วนใหญ่แล้วถ้าตัวถูกดำเนินการทั้งสองไม่เป็นชนิดเดียวกัน, จาวาสคริปต์จะพยายามแปลงค่าให้เหมาะสมต่อการเปรียบเทียบ ซึ่งจะได้ผลลัพธ์เหมือนการเปรียบเทียบค่าตัวเลข แต่ก็มีข้อยกเว้นเมื่อทำการเปรียบเทียบด้วยตัวดำเนินการ <code>===</code> และ <code>!==</code> ซึ่งตัวดำเนินการสองตัวนี้จะไม่มีการแปลงค่าก่อนการเปรียบเทียบ โดยข้อมูลทั้งสองจะต้องเท่ากันจริง หรือไม่เท่ากันจริงเท่านั้น</p>

<p>ตารางต่อไปนี้แสดงตัวดำเนินการเปรียบเทียบค่าของตัวอย่างง่ายๆดังนี้</p>

<pre class="brush: js">var var1 = 3, var2 = 4;
</pre>

<table class="standard-table">
 <caption>ตาราง 3.2 ตัวดำเนินการเปรียบเทียบ</caption>
 <thead>
  <tr>
   <th scope="col">ตัวดำเนินการ</th>
   <th scope="col">คำอธิบาย</th>
   <th scope="col">ตัวอย่างที่เป็นจริง (true)</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>เท่ากับ (<code>==</code>)</td>
   <td>ได้ค่าจริง ถ้าตัวถูกดำเนินการเท่ากัน</td>
   <td><code>3 == var1<br>
    "3" == var1<br>
    3 == '3'</code></td>
  </tr>
  <tr>
   <td>ไม่เท่ากับ (<code>!=</code>)</td>
   <td>ได้ค่าจริง ถ้าตัวถูกดำเนินการไม่เท่ากัน</td>
   <td><code>var1 != 4<br>
    var2 != "3"</code></td>
  </tr>
  <tr>
   <td>เท่ากันจริง (<code>===</code>)</td>
   <td>
    <p>ได้ค่าจริง ถ้าตัวถูกดำเนินการเท่ากัน และมีชนิดเดียวกัน ดูเพิ่มเติมที่ <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is"><code>Object.is</code></a> และ <a href="/en-US/docs/Web/JavaScript/Guide/Sameness" title="/en-US/docs/Web/JavaScript/Guide/Sameness">sameness in JS</a></p>
   </td>
   <td><code>3 === var1</code></td>
  </tr>
  <tr>
   <td>ไม่เท่ากันจริง (<code>!==</code>)</td>
   <td>ได้ค่าจริง ถ้าตัวถูกดำเนินการไม่เท่ากัน และ/หรือ ต่างชนิดเดียวกัน</td>
   <td><code>var1 !== "3"<br>
    3 !== '3'</code></td>
  </tr>
  <tr>
   <td>มากกว่า (<code>&gt;</code>)</td>
   <td>
    <p>ได้ค่าจริง ถ้าตัวถูกดำเนินการทางซ้าย มากกว่าตัวขวา</p>
   </td>
   <td><code>var2 &gt; var1<br>
    "12" &gt; 2</code></td>
  </tr>
  <tr>
   <td>มากกว่าเท่ากับ (<code>&gt;=</code>)</td>
   <td>ได้ค่าจริง ถ้าตัวถูกดำเนินการทางซ้าย มากกว่าหรือเท่ากับตัวขวา</td>
   <td><code>var2 &gt;= var1<br>
    var1 &gt;= 3</code></td>
  </tr>
  <tr>
   <td>น้อยกว่า (<code>&lt;</code>)</td>
   <td>ได้ค่าจริง ถ้าตัวถูกดำเนินการทางซ้าย น้อยกว่าตัวขวา</td>
   <td><code>var1 &lt; var2<br>
    "2" &lt; "12"</code></td>
  </tr>
  <tr>
   <td>น้อยกว่าเท่ากับ (<code>&lt;=</code>)</td>
   <td>ได้ค่าจริง ถ้าตัวถูกดำเนินการทางซ้าย น้อยกว่าหรือเท่ากับตัวขวา</td>
   <td><code>var1 &lt;= var2<br>
    var2 &lt;= 5</code></td>
  </tr>
 </tbody>
</table>

<h3 id="ตัวดำเนินการคณิตศาสตร์">ตัวดำเนินการคณิตศาสตร์</h3>

<p>ตัวดำเนินการคณิตศาสตร์ นำค่าตัวเลข (จากต้วข้อมูลหรือตัวแปร) มาดำเนินการทางคณิตศาสตร์ และคืนค่าผลลัพธ์เป็นค่าตัวเลขหนึ่งค่า ตัวดำเนินการคณิตศาสตร์มาตรฐานคือ บวก (<code>+</code>), ลบ (<code>-</code>), คูณ (<code>*</code>), และหาร (<code>/</code>) โดยตัวดำเนินการเหล่านี้ทำหน้าที่เหมือนในภาษาโปรแกรมส่วนใหญ่ เมื่อใช้กับตัวเลขจำนวนจริง (ที่พิเศษคือ การหารด้วยศูนย์จะได้ <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity"><code>Infinity</code></a>) ดังตัวอย่าง</p>

<pre class="brush: js">console.log(1 / 2); /* prints 0.5 */
console.log(1 / 2 == 1.0 / 2.0); /* also this is true */
</pre>

<p>นอกจากที่กล่าวมา จาวาสคริปต์ยังมีตัวดำเนินการคณิตศาสตร์ให้ใช้เพิ่มเติม ตามตารางต่อไปนี้</p>

<table class="fullwidth-table">
 <caption>ตาราง 3.3 ตัวดำเนินการคณิตศาสตร์</caption>
 <thead>
  <tr>
   <th scope="col">ตัวดำเนินการ</th>
   <th scope="col">คำอธิบาย</th>
   <th scope="col">ตัวอย่าง</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>%</code><br>
    (มอดูลัส)</td>
   <td>เป็นตัวดำเนินการคู่, ให้ค่าเศษจากการหารกันเป็นจำนวนเต็ม</td>
   <td><code>12 % 5</code> ได้ค่า <code>2</code></td>
  </tr>
  <tr>
   <td><code>++</code><br>
    (เพิ่มค่า)</td>
   <td>
    <p>เป็นตัวดำเนินการเดี่ยว, บวกหนึ่งเพิ่มที่ตัวถูกดำเนินการ ถ้าใช้ข้างหน้า (<code>++x</code>), จะคืนค่าหลังจากบวกแล้ว แต่ถ้าไว้ข้างหลัง (<code>x++</code>), จะคืนค่าก่อนการบวก</p>
   </td>
   <td>ถ้า <code>x</code> เป็น <code>3</code>, แล้ว <code>++x</code> จะได้ <code>x</code> เป็น <code>4</code> และคืนค่า <code>4</code>, ในขณะที่ <code>x++</code> คืนค่า <code>3</code> แล้วจึงทำให้ <code>x</code> เป็น <code>4</code>.</td>
  </tr>
  <tr>
   <td><code>--</code><br>
    (ลดค่า)</td>
   <td>เป็นตัวดำเนินการเดี่ยว, ลบหนึ่งออกจากตัวถูกดำเนินการ ค่าที่คืนเป็นไปแนวเดียวกับตัวเพิ่มค่า</td>
   <td>ถ้า <code>x</code> เป็น <code>3</code>, แล้ว <code>--x</code> จะได้ <code>x</code> เป็น <code>2</code> และคืนค่า <code>2</code>, ในขณะที่ <code>x--</code> คืนค่า <code>3</code> แล้วจึงทำให้ <code>x</code> เป็น <code>2</code></td>
  </tr>
  <tr>
   <td><code>-</code><br>
    (ทำให้เป็นลบ)</td>
   <td>
    <p>เป็นตัวดำเนินการเดี่ยว, คืนค่าลบของตัวถูกดำเนินการ</p>
   </td>
   <td>ถ้า <code>x</code> เป็น <code>3</code>, แล้ว <code>-x</code> จะได้ <code>-3</code></td>
  </tr>
 </tbody>
</table>

<h3 id="ตัวดำเนินการบิท">ตัวดำเนินการบิท</h3>

<p>ตัวดำเนินการบิท จัดการกับตัวถูกดำเนินการแบบเลขฐานสองจำนวน 32 บิท (ศูนย์และหนึ่ง), ไม่ใช่ฐานสิบ ฐานสิบหก หรือฐานแปด ตัวอย่าง เช่น, เลข <code>9</code> ในฐานสิบ เขียนแบบฐานสองได้ <code>1001</code> ซึ่งตัวดำเนินการแบบบิทจะจัดการค่าข้อมูลกับเลขฐานสองแบบนี้ และคืนผลลัพธ์เป็นค่าตัวเลขของจาวาสคริปต์</p>

<p>ตารางต่อไปนี้สรุปตัวดำเนินการบิทของจาวาสคริปต์</p>

<table class="standard-table">
 <caption>ตาราง 3.4 ตัวดำเนินการบิท</caption>
 <thead>
  <tr>
   <th scope="col">ตัวดำเนินการ</th>
   <th scope="col">วิธีใช้</th>
   <th scope="col">คำอธิบาย</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>AND</td>
   <td><code>a &amp; b</code></td>
   <td>คืนค่า 1 ในแต่ละบิท ที่มีค่าเป็น 1 ทั้งคู่</td>
  </tr>
  <tr>
   <td>OR</td>
   <td><code>a | b</code></td>
   <td>คืนค่า 1 ในแต่ละบิท ที่มีค่าตัวใดตัวหนึ่ง หรือทั้งคู่เป็น 1</td>
  </tr>
  <tr>
   <td>XOR</td>
   <td><code>a ^ b</code></td>
   <td>คืนค่า 1 ในแค่ละบิท ที่มีค่าตัวใดตัวหนึ่ง แต่ไม่ใช่ทั้งคู่เป็น 1</td>
  </tr>
  <tr>
   <td>NOT</td>
   <td><code>~ a</code></td>
   <td>ทำทุกบิทให้มีค่าตรงกันข้าม</td>
  </tr>
  <tr>
   <td>เลื่อนซ้าย</td>
   <td><code>a &lt;&lt; b</code></td>
   <td>
    <p>เลื่อนข้อมูล <code>a</code> ไปทางซ้ายจำนวน <code>b</code> บิท และเติม <code>0</code> เข้าทางขวา</p>
   </td>
  </tr>
  <tr>
   <td>เลื่อนขวาเก็บเครื่องหมาย</td>
   <td><code>a &gt;&gt; b</code></td>
   <td>เลื่อนข้อมูล <code>a</code> ไปทางขวาจำนวน <code>b</code> บิท ทิ้งบิทที่ถูกเลื่อนออกไป และเติม <code>0</code> เข้าทางซ้าย ถ้า <code>a</code> เป็นบวก, เติม <code>1</code> ถ้าเป็นลบ</td>
  </tr>
  <tr>
   <td>เลื่อนขวาเติมศูนย์</td>
   <td><code>a &gt;&gt;&gt; b</code></td>
   <td>เลื่อนข้อมูล <code>a</code> ไปทางขวาจำนวน <code>b</code> บิท ทิ้งบิทที่ถูกเลื่อนออกไป และเติม <code>0</code> เข้าทางซ้าย</td>
  </tr>
 </tbody>
</table>

<h4 id="Bitwise_Logical_Operators" name="Bitwise_Logical_Operators">ตัวดำเนินการบิทแบบตรรกะ</h4>

<p>โดยหลักการ, ตัวดำเนินการบิทแบบตรรกะทำงานดังนี้:</p>

<ul>
 <li>ตัวถูกดำเนินการทั้งหมด ถูกแปลงให้เป็นเลขจำนวนเต็ม 32  บิท ในรูปแบบฐานสอง (ศูนย์และหนึ่ง)</li>
 <li>แต่ละบิทของตัวถูกดำเนินการตัวแรกจับคู่กับบิทที่ตรงกันของตัวที่สอง บิทแรกคู่บิทแรก, บิทสองคู่บิทสอง, จนครบทุกบิท</li>
 <li>ตัวดำเนินการ จัดการค่าในแต่ละคู่บิท ได้ผลลัพธ์แบบบิท</li>
</ul>

<p>ตัวอย่าง เช่น, ฐานสองของเก้าคือ <code>1001</code>, และฐานสองของสิบห้าคือ <code>1111</code> เมื่อนำมาดำเนินการบิทจะได้ผลลัพธ์ดังนี้:</p>

<table class="standard-table">
 <caption>ตาราง 3.5 ตัวอย่างการใช้ตัวดำเนินการบิท</caption>
 <thead>
  <tr>
   <th scope="col">นิพจน์</th>
   <th scope="col">ผลลัพธ์</th>
   <th scope="col">รูปแบบฐานสอง</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>15 &amp; 9</code></td>
   <td><code>9</code></td>
   <td><code>1111 &amp; 1001 = 1001</code></td>
  </tr>
  <tr>
   <td><code>15 | 9</code></td>
   <td><code>15</code></td>
   <td><code>1111 | 1001 = 1111</code></td>
  </tr>
  <tr>
   <td><code>15 ^ 9</code></td>
   <td><code>6</code></td>
   <td><code>1111 ^ 1001 = 0110</code></td>
  </tr>
  <tr>
   <td><code>~15</code></td>
   <td><code>-16</code></td>
   <td><code>~</code><code>00000000...</code><code>00001111 = </code><code>1111</code><code>1111</code><code>...</code><code>11110000</code></td>
  </tr>
  <tr>
   <td><code>~9</code></td>
   <td><code>-10</code></td>
   <td><code>~</code><code>00000000</code><code>...</code><code>0000</code><code>1001 = </code><code>1111</code><code>1111</code><code>...</code><code>1111</code><code>0110</code></td>
  </tr>
 </tbody>
</table>

<p>หมายเหตุ  ค่า 32 บิททุกค่าจะถูกอินเวอร์ตโดยใช้ตัวดำเนินการบิท NOT, ถ้าค่านั้นมีบิทหลักซ้ายสุดเป็น <code>1</code> แสดงว่าเป็นเลขลบ (ใช้การแสดงแบบคู่ตรงข้าม)</p>

<h4 id="Bitwise_Shift_Operators" name="Bitwise_Shift_Operators">ตัวดำเนินการบิทแบบเลื่อน</h4>

<p>ตัวดำเนินการบิทแบบเลื่อน ใช้กับตัวถูกดำเนินการสองค่า ค่าแรกคือข้อมูลที่จะทำการเลื่อน ค่าที่สองคือจำนวนตำแหน่งบิทที่จะเลื่อน ทิศทางเลื่อนควบคุมโดยชนิดตัวดำเนินการที่ใช้</p>

<p>ตัวดำเนินการแบบเลื่อนนี้ จะแปลงค่าข้อมูลของตัวถูกดำเนินการให้เป็นจำนวนเต็มฐานสอง และคืนผลลัพธ์ที่ได้ด้วยข้อมูลแบบเดียวกับตัวถูกดำเนินการทางซ้าย</p>

<p>ตัวดำเนินการแบบเลื่อนมีรายละเอียดดังตารางต่อไปนี้</p>

<table class="fullwidth-table">
 <caption>ตาราง 3.6 ตัวดำเนินการบิทแบบเลื่อน</caption>
 <thead>
  <tr>
   <th scope="col">ตัวดำเนินการ</th>
   <th scope="col">คำอธิบาย</th>
   <th scope="col">ตัวอย่าง</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&lt;&lt;</code><br>
    (เลื่อนซ้าย)</td>
   <td>
    <p>ตัวดำเนินการนี้ เลื่อนข้อมูลตัวแรกไปทางซ้ายด้วยจำนวนบิทจากข้อมูลตัวหลัง ตัดบิทที่เกินออกทางซ้ายทิ้งไป และเติมบิท 0 เข้าทางขวา</p>
   </td>
   <td>
    <p><code>9&lt;&lt;2</code> ได้ <code>36</code>, เพราะ <code>1001</code> เลื่อนไป <code>2</code> บิททางซ้ายได้ <code>100100</code>, ซึ่งเท่ากับ <code>36</code></p>
   </td>
  </tr>
  <tr>
   <td><code>&gt;&gt;</code><br>
    (เลื่อนขวาเก็บเครื่องหมาย)</td>
   <td>
    <p>ตัวดำเนินการนี้ เลื่อนข้อมูลตัวแรกไปทางขวาด้วยจำนวนบิทจากข้อมูลตัวหลัง ตัดบิทที่เกินออกทางขวาทิ้งไป และเติมสำเนาบิทซ้ายสุดเข้าทางซ้าย</p>
   </td>
   <td>
    <p><code>9&gt;&gt;2</code> ได้ <code>2</code>, เพราะ <code>1001</code> เลื่อนไป <code>2</code> บิททางขวาได้ <code>10</code>, ซึ่งเท่ากับ <code>2</code></p>

    <p>ทำนองเดียวกัน, <code>-9&gt;&gt;2</code> ได้ <code>-3</code>, เพราะ <code>-9 เท่ากับ 111...11<span style="color: #0000ff;"><strong>0111</strong></span> เลื่อนไป 2 บิททางขวาและเติม 1 ทางซ้ายได้ <strong><span style="color: #0000ff;">1</span></strong>11...1111<strong><span style="color: #0000ff;">01</span></strong>,ซึ่งเท่ากับ -3</code></p>
   </td>
  </tr>
  <tr>
   <td><code>&gt;&gt;&gt;</code><br>
    (เลื่อนขวาเติมศูนย์)</td>
   <td>
    <p>ตัวดำเนินการนี้ เลื่อนข้อมูลตัวแรกไปทางขวาด้วยจำนวนบิทจากข้อมูลตัวหลัง ตัดบิทที่เกินออกทางขวาทิ้งไป และเติมบิท 0 เข้าทางซ้าย</p>
   </td>
   <td>
    <p><code>19&gt;&gt;&gt;2</code> ได้ <code>4</code>, เพราะ <code>10011</code> เลื่อนไป <code>2</code> บิททางขวาได้ <code>100</code>, ซึ่งเท่ากับ <code>4</code></p>

    <p>ถ้าไม่เป็นเลขลบ, การเลื่อนขวาเติมศูนย์ จะได้ผลลัพธ์เหมือนแบบเลื่อนขวาเก็บเครื่องหมาย</p>
   </td>
  </tr>
 </tbody>
</table>

<h3 id="ตัวดำเนินการตรรกะ">ตัวดำเนินการตรรกะ</h3>

<p>ตัวดำเนินการตรรกะโดยทั่วไปใช้กับข้อมูลตรรกะ และคืนค่าเป็นข้อมูลตรรกะ แต่ตามจริงแล้ว, ตัวดำเนินการ <code>&amp;&amp;</code> และ <code>||</code> จะคืนค่าใดค่าหนึ่งของตัวถูกดำเนินการ ดังนั้นถ้านำไปใช้กับค่าที่ไม่ใช่ข้อมูลตรรกะ อาจจะได้ผลลัพธ์ที่ไม่ใช่ข้อมูลตรรกะ ดังอธิบายได้ตามตารางต่อไปนี้</p>

<table class="fullwidth-table">
 <caption>ตาราง 3.6 ตัวดำเนินการตรรกะ</caption>
 <thead>
  <tr>
   <th scope="col">Operator</th>
   <th scope="col">Usage</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&amp;&amp;</code></td>
   <td><code>expr1 &amp;&amp; expr2</code></td>
   <td>(ตรรกะ AND) คืนค่า <code>expr1</code> ถ้าแปลงเป็น <code>false</code> ได้ นอกนั้นคืนค่า <code>expr2</code> โดยถ้านำไปใช้กับข้อมูลตรรกะ, <code>&amp;&amp;</code> จะคืน <code>true</code> ถ้าทั้งสองค่าเป็นจริง, นอกนั้นคืน <code>false</code></td>
  </tr>
  <tr>
   <td><code>||</code></td>
   <td><code>expr1 || expr2</code></td>
   <td>(ตรรกะ OR) คืนค่า <code>expr1</code> ถ้าแปลงเป็น <code>true</code> ได้ นอกนั้นคืนค่า <code>expr2</code> โดยถ้านำไปใช้กับข้อมูลตรรกะ, <code>||</code> จะคืน <code>true</code> ถ้าค่าใดค่าหนึ่งเป็นจริง ถ้าทั้งคู่เป็นเท็จ, คืนค่า <code>false</code></td>
  </tr>
  <tr>
   <td><code>!</code></td>
   <td><code>!expr</code></td>
   <td>(ตรรกะ NOT) คืนค่า <code>false</code> ถ้าสามารถแปลงค่า <code>expr เป็น true ได้,นอกนั้นคืนค่า true</code></td>
  </tr>
 </tbody>
</table>

<p>โดยนิพจน์ที่สามารถแปลงเป็น <code>false</code> ได้คือ นิพจน์ที่หาค่าได้เป็น ค่าว่าง, <code>0</code>, <code>NaN</code>, สตริงว่าง (<code>""</code>) , หรือ <code>undefined</code></p>

<p>โค้ดต่อไปนี้แสดงตัวอย่างการใช้ ตัวดำเนินการ <code>&amp;&amp;</code> (ตรรกะ AND)</p>

<pre class="brush: js">var a1 =  true &amp;&amp; true;     // t &amp;&amp; t returns true
var a2 =  true &amp;&amp; false;    // t &amp;&amp; f returns false
var a3 = false &amp;&amp; true;     // f &amp;&amp; t returns false
var a4 = false &amp;&amp; (3 == 4); // f &amp;&amp; f returns false
var a5 = "Cat" &amp;&amp; "Dog";    // t &amp;&amp; t returns Dog
var a6 = false &amp;&amp; "Cat";    // f &amp;&amp; t returns false
var a7 = "Cat" &amp;&amp; false;    // t &amp;&amp; f returns false
</pre>

<p>โค้ดต่อไปนี้แสดงตัวอย่างการใช้ ตัวดำเนินการ <code>||</code> (ตรรกะ OR)</p>

<pre class="brush: js">var o1 =  true || true;     // t || t returns true
var o2 = false || true;     // f || t returns true
var o3 =  true || false;    // t || f returns true
var o4 = false || (3 == 4); // f || f returns false
var o5 = "Cat" || "Dog";    // t || t returns Cat
var o6 = false || "Cat";    // f || t returns Cat
var o7 = "Cat" || false;    // t || f returns Cat
</pre>

<p>โค้ดต่อไปนี้แสดงตัวอย่างการใช้ ตัวดำเนินการ <code>!</code> (ตรรกะ NOT)</p>

<pre class="brush: js">var n1 = !true;  // !t returns false
var n2 = !false; // !f returns true
var n3 = !"Cat"; // !t returns false
</pre>

<h4 id="Short-Circuit_Evaluation" name="Short-Circuit_Evaluation">การหาค่าแบบวิธีลัด</h4>

<p>เนื่องจากการหาค่านิพจน์แบบตรรกะ เป็นแบบซ้ายไปขวา, จึงสามารถใช้วิธีลัดเพื่อหาค่าได้ดังนี้</p>

<ul>
 <li><code>false</code> &amp;&amp; <em>อะไรก็ได้</em> , ใช้วิธีลัดจะได้ <code>false</code></li>
 <li><code>true</code> || <em>อะไรก็ได้</em> , ใช้วิธีลัดจะได้ <code>true</code></li>
</ul>

<p>ด้วยกฏของตรรกะรับประกันได้ว่า การหาค่าแบบนี้ถูกต้องเสมอ และเนื่องจาก <em>อะไรก็ได้</em>  ในนิพจน์ด้านบนไม่ถูกดำเนินการ จีงไม่ส่งผลข้างเคียงจากการหาค่า <em>อะไรก็ได้</em></p>

<h3 id="ตัวดำเนินการสตริง">ตัวดำเนินการสตริง</h3>

<p>นอกจากตัวดำเนินการเปรียบเทียบจะใช้กับข้อมูลสตริงได้แล้ว, ตัวดำเนินการ <code>+</code> ก็สามารถเชื่อมต่อสตริงสองตัวเข้าด้วยกันได้ โดยคืนค่าสตริงใหม่ที่เกิดจากการรวมกันของสตริงทั้งสอง เช่น <code>"my " + "string"</code> ได้สตริง <code>"my string"</code></p>

<p>ตัวดำเนินการให้ค่าแบบย่อ <code>+=</code> สามารถใช้เชื่อมสตริงเข้าด้วยกันได้ เช่น, มีตัวแปรชื่อ <code>mystring</code> มีค่า <code>"alpha"</code>, นิพจน์ <code>mystring += "bet"</code> จะหาค่าได้เป็น <code>"alphabet"</code> และให้ค่านี้กับตัวแปร <code>mystring</code></p>

<h3 id="ตัวดำเนินการพิเศษ">ตัวดำเนินการพิเศษ</h3>

<p>จาวาสคริปต์มีตัวดำเนินการพิเศษให้ดังนี้:</p>

<ul>
 <li><code>{{ web.link("#Conditional_operator", "ตัวดำเนินการเงื่อนไข") }}</code></li>
 <li><code>{{ web.link("#Comma_operator", "ตัวดำเนินการคอมมา") }}</code></li>
 <li><code>{{ web.link("#delete", "delete") }}</code></li>
 <li><code>{{ web.link("#in", "in") }}</code></li>
 <li><code>{{ web.link("#instanceof", "instanceof") }}</code></li>
 <li><code>{{ web.link("#new", "new") }}</code></li>
 <li><code>{{ web.link("#this", "this") }}</code></li>
 <li><code>{{ web.link("#typeof", "typeof") }}</code></li>
 <li><code>{{ web.link("#void", "void") }}</code></li>
</ul>

<h4 id="conditional_operator" name="conditional_operator">ตัวดำเนินการเงื่อนไข</h4>

<p>ตัวดำเนินการเงื่อนไข เป็นตัวดำเนินการแบบเดียวในจาวาสคริปต์ที่รับตัวถูกดำเนินการสามค่า และคืนค่าใดค่าหนึ่งจากสองค่าตามเงื่อนไข โดยมีรูปแบบดังนี้:</p>

<pre><em>เงื่อนไข</em> ? <code>val1</code> : <code>val</code>2
</pre>

<p>ถ้า เงื่อนไข เป็นจริง, จะคืนค่า<code>จาก val1</code>  นอกนั้นจะคืนค่าจาก <code>val2</code> โดยคุณสามารถใช้ตัวดำเนินการนี้ได้ทุกที่เหมือนตัวดำเนินการปกติ.</p>

<p>ตัวอย่าง เช่น,</p>

<pre class="brush: js">var status = (age &gt;= 18) ? "adult" : "minor";
</pre>

<p>คำสั่งนี้เป็นการให้ค่า <code>"adult"</code> แก่ตัวแปร <code>status</code> ถ้า <code>age</code> มากกว่าเท่ากับสิบแปด, นอกนั้นจะให้ค่า <code>"minor"</code> แก่  <code><code>status</code></code></p>

<h4 id="comma_operator" name="comma_operator">ตัวดำเนินการคอมมา</h4>

<p>ตัวดำเนินการคอมมา (<code>,</code>) ทำหน้าที่หาค่าจากตัวถูกดำเนินการสองตัว และคืนค่าตัวที่สอง โดยตัวดำเนินการนี้ใช้ในคำสั่งลูป <code>for</code> เป็นหลัก, เพื่อให้สามารถปรับค่าตัวแปรหลายตัวในแต่ละลูปได้</p>

<p>ตามตัวอย่าง, ถ้า <code>a</code> เป็นอาร์เรย์สองมิติมีสมาชิกจำนวน 10 ตัว, ในโค้ดจะใช้ตัวดำเนินการคอมมา เพื่อเพิ่มค่าตัวแปรทั้งสองตัวพร้อมๆกัน โดยโค้ดนี้จะพิมพ์ค่าสมาชิกในแนวแทยงมุมของอาร์เรย์ออกมา</p>

<pre class="brush: js">for (var i = 0, j = 9; i &lt;= 9; i++, j--)
  document.writeln("a[" + i + "][" + j + "]= " + a[i][j]);
</pre>

<h4 id="delete" name="delete"><code>delete</code></h4>

<p>ตัวดำเนินการ <code>delete</code> ใช้เพื่อลบอ็อบเจกต์, คุณสมบัติอ็อบเจกต์, หรือสมาชิกของอาร์เรย์ในตำแหน่งที่ระบุ โดยมีรูปแบบการใช้งานดังนี้:</p>

<pre class="brush: js">delete objectName;
delete objectName.property;
delete objectName[index];
delete property; // legal only within a with statement
</pre>

<p>โดยที่<code> objectName</code> คือชื่ออ็อบเจกต์, <code>property</code> คือคุณสมบัติอ็อบเจ็กต์, และ <code>index</code> เป็นจำนวนเต็มแทนตำแหน่งของสมาชิกในอาร์เรย์</p>

<p>รูปแบบที่สี่ ใช้ในคำสั่ง <code>with</code> เพื่อลบคุณสมบัติออกจากอ็อบเจกต์</p>

<p>คุณสามารถใช้ตัวดำเนินการ <code>delete</code> เพื่อลบตัวแปรที่ประกาศโดยไม่มีคำสั่ง <code>var</code> ได้</p>

<p>ถ้า <code>delete</code> ดำเนินการสำเร็จ จะกำหนดคุณสมบัติหรือสมาชิกที่ถูกลบให้มีค่าเป็น <code>undefined</code> โดยจะคืนค่า <code>true</code> ถ้าการดำเนินการเป็นไปได้ และคืนค่า <code>false</code> ถ้าเป็นไปไม่ได้</p>

<pre class="brush: js">x = 42;
var y = 43;
myobj = new Number();
myobj.h = 4;    // create property h
delete x;       // returns true (can delete if declared implicitly)
delete y;       // returns false (cannot delete if declared with var)
delete Math.PI; // returns false (cannot delete predefined properties)
delete myobj.h; // returns true (can delete user-defined properties)
delete myobj;   // returns true (can delete if declared implicitly)
</pre>

<h5 id="การลบสมาชิกในอาร์เรย์">การลบสมาชิกในอาร์เรย์</h5>

<p>เมื่อคุณลบสมาชิกของอาร์เรย์, ความยาวของอาร์เรย์จะไม่เปลี่ยนแปลง เช่น, ถ้าลบ <code>a[3]</code>, <code>a[4]</code> ก็ยังเป็น <code>a[4]</code> และ <code>a[3]</code> มีค่า <code>undefined</code></p>

<p>เมื่อตัวดำเนินการ <code>delete</code> ทำการลบสมาชิกอาร์เรย์,จะทำให้ไม่มีสมาชิกนั้นอยู่ในอาร์เรย์อีก ในตัวอย่างต่อไปนี้, <code>trees[3]</code> ถูกลบออกด้วย <code>delete</code> ทำให้นิพจน์ (<code>3 in trees</code>) ไม่เป็นจริง นั่นคือสมาชิกตัวที่สามไม่มีอยู่ในอาร์เรย์แล้ว แต่อย่างไรก็ตามยังสามารถอ้างถึง <code>trees[3]</code> ได้ โดยจะได้ค่าเป็น <code>undefined</code></p>

<pre class="brush: js">var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
delete trees[3];
if (3 in trees) {
  // this does not get executed
}
</pre>

<p>ถ้าคุณต้องการคงสมาชิกอาร์เรย์ไว้ แต่ไม่ต้องการให้มีค่า, ให้ใช้ <code>undefined</code> แทนการใช้ <code>delete</code> จากตัวอย่าง, <code>tree[3]</code> ถูกให้ค่าเป็น <code>undefined</code> โดยนิพจน์ (<code>3 in trees</code>)ยังเป็นจริงอยู่ นั่นคือสมาชิกตัวที่สามยังคงอยู่ในอาร์เรย์</p>

<pre class="brush: js">var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
trees[3] = undefined;
if (3 in trees) {
  // this gets executed
}
</pre>

<h4 id="in" name="in"><code>in</code></h4>

<p>ตัวดำเนินการ <code>in</code> คืนค่า <code>true</code> ถ้ามีคุณสมบัติที่ระบุอยู่ในอ็อบเจกต์นั้น</p>

<pre class="brush: js">propNameOrNumber in objectName
</pre>

<p>โดยที่ <code>propNameOrNumber</code> เป็นสตริงหรือนิพจน์ที่มีค่าเป็นตัวเลข แทนชื่อคุณสมบัติหรือตำแหน่งอาร์เรย์ และ <code>objectName</code> แทนชื่ออ็อบเจกต์</p>

<p>ตัวอย่างต่อไปนี้แสดงการใช้ตัวดำเนินการ <code>in</code></p>

<pre class="brush: js">// Arrays
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees;        // returns true
3 in trees;        // returns true
6 in trees;        // returns false
"bay" in trees;    // returns false (you must specify the index number,
                   // not the value at that index)
"length" in trees; // returns true (length is an Array property)

// Predefined objects
"PI" in Math;          // returns true
var myString = new String("coral");
"length" in myString;  // returns true

// Custom objects
var mycar = {make: "Honda", model: "Accord", year: 1998};
"make" in mycar;  // returns true
"model" in mycar; // returns true
</pre>

<h4 id="instanceof" name="instanceof"><code>instanceof</code></h4>

<p>ตัวดำเนินการ <code>instanceof</code> คืนค่า <code>true</code> ถ้าอ็อบเจกต์ที่ต้องการเปรียบเทียบเป็นชนิดเดียวกันกับที่ระบุ มีรูปแบบดังนี้</p>

<pre class="brush: js">objectName instanceof objectType
</pre>

<p>โดย <code>objectName</code> คือชื่ออ็อบเจกต์ที่ต้องการเปรียบเทียบ,และ <code>objectType</code> คือชนิดของอ็อบเจกต์ที่ระบุ เช่น <code>Date</code> หรือ <code>Array</code></p>

<p>ใช้ <code>instanceof</code> เมื่อคุณจำเป็นต้องยืนยันชนิดอ็อบเจกต์ตอนโปรแกรมทำงาน เช่น, ในโค้ดตรวจสอบข้อผิดพลาด คุณสามารถกำหนดให้โปรแกรมทำงานตามชนิดข้อผิดพลาดที่เกิดขึ้นได้</p>

<p>ตัวอย่างโค้ดต่อไปนี้ใช้ <code>instanceof</code> เพื่อหาว่า <code>theDay</code> เป็นอ็อบเจกต์ <code>Date</code> หรือไม่, และเนื่องจาก <code>theDay</code> เป็นอ็อบเจกต์ <code>Date</code> คำสั่ง <code>if</code> จืงทำงานได้</p>

<pre class="brush: js">var theDay = new Date(1995, 12, 17);
if (theDay instanceof Date) {
  // statements to execute
}
</pre>

<h4 id="new" name="new"><code>new</code></h4>

<p>คุณใช้ตัวดำเนินการ <code>new</code> เพื่อสร้างอ็อบเจกต์จากรูปแบบที่กำหนดเอง หรือจากที่มีในจาวาสคริปต์แล้วคือ<code> Array,Boolean,Date,Function,</code><code>Image</code>, <code>Number</code>, <code>Object</code>, <code>Option</code>, <code>RegExp</code>, หรือ <code>String</code>  โดยใน server, ยังสามารถใช้กับ <code>DbPool</code>, <code>Lock</code>, <code>File</code>, หรือ <code>SendMail</code> ได้ ซึ่งการใช้งาน <code>new </code>มีรูปแบบดังนี้:</p>

<pre class="brush: js">var objectName = new objectType([param1, param2, ..., paramN]);
</pre>

<p>คุณยังสามารถสร้างอ็อบเจกต์ได้จากตัวสร้างออบเจกต์  จากที่ได้อธิบายใน {{ web.link("Working_with_objects#Using_object_initializers", "using object initializers") }}</p>

<p>ดูข้อมูลเพิ่มเติมที่หน้า <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new"><code>new</code> operator</a> ใน Core JavaScript Reference</p>

<h4 id="this" name="this"><code>this</code></h4>

<p>ใช้คำสั่ง <code>this</code> เพื่ออ้างถึงอ็อบเจกต์ปัจจุบัน โดยทั่วไป <code>this</code> ในเมธอดจะหมายถึงอ็อบเจกต์ที่กำลังทำงานอยู่ โดยมีรูปแบบการใช้งานดังนี้</p>

<pre class="brush: js">this["propertyName"]
</pre>

<pre class="brush: js">this.propertyName
</pre>

<p><strong>ตัวอย่างที่ 1.</strong></p>

<p>สมมุติว่ามีฟังก์ชันชื่อ <code>validate</code> ทำหน้าที่ตรวจสอบคุณสมบัติ <code>value</code> ของอ็อบเจกต์, โดยกำหนดให้รับค่าอ็อบเจกต์,ค่าสูง,และค่าต่ำ ดังนี้:</p>

<pre class="brush: js">function validate(obj, lowval, hival){
  if ((obj.value &lt; lowval) || (obj.value &gt; hival))
    alert("Invalid Value!");
}
</pre>

<p>คุณสามารถเรียกใช้งาน <code>validate</code> จากเหตุการณ์ <code>onChange</code> ของแต่ละอ็อบเจกต์ในฟอร์มได้, โดยการส่งค่า <code>this</code> แทนอ็อบเจกต์นั้น ตามตัวอย่างต่อไปนี้</p>

<pre class="brush: html">&lt;B&gt;Enter a number between 18 and 99:&lt;/B&gt;
&lt;INPUT TYPE="text" NAME="age" SIZE=3
   onChange="validate(this, 18, 99);"&gt;
</pre>

<p><strong>ตัวอย่างที่ 2.</strong><br>
 <code>this.form</code> สามารถใช้อ้างถึงอ็อบเจกต์ฟอร์มได้ ในตัวอย่างต่อไปนี้, ฟอร์มชื่อ <code>myForm</code> ประกอบด้วยอ็อบเจกต์ <code>Text</code> และปุ่มกด เมื่อผู้ใช้กดปุ่ม, ค่าในอ็อบเจกต์จะถูกกำหนดให้เป็นชื่อของฟอร์ม จากเหตุการณ์ <code>onClick</code> ของปุ่มกด ซึ่งใช้คำสั่ง <code>this.form</code> แทนฟอร์ม <code>myForm </code></p>

<pre class="brush: html">&lt;FORM NAME="myForm"&gt;
Form name:&lt;INPUT TYPE="text" NAME="text1" VALUE="Beluga"/&gt;
&lt;INPUT NAME="button1" TYPE="button" VALUE="Show Form Name"
   onClick="this.form.text1.value = this.form.name;"/&gt;
&lt;/FORM&gt;
</pre>

<h4 id="typeof" name="typeof"><code>typeof</code></h4>

<p>ตัวดำเนินการ <code>typeof</code> ใช้ได้สองแบบดังนี้:</p>

<ol>
 <li>
  <pre class="brush: js">typeof operand
</pre>
 </li>
 <li>
  <pre class="brush: js">typeof (operand)
</pre>
 </li>
</ol>

<p>ตัวดำเนินการ <code>typeof</code> คืนค่าสตริงแสดงชนิดของตัวถูกดำเนินการ (ที่ยังไม่ถูกประมวลค่า) ซึ่งเป็นได้ทั้ง สตริง,ตัวแปร,คำสั่ง, หรืออ็อบเจกต์ ที่ต้องการทราบชนิด โดยจะใส่วงเล็บหรือไม่ใส่ก็ได้</p>

<p>สมมุติว่าคุณได้ประกาศตัวแปรต่อไปนี้:</p>

<pre class="brush: js">var myFun = new Function("5 + 2");
var shape = "round";
var size = 1;
var today = new Date();
</pre>

<p>ตัวดำเนินการ <code>typeof</code> จะคืนค่าผลลัพธ์ของแต่ละตัวแปรดังนี้:</p>

<pre class="brush: js">typeof myFun;     // returns "function"
typeof shape;     // returns "string"
typeof size;      // returns "number"
typeof today;     // returns "object"
typeof dontExist; // returns "undefined"
</pre>

<p>สำหรับ <code>true</code> และ <code>null</code>, ตัวดำเนินการ <code>typeof</code> จะคืนค่าผลลัพธ์ดังนี้:</p>

<pre class="brush: js">typeof true; // returns "boolean"
typeof null; // returns "object"
</pre>

<p>สำหรับตัวเลขและสตริง, ตัวดำเนินการ <code>typeof</code> จะคืนค่าผลลัพธ์ดังนี้:</p>

<pre class="brush: js">typeof 62;            // returns "number"
typeof 'Hello world'; // returns "string"
</pre>

<p>สำหรับค่าคุณสมบัติ, ตัวดำเนินการ <code>typeof</code> จะคืนชนิดของข้อมูลในคุณสมบัตินั้น:</p>

<pre class="brush: js">typeof document.lastModified; // returns "string"
typeof window.length;         // returns "number"
typeof Math.LN2;              // returns "number"
</pre>

<p>สำหรับเมธอดและฟังก์ชัน, ตัวดำเนินการ <code>typeof</code> จะคืนค่าผลลัพธ์ดังนี้:</p>

<pre class="brush: js">typeof blur;        // returns "function"
typeof eval;        // returns "function"
typeof parseInt;    // returns "function"
typeof shape.split; // returns "function"
</pre>

<p>สำหรับอ็อบเจกต์พื้นฐาน, ตัวดำเนินการ <code>typeof</code> จะคืนค่าผลลัพธ์ดังนี้:</p>

<pre class="brush: js">typeof Date;     // returns "function"
typeof Function; // returns "function"
typeof Math;     // returns "object"
typeof Option;   // returns "function"
typeof String;   // returns "function"
</pre>

<h4 id="void" name="void"><code>void</code></h4>

<p>ตัวดำเนินการ <code>void</code> ใช้ได้แบบใดแบบหนึ่งดังนี้:</p>

<ol>
 <li>
  <pre class="brush: js">void (expression)
</pre>
 </li>
 <li>
  <pre class="brush: js">void expression
</pre>
 </li>
</ol>

<p>ตัวดำเนินการ <code>void</code> ประมวลค่านิพจน์ที่กำหนดแต่ไม่คืนค่าออกมา โดยที่ <code>expression</code> คือนิพจน์ที่ต้องการหาค่า จะใส่หรือไม่ใส่วงเล็บก็ได้แต่รูปแบบที่ดีคือใส่ในวงเล็บ</p>

<p>คุณสามารถใช้ตัวดำเนินการ <code>void</code> กับนิพจน์ในลิงค์ไฮเปอร์เทกซ์ ซึ่งจะทำงานเมื่อมีการคลิ๊ก โดยไม่มีการโหลดหน้าเว็บใหม่</p>

<p>โค้ดต่อไปนี้สร้างลิงค์ไฮเปอร์เทกซ์ที่ไม่เกิดอะไรขึ้นเมื่อผู้ใช้คลิ๊ก โดยเมื่อลิ๊งค์ถูกคลิ๊ก, <code>void(0)</code> จะได้ค่าเป็น <code>undefined</code> ซึ่งไม่ทำให้เกิดอะไรขึ้นในจาวาสคริปต์</p>

<pre class="brush: html">&lt;A HREF="javascript:void(0)"&gt;Click here to do nothing&lt;/A&gt;
</pre>

<p>โค้ดต่อไปนี้สร้างลิงค์ไฮเปอร์เทกซ์ ที่จะส่งฟอร์มเมื่อผู้ใช้คลิ๊กมัน</p>

<pre class="brush: html">&lt;A HREF="javascript:void(document.form.submit())"&gt;
Click here to submit&lt;/A&gt;</pre>

<h3 id="ลำดับความสำคัญของตัวดำเนินการ">ลำดับความสำคัญของตัวดำเนินการ</h3>

<p>ลำดับความสำคัญของตัวดำเนินการ คือลำดับการทำงานของตัวดำเนินการเมื่อมีการประมวลค่านิพจน์ โดยคุณสามารถจัดลำดับเองได้โดยใช้วงเล็บช่วย</p>

<p>ตารางต่อไปนี้อธิบายลำดับความสำคัญของตัวดำเนินการ,  จากสูงที่สุดไปหาต่ำที่สุด</p>

<p><small><em>In accordance with <a href="/en-US/docs/Talk:JavaScript/Guide/Obsolete_Pages/Operators#Precedence_Tablerators#Precedence_Table">relevant discussion</a>, this table was reversed to list operators in <strong>decreasing</strong> order of priority.</em></small></p>

<table class="standard-table">
 <caption>ตาราง 3.7 ลำดับความสำคัญของตัวดำเนินการ</caption>
 <thead>
  <tr>
   <th scope="col">ชนิดตัวดำเนินการ</th>
   <th scope="col">ตัวดำเนินการแต่ละตัว</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>member</td>
   <td><code>. []</code></td>
  </tr>
  <tr>
   <td>call / create instance</td>
   <td><code>() new</code></td>
  </tr>
  <tr>
   <td>negation/increment</td>
   <td><code>! ~ - + ++ -- typeof void delete</code></td>
  </tr>
  <tr>
   <td>multiply/divide</td>
   <td><code>* / %</code></td>
  </tr>
  <tr>
   <td>addition/subtraction</td>
   <td><code>+ -</code></td>
  </tr>
  <tr>
   <td>bitwise shift</td>
   <td><code>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td>
  </tr>
  <tr>
   <td>relational</td>
   <td><code>&lt; &lt;= &gt; &gt;= in instanceof</code></td>
  </tr>
  <tr>
   <td>equality</td>
   <td><code>== != === !==</code></td>
  </tr>
  <tr>
   <td>bitwise-and</td>
   <td><code>&amp;</code></td>
  </tr>
  <tr>
   <td>bitwise-xor</td>
   <td><code>^</code></td>
  </tr>
  <tr>
   <td>bitwise-or</td>
   <td><code>|</code></td>
  </tr>
  <tr>
   <td>logical-and</td>
   <td><code>&amp;&amp;</code></td>
  </tr>
  <tr>
   <td>logical-or</td>
   <td><code>||</code></td>
  </tr>
  <tr>
   <td>conditional</td>
   <td><code>?:</code></td>
  </tr>
  <tr>
   <td>assignment</td>
   <td><code>= += -= *= /= %= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= ^= |=</code></td>
  </tr>
  <tr>
   <td>comma</td>
   <td><code>,</code></td>
  </tr>
 </tbody>
</table>

<p>รายละเอียดเพิ่มเติมของตารางนี้, พร้อมลิ๊งค์ที่มีรายละเอีนดของตัวดำเนินการแต่ละตัว หาได้จาก <a href="/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">JavaScript Reference</a></p>