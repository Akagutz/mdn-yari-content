<p>จาวาสคริปต์รองรับชุดคำสั่งขนาดย่อม ซึ่งส่วนใหญ่เป็นคำสั่งควบคุมที่คุณสามารถใช้สร้างปฏิสัมพันธ์ในหน้าเว็บได้หลากหลาย โดยในบทนี้จะกล่าวถึงภาพรวมของคำสั่งเหล่านี้</p>

<p>นิพจน์ก็เป็นคำสั่งแบบหนึ่ง ดูข้อมูลเกี่ยวกับนิพจน์ได้ที่ <a href="/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators">Expressions and Operators</a></p>

<p>ใช้เครื่องหมายเซมิโคลอน (<code>;</code>) เพื่อแยกคำสั่งในโปรแกรมจาวาสคริปต์</p>

<p>ดูรายละเอียดของคำสั่งต่างๆในบทนี้ได้ที่ <a href="/en-US/docs/Web/JavaScript/Reference/Statements">JavaScript Reference</a></p>

<h2 id="บล็อกคำสั่ง">บล็อกคำสั่ง</h2>

<p>บล็อกคำสั่ง ใช้เพื่อจัดกลุ่มคำสั่ง โดยจำกัดขอบเขตบล็อกด้วยคู่วงเล็บปีกกา ดังนี้:</p>

<pre class="brush: js">{
   statement_1;
   statement_2;
   .
   .
   .
   statement_n;
}
</pre>

<p>ตัวอย่าง<br>
 บล็อกคำสั่ง โดยทั่วไปใช้ร่วมกับคำสั่งควบคุมต่างๆ (เช่น <code>if</code>, <code>for</code>, <code>while</code>)</p>

<pre class="brush: js">while (x &lt; 10){
  x++;
}
</pre>

<p>โดยที่, <code>{  x++; }</code> คือบล็อกคำสั่ง</p>

<p><strong>เรื่องสำคัญ</strong>: จาวาสคริปต์<strong> ไม่มี</strong> ขอบเขตบล็อก โดยตัวแปรที่ประกาศภายในบล็อกมีขอบเขตอยู่ในฟังก์ชันหรือสคริปต์ที่ครอบบล็อกนั้น และการให้ค่าตัวแปรเหล่านี้มีผลถึงข้างนอกบล็อกนั้นด้วย หรืออธิบายได้ว่า, บล็อกคำสั่งไม่สร้างขอบเขตตัวแปรขึ้น และถึงแม้ว่าจะสามารถใช้บล็อกคำสั่งโดยไม่มีคำสั่งควบคุมได้ คุณก็ไม่ควรทำแบบนั้นในจาวาสคริปต์ เพราะมันไม่ได้ทำงานแบบเดียวกับในภาษาซีหรือจาวาอย่างที่เราคิด ตัวอย่าง เช่น:</p>

<pre class="brush: js">var x = 1;
{
  var x = 2;
}
alert(x); // outputs 2
</pre>

<p>จะได้ค่า <code>2</code> เพราะว่าคำสั่ง <code>var x</code> ในบล็อกอยู่ในขอบเขตเดียวกับ <code>var x</code> นอกบล็อก แต่ถ้าเป็นในภาษาซีหรือจาวา,  จะได้ค่าเป็น <code>1 </code></p>

<h2 id="คำสั่งเงื่อนไข">คำสั่งเงื่อนไข</h2>

<p>คำสั่งเงื่อนไข คือชุดคำสั่งที่จะทำงานเมื่อเงื่อนไขที่ระบุเป็นจริง โดยจาวาสคริปต์รองรับคำสั่งเงื่อนไขสองแบบ คือ <code>if...else</code> และ <code>switch</code></p>

<h3 id="คำสั่ง_if...else">คำสั่ง if...else</h3>

<p>ใช้คำสั่ง <code>if</code> เมื่อต้องการให้คำสั่งที่กำหนด ทำงานเมื่อเงื่อนไขตรรกะเป็นจริง (<code>true</code>) และอาจใช้ <code>else</code> ได้ ถ้าต้องการให้อีกคำสั่งทำงานเมื่อเงื่อนไขเป็นเท็จ (<code>false</code>) โดยคำสั่ง <code>if</code> มีรูปแบบการใช้งานดังนี้: </p>

<pre class="brush: js">if (condition)
  statement_1
[else
  statement_2]
</pre>

<p>โดย <code>condition</code> เป็นนิพจน์ใดๆที่หาค่าได้เป็น <code>true</code> หรือ <code>false</code> (ดูคำอธิบายเรื่องวิธีการหาค่า <code>true</code> และ <code>false</code> ได้ที่ <a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean#Description">Boolean</a>) ซึ่งถ้า <code>condition</code> มึค่าเป็น <code>true</code> จะทำให้ <code>statement_1</code> ทำงาน และในทางตรงข้าม, <code>statement_2</code> จะทำงานแทน โดยที่ <code>statement_1</code> และ <code>statement_2</code> สามารถเป็นคำสั่ง <code>if</code> ซ้อนได้</p>

<p>คุณสามารถผสมคำสั่ง โดยใช้ <code>else if</code> เมื่อต้องการทดสอบเงื่อนไขทีละขั้นได้ ดังนี้:</p>

<pre class="brush: js">if (condition)
  statement_1
[else if (condition_2)
  statement_2]
...
[else if (condition_n_1)
  statement_n_1]
[else
  statement_n]
</pre>

<p>ถ้าต้องการให้หลายคำสั่งทำงานในเงื่อนไขเดียวกัน, ให้รวมคำสั่งเข้าด้วยกันในบล็อกคำสั่ง (<code>{ ... }</code>) ซึ่งการใช้บล็อกคำสั่งอยู่เสมอเป็นวิธีการที่ดี โดยเฉพาะเมื่อใช้คำสั่ง <code>if</code> ซ้อนกันหลายชั้น:</p>

<pre class="brush: js">if (condition) {
    statement_1_runs_if_condition_is_true
    statement_2_runs_if_condition_is_true
} else {
    statement_3_runs_if_condition_is_false
    statement_4_runs_if_condition_is_false
}
</pre>

<div>ที่ไม่ควรทำคือ การกำหนดค่าภายในนิพจน์เงื่อนไข, เพราะจากโค้ด อาจทำให้เกิดการสับสนระหว่างการกำหนดค่า กับการเปรียบเทียบค่าได้ ดังตัวอย่าง, ไม่ควรเขียนโค้ดแบบนี้</div>

<div> </div>

<pre class="brush: js">if (x = y) {
  /* do the right thing */
}
</pre>

<p>ถ้าคุณจำเป็นต้องกำหนดค่าในนิพจน์เงื่อนไข, วิธีที่ใช้กันคือ ใส่วงเล็บครอบไปอีกชั้น เช่นตัวอย่างนี้:</p>

<pre class="brush: js">if ((x = y)) {
  /* do the right thing */
}
</pre>

<p>ค่าต่อไปนี้ เมื่อนำมาหาค่าแล้วจะได้ค่า <code>false</code> :</p>

<ul>
 <li><code>false</code></li>
 <li><code>undefined</code></li>
 <li><code>null</code></li>
 <li><code>0</code></li>
 <li><code>NaN</code></li>
 <li>สตริงว่าง (<code>""</code>)</li>
</ul>

<p>สำหรับค่าอื่นๆ รวมทั้งอ็อบเจ็กต์ทุกตัว, เมื่อนำมาหาค่าในคำสั่งเงื่อนไข จะได้ค่า <code>true</code> เสมอ</p>

<p>อย่าสับสนกับค่าข้อมูลตรรกะพื้นฐาน <code>true</code> และ <code>false</code> กับค่าที่ได้จากอ็อบเจกต์ Boolean ดังตัวอย่าง</p>

<pre class="brush: js">var b = new Boolean(false);
if (b) // this condition evaluates to true
</pre>

<p><strong>Example</strong><br>
 ในตัวอย่างต่อไปนี้, ฟังก์ชัน <code>checkData</code> จะคืนค่า <code>true</code> ถ้าอ็อบเจกต์ <code>threeChar</code> มีข้อความยาวสามอักขระ, นอกจากนั้นจะแสดงคำเตือน และคืนค่า <code>false</code></p>

<pre class="brush: js">function checkData() {
  if (document.form1.threeChar.value.length == 3) {
    return true;
  } else {
    alert("Enter exactly three characters. " +
      document.form1.threeChar.value + " is not valid.");
    return false;
  }
}
</pre>

<h3 id="คำสั่ง_switch">คำสั่ง switch</h3>

<p>คำสั่ง <code>switch</code> ทำงานโดยนำค่าของนิพจน์มาจับคู่กับค่าที่กำหนด ถ้าตรงกัน, โปรแกรมจะทำงานตามคำสั่งที่เกี่ยวข้อง คำสั่ง <code>switch</code> มีรูปแบบการใช้ดังนี้:</p>

<pre class="brush: js">switch (expression) {
   case label_1:
      statements_1
      [break;]
   case label_2:
      statements_2
      [break;]
   ...
   default:
      statements_def
      [break;]
}
</pre>

<p>เริ่มจากโปรแกรมมองหาประโยค <code>case</code> ที่มีค่าตรงกับค่าจากนิพจน์ (<code>expression</code>) และข้ามไปทำงานที่ตำแหน่งนั้นตามคำสั่งที่กำหนด ถ้าไม่พบค่าที่ตรงกัน, โปรแกรมจะมองหาประโยค <code>default</code> และทำงานที่ตำแหน่งนั้นตามคำสั่งที่กำหนด ถ้าไม่พบประโยค <code>default</code>, โปรแกรมจะทำงานต่อที่ตำแหน่งถัดจากคำสั่ง <code>switch</code> ซึ่งตามหลักการแล้ว, ประโยค <code>default</code> ควรอยู่ท้ายสุด แต่ก็ไม่จำเป็นเสมอไป</p>

<p>คำสั่ง <code>break</code> ที่ใส่ไว้ในประโยค <code>case</code> จะทำให้โปรแกรมหยุดทำงานและออกจากคำสั่ง <code>switch</code> แล้วทำงานต่อที่ตำแหน่งถัดจากคำสั่ง <code>switch</code> แต่ถ้าไม่มี <code>break</code>, โปรแกรมจะทำงานต่อที่คำสั่งถัดไปใน <code>switch</code></p>

<p>ตัวอย่าง<br>
 ในตัวอย่างต่อไปนี้, ถ้า <code>fruttype</code> มีค่าเป็น <code>"Bananas"</code> โปรแกรมจะพบค่าที่ตรงกันในประโยค <code>case "Bananas"</code> และข้ามไปทำงานที่ตำแหน่งนั้น จนถึงคำสั่ง <code>break</code> โปรแกรมก็จะหยุดทำงานแล้วทำงานต่อที่ตำแหน่งถัดจากคำสั่ง <code>switch</code> แต่ถ้าไม่มี <code>break</code>, โปรแกรมจะทำงานต่อที่คำสั่งถัดมาในประโยค <code>case "Cherries"</code> ด้วย</p>

<pre class="brush: js">switch (fruittype) {
   case "Oranges":
      document.write("Oranges are $0.59 a pound.&lt;br&gt;");
      break;
   case "Apples":
      document.write("Apples are $0.32 a pound.&lt;br&gt;");
      break;
   case "Bananas":
      document.write("Bananas are $0.48 a pound.&lt;br&gt;");
      break;
   case "Cherries":
      document.write("Cherries are $3.00 a pound.&lt;br&gt;");
      break;
   case "Mangoes":
   case "Papayas":
      document.write("Mangoes and papayas are $2.79 a pound.&lt;br&gt;");
      break;
   default:
      document.write("Sorry, we are out of " + fruittype + ".&lt;br&gt;");
}
document.write("Is there anything else you'd like?&lt;br&gt;");</pre>

<h2 id="คำสั่งลูป">คำสั่งลูป</h2>

<p>คำสั่งลูป คือชุดคำสั่งที่ทำงานซ้ำจนกระทั่งเงื่อนไขที่กำหนดเป็นจริง โดยจาวาสคริปต์รองรับคำสั่งลูป <code>for</code>, <code>do...while</code>, และ <code>while</code> และป้ายชื่อคำสั่ง (ซึ่งไม่ใช่คำสั่งลูป แต่มักใช้คู่กัน) นอกจากนี้, คุณยังสามารถใช้คำสั่ง <code>break</code> และ <code>continue</code> กับคำสั่งลูปได้ด้วย</p>

<p>อีกคำสั่งหนึ่งคือ <code>for...in</code>, เป็นคำสั่งที่ทำงานวนซ้ำเหมือนกัน แต่ใช้กับการจัดการอ็อบเจกต์ ดูเพิ่มเติมที่ <a href="#Object_Manipulation_Statements">Object Manipulation Statements</a></p>

<p>คำสั่งลูปทั้งหมด มีดังนี้:</p>

<ul>
 <li><a href="#for_Statement">for Statement</a></li>
 <li><a href="#do...while_Statement">do...while Statement</a></li>
 <li><a href="#while_Statement">while Statement</a></li>
 <li><a href="#label_Statement">label Statement</a></li>
 <li><a href="#break_Statement">break Statement</a></li>
 <li><a href="#continue_Statement">continue Statement</a></li>
</ul>

<h3 id="คำสั่ง_for">คำสั่ง for</h3>

<p>คำสั่งลูป <code>for</code> จะทำงานซ้ำจนกระทั่งเงื่อนไขที่กำหนดเป็นเท็จ (<code>false</code>) โดย <code>for</code> ในจาวาสคริปต์ทำงานคล้าย <code>for</code> ในภาษาจาวาและซี ซึ่งมีรูปแบบการใช้งานดังนี้:</p>

<pre class="brush: js">for ([initialExpression]; [condition]; [incrementExpression])
   statement
</pre>

<p>เมื่อคำสั่ง <code>for</code> ทำงาน, สิ่งที่เกิดขึ้นคือ:</p>

<ol>
 <li>ถ้ามีนิพจน์ <code>initialExpression</code>, จะมีการประมวลค่านิพจน์นี้ ซึ่งโดยทั่วไปจะใช้เพื่อกำหนดค่าเริ่มต้นให้กับตัวแปร ตัวเดียวหรือหลายตัว แต่ก็สามารถใช้กับนิพจน์ที่มีความซับซ้อน และใช้ประกาศตัวแปรได้</li>
 <li>ทำการประมวลค่านิพจน์ <code>condition</code>, ถ้ามีค่าเป็นจริง (<code>true</code>) คำสั่งในลูปทั้งหมดจะทำงาน แต่ถ้ามีค่าเท็จ (<code>false</code>) ลูป for จะหยุดทำงาน และถ้าไม่มีนิพจน์ <code>condition</code> เลย, ค่าเงื่อนไขนี้จะถูกสมมุติให้เป็นจริง (<code>true</code>)</li>
 <li>คำสั่ง <code>statement</code> เริ่มทำงาน, ถ้าต้องการทำงานหลายคำสั่ง ต้องใช้บล็อกคำสั่ง (<code>( ... )</code>) หุ้มอีกชั้น</li>
 <li>ถ้ามีนิพจน์ <code>incrementExpression</code>, จะมีการประมวลค่านิพจน์นี้ และกลับไปทำงานที่ขั้นตอนที่ 2</li>
</ol>

<p>ตัวอย่าง<br>
 ฟังก์ชันต่อไปนี้ประกอบด้วยคำสั่ง <code>for</code> ซึ่งใช้นับจำนวนตัวเลือกที่ถูกเลือกในรายการข้อมูล (อ็อบเจกต์ <code>Select</code> ยอมให้เลือกได้หลายค่า) โดยคำสั่ง <code>for</code> ประกาศตัวแปร <code>i</code> และกำหนดค่าเริ่มต้นเป็นศูนย์ จากนั้นจะตรวจสอบว่า <code>i</code> ยังมีค่าน้อยกว่าจำนวนตัวเลือกในอ็อบเจกต์ <code>Select</code> แล้วจึงทำตามคำสั่ง <code>if</code> ที่กำหนด และเพิ่มค่า <code>i</code> ทีละหนึ่งทุกครั้งที่ครบลูป</p>

<pre class="brush: html">&lt;script&gt;

function howMany(selectObject) {
   var numberSelected = 0;
   for (var i = 0; i &lt; selectObject.options.length; i++) {
      if (selectObject.options[i].selected)
         numberSelected++;
   }
   return numberSelected;
}

&lt;/script&gt;

&lt;form name="selectForm"&gt;
   &lt;p&gt;
      &lt;strong&gt;Choose some music types, then click the button below:&lt;/strong&gt;
      &lt;br/&gt;
      &lt;select name="musicTypes" multiple="multiple"&gt;
         &lt;option selected="selected"&gt;R&amp;B&lt;/option&gt;
         &lt;option&gt;Jazz&lt;/option&gt;
         &lt;option&gt;Blues&lt;/option&gt;
         &lt;option&gt;New Age&lt;/option&gt;
         &lt;option&gt;Classical&lt;/option&gt;
         &lt;option&gt;Opera&lt;/option&gt;
      &lt;/select&gt;
   &lt;/p&gt;
   &lt;p&gt;
      &lt;input type="button" value="How many are selected?"
         onclick="alert ('Number of options selected: ' + howMany(document.selectForm.musicTypes))"/&gt;
   &lt;/p&gt;
&lt;/form&gt;</pre>

<h3 id="คำสั่ง_do...while">คำสั่ง do...while</h3>

<p>คำสั่ง <code>do...while</code> จะทำงานซ้ำจนกระทั่งเงื่อนไขที่กำหนดเป็นเท็จ (<code>false</code>) โดยมีรูปแบบการใช้งานดังนี้:</p>

<pre class="brush: js">do
   statement
while (condition);
</pre>

<p>คำสั่ง <code>statement</code> จะทำงานหนึ่งครั้งก่อนที่จะมีการตรวจสอบเงื่อนไข ถ้าต้องการทำงานหลายคำสั่ง ต้องใช้บล็อกคำสั่ง (<code>{ ... }</code>) หุ้มอีกชั้น เมื่อเงื่อนไข <code>condition</code> เป็นจริง (<code>true</code>), คำสั่ง <code>statement</code> จะทำงานอีกครั้ง โดยทุกครั้งที่จบการทำงานจะทำการตรวจสอบเงื่อนไข เมื่อเงื่อนไขเป็นเท็จ (<code>false</code>), การทำงานจะหยุดและข้ามไปทำต่อที่คำสั่งถัดจาก <code>do...while</code></p>

<p>ตัวอย่าง<br>
 ในตัวอย่างต่อไปนี้, ลูป <code>do</code> จะทำงานซ้ำอย่างน้อยหนึ่งครั้ง และทำซ้ำอีกจนกระทั่ง <code>i</code> มีค่าไม่น้อยกว่า <code>5</code></p>

<pre class="brush: js">do {
   i += 1;
   document.write(i);
} while (i &lt; 5);</pre>

<h3 id="คำสั่ง_while">คำสั่ง while</h3>

<p>คำสั่ง <code>while</code> จะทำงานเมื่อเงื่อนไขที่กำหนดเป็นจริง (<code>true</code>) โดยมีรูปแบบการใช้งานดังนี้:</p>

<pre class="brush: js">while (condition)
   statement
</pre>

<p>ถ้าเงื่อนไขกลายเป็นเท็จ (<code>false</code>), คำสั่งในลูปจะหยุดทำงานและข้ามไปทำงานต่อที่คำสั่งถัดจากลูป</p>

<p>การทดสอบเงื่อนไขจะเกิดขี้นก่อนคำสั่ง <code>statement</code> ในลูปเริ่มทำงาน เมื่อเงื่อนไขเป็นจริง (<code>true</code>), คำสั่ง <code>statement</code> จะทำงาน และเงื่อนไขจะถูกทดสอบอีกครั้ง จนเมื่อเงื่อนไขเป็นเท็จ (<code>false</code>) การทำงานจะหยุดและข้ามไปทำงานต่อที่คำสั่งถัดจาก <code>while</code></p>

<p>ถ้าต้องการทำงานหลายคำสั่ง, ให้ใช้บล็อกคำสั่ง (<code>{ ... }</code>) หุ้มอีกชั้น</p>

<p><strong>ตัวอย่างที่ 1</strong><br>
 ลูป <code>while</code> ต่อไปนี้ จะทำงานซ้ำเมื่อ <code>n</code> ยังน้อยกว่า <code>3</code>:</p>

<pre class="brush: js">n = 0;
x = 0;
while (n &lt; 3) {
   n++;
   x += n;
}
</pre>

<p>ในแต่ละรอบของการทำซ้ำ, ลูปจะเพิ่มค่า <code>n</code> และบวกค่าให้ <code>x</code>, นั่นคือ <code>x</code> และ <code>n</code> จะมีค่าดังนี้:</p>

<ul>
 <li>หลังจากผ่านรอบแรกไป: <code>n = 1</code> และ <code>x = 1</code></li>
 <li>หลังจากผ่านไปสองรอบ: <code>n = 2</code> และ <code>x = 3</code></li>
 <li>หลังจากผ่านไปสามรอบ: <code>n = 3</code> และ <code>x = 6</code></li>
</ul>

<p>หลังจากจบรอบสาม, เงื่อนไขที่ <code>n &lt; 3</code> ไม่เป็นจริงอีกแล้ว, ลูปจึงหยุดทำงาน</p>

<p><strong>ตัวอย่างที่ 2</strong><br>
 เพื่อหลีกเลี่ยงการวนลูปแบบไม่สิ้นสุด, ต้องแน่ใจว่าเงื่อนไขในลูปจะกลายเป็นเท็จ (<code>false</code>) ได้ในที่สุด มิเช่นนั้นลูปจะทำงานไม่หยุด เช่น คำสั่งในลูป <code>while</code> ต่อไปนี้จะทำงานไปตลอดเพราะเงื่อนไขไม่เคยเป็นเท็จ (<code>false</code>)</p>

<pre class="brush: js">while (true) {
   alert("Hello, world");
}</pre>

<h3 id="ป้ายชื่อคำสั่ง">ป้ายชื่อคำสั่ง</h3>

<p>การกำหนดป้ายชื่อคำสั่ง คือการติดป้ายชื่อที่คำสั่งใดๆเพื่อช่วยให้คุณอ้างถึงมันได้จากที่ต่างๆในโปรแกรม ตัวอย่าง เช่น, คุณสามารถติดป้ายชื่อที่คำสั่งลูป และใช้คำสั่ง <code>break</code> หรือ <code>continue</code> เพื่อให้โปรแกรมหยุดการทำงานและออกจากลูป หรือทำงานต่อที่ลูปนั้น</p>

<p>รูปแบบการติดป้ายชื่อที่คำสั่ง มีวิธีดังนี้:</p>

<pre class="brush: js">label :
   statement
</pre>

<p>โดย <code>label</code> คือป้ายชื่อคำสั่ง ตั้งชื่อตามแบบตัวแปรในจาวาสคริปต์ ซึ่งไม่สามารถใช้คำสงวนได้ โดยคำสั่ง <code>statement</code> ที่กำหนดคู่กับป้ายชื่อ <code>label</code> จะเป็นคำสั่งแบบใดก็ได้</p>

<p>ตัวอย่าง<br>
 ในตัวอย่างนี้, <code>markLoop</code> คือป้ายชื่อที่ตั้งให้ลูป <code>while</code></p>

<pre class="brush: js">markLoop:
while (theMark == true) {
   doSomething();
}</pre>

<h3 id="คำสั่ง_break">คำสั่ง break</h3>

<p>ใช้คำสั่ง <code>break</code> เพื่อหยุดการทำงานในลูป, <code>switch</code>, หรือใช้ร่วมกับป้ายชื่อคำสั่ง</p>

<ul>
 <li>เมื่อคุณใช้ <code>break</code> โดยไม่ระบุป้ายชื่อคำสั่ง, มันจะหยุดการทำงานของคำสั่งชั้นในสุดของ <code>while</code>, <code>do-while</code>, <code>for</code>, หรือ <code>switch</code> ทันทีและข้ามออกมาทำงานในคำสั่งถัดไป</li>
 <li>เมื่อคุณใช้ <code>break</code> และระบุป้ายชื่อคำสั่ง, มันจะหยุดการทำงานของคำสั่งตามป้ายชื่อนั้น</li>
</ul>

<p>รูปแบบของคำสั่ง break เป็นดังนี้:</p>

<ol>
 <li><code>break;</code></li>
 <li><code>break <em>label</em>;</code></li>
</ol>

<p>รูปแบบแรกจะหยุดการทำงานของลูปในสุด หรือใน switch, ส่วนแบบที่สอง จะหยุดการทำงานของคำสั่งทีี่มีป้ายชื่อ <code><em>label</em></code></p>

<p><strong>ตัวอย่างที่</strong> <strong>1:</strong><br>
 ตัวอย่างต่อไปนี้ ทำงานซ้ำตามจำนวนสมาชิกในอาร์เรย์ จนกระทั่งพบตำแหน่งของสมาชิกที่มีค่าเท่ากับ <code>theValue</code></p>

<pre class="brush: js">for (i = 0; i &lt; a.length; i++) {
   if (a[i] == theValue)
      break;
}</pre>

<p><strong>ตัวอย่างที่ 2: </strong>หยุดทำงานของคำสั่งตามป้ายชื่อที่กำหนด</p>

<pre class="brush: js">var x = 0;
var z = 0
labelCancelLoops: while (true) {
    console.log("Outer loops: " + x);
    x += 1;
    z = 1;
    while (true) {
        console.log("Inner loops: " + z);
        z += 1;
        if (z === 10 &amp;&amp; x === 10) {
            break labelCancelLoops;
        } else if (z === 10) {
            break;
        }
    }
}
</pre>

<h3 id="คำสั่ง_continue">คำสั่ง continue</h3>

<p>คำสั่ง <code>continue</code> ใช้เพื่อเริ่มการทำงานใหม่ของคำสั่ง <code>while</code>, <code>do-while</code>, <code>for</code>, หรือที่ป้ายชื่อคำสั่ง:</p>

<ul>
 <li>เมื่อคุณใช้ <code>continue</code> โดยไม่ระบุป้ายชื่อคำสั่ง, มันจะหยุดการทำงานรอบปัจจุบันที่ชั้นในสุดของคำสั่ง <code>while</code>, <code>do-while</code> หรือคำสั่ง <code>for</code> และเริ่มทำงานลูปใหม่ในรอบถัดไป ที่ตรงข้ามกับคำสั่ง <code>break</code> คือ <code>continue</code> จะไม่หยุดการทำงานของลูปทั้งหมด โดยในลูป <code>while</code>, มันจะข้ามไปทำงานที่ตำแหน่งเงื่อนไข และในลูป <code>for</code>, มันจะข้ามไปทำงานที่ส่วน <code>increment-expression</code></li>
 <li>เมื่อคุณใช้ <code>continue</code> กับป้ายชื่อคำสั่ง, มันจะถูกใช้กับคำสั่งลูปที่มีป้ายชื่อตามที่กำหนด</li>
</ul>

<p>รูปแบบของคำสั่ง continue เป็นได้ดังนี้:</p>

<ol>
 <li><code>continue;</code></li>
 <li><code>continue </code><em><code>label;</code></em></li>
</ol>

<p><strong>ตัวอย่างที่ 1</strong><br>
 ตัวอย่างต่อไปนี้แสดง ลูป while ที่มีคำสั่ง continue ซึ่งจะทำงานเมื่อ i เป็น 3 นั่นคือ n จะมีค่าเป็น หนึ่ง, สาม, เจ็ด, และสิบสอง</p>

<pre class="brush: js">i = 0;
n = 0;
while (i &lt; 5) {
   i++;
   if (i == 3)
      continue;
   n += i;
}
</pre>

<p><strong>ตัวอย่า</strong><strong>งที่ 2</strong><br>
 โปรแกรมต่อไปนี้ มีคำสั่ง <code>while</code> ติดป้ายชื่อ <code>checkiandj</code> ที่ภายในมีคำสั่ง <code>while</code> ติดป้ายชื่อ <code>checkj</code> เมื่อโปรแกรมทำงานถึงคำสั่ง <code>continue</code>, โปรแกรมจะหยุดการทำงานรอบปัจจุบันของ <code>checkj</code> และเริ่มทำงานในรอบถัดไป โดยทุกครั้งที่ทำงานถึง <code>continue</code> โปรแกรมก็จะกลับไปเริ่มทำงาน <code>checkj</code> รอบใหม่จนกระทั่งได้เงื่อนไขที่เป็นเท็จ (<code>false</code>) ซึ่งทำให้โปรแกรมหลุดออกจากลูป <code>checkj</code> เข้ามาในลูปใหญ่ <code>checkiandj</code> และทำงานต่อจนจบลูป จากนั้น <code>checkiandj</code> <code>ก็</code>ทำงานซ้ำจนได้เงื่อนไขที่เป็นเท็จ (<code>false</code>) ซึ่งทำให้โปรแกรมหลุดออกจากลูป <code>checkiandj</code> และทำงานที่คำสั่งถัดไป</p>

<p>แต่ถ้า <code>continue</code> ระบุป้ายชื่อ <code>checkiandj</code>, โปรแกรมก็จะทำงานต่อที่ส่วนบนสุดของคำสั่ง <code>checkiandj</code> แทน</p>

<pre class="brush: js">checkiandj :
   while (i &lt; 4) {
      document.write(i + "&lt;br/&gt;");
      i += 1;
      checkj :
         while (j &gt; 4) {
            document.write(j + "&lt;br/&gt;");
            j -= 1;
            if ((j % 2) == 0)
               continue checkj;
            document.write(j + " is odd.&lt;br/&gt;");
         }
      document.write("i = " + i + "&lt;br/&gt;");
      document.write("j = " + j + "&lt;br/&gt;");
   }</pre>

<h2 id="คำสั่งจัดการอ็อบเจกต์">คำสั่งจัดการอ็อบเจกต์</h2>

<p>จาวาสคริปต์ใช้คำสั่ง <code>for...in</code>, <code>for each...in</code>, และ <code>with</code> ในการจัดการกับอ็อบเจกต์</p>

<h3 id="คำสั่ง_for...in">คำสั่ง for...in</h3>

<p>คำสั่ง <a href="/en-US/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> จะทำงานซ้ำตามจำนวนคุณสมบัติของอ็อบเจกต์ โดยในแต่ละรอบ,ตัวแปรจะถูกกำหนดให้มีค่าเป็นคุณสมบัติของอ็อบเจกต์ทีละตัว และจาวาสคริปต์จะทำงานตามคำสั่งที่กำหนด จนครบตามจำนวนคุณสมบัติที่ต่างกันทั้งหมด โดยมีรูปแบบต่อไปนี้:</p>

<pre class="brush: js">for (variable in object) {
   statements
}
</pre>

<p><strong>ตัวอย่าง</strong><br>
 ฟังก์ชันต่อไปนี้ รับค่าพารามิเตอร์ อ็อบเจกต์และชื่ออ็อบเจกต์ โดยจะทำงานซ้ำตามคุณสมบัติทั้งหมดของอ็อบเจกต์ และคืนค่าสตริงที่แสดงชื่อคุณสมบัติกับค่าของมัน</p>

<pre class="brush: js">function dump_props(obj, obj_name) {
   var result = "";
   for (var i in obj) {
      result += obj_name + "." + i + " = " + obj[i] + "&lt;br&gt;";
   }
   result += "&lt;hr&gt;";
   return result;
}
</pre>

<p>เมื่อใช้กับอ็อบเจกต์ <code>car</code> ที่มีคุณสมบัติ <code>make</code> และ <code>model</code>, จะได้ค่า <code>result</code> ดังนี้:</p>

<pre class="brush: js">car.make = Ford
car.model = Mustang
</pre>

<p><strong>อา์เรย์</strong><br>
 แม้ว่าเราอยากจะใช้วิธีนี้เพื่อวนซ้ำตามจำนวนสมาชิกของอ็อบเจกต์อาร์เรย์, แต่เนื่องจากคำสั่ง <code>for...in</code> นอกจากจะทำงานซ้ำตามจำนวนสมาชิกอาร์เรย์แล้ว ยังทำงานซ้ำตามจำนวนคุณสมบัติของอาร์เรย์ด้วย ดังนั้นถ้าคุณแก้ไขอ็อบเจกต์อาร์เรย์ โดยเพิ่มคุณสมบัติหรือเมธอดเข้าไป, คำสั่ง <code>for...in</code> จะทำงานซ้ำด้วยจำนวนครั้งที่รวมจำนวนคุณสมบัติและจำนวนสมาชิกเข้าด้วยกัน ด้วยเหตุนี้, วิธีที่ดีกว่าคือใช้คำสั่ง <code>for</code> แบบปกติ และทำการวนซ้ำด้วยเลขตำแหน่งของสมาชิกในอาร์เรย์</p>

<h3 id="คำสั่ง_for_each...in">คำสั่ง for each...in</h3>

<p><a href="/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in"><code>for each...in</code></a> เป็นคำสั่งลูปที่เริ่มมีใน <a href="/en-US/docs/Web/JavaScript/New_in_JavaScript/1.6">JavaScript 1.6</a> มีการทำงานคล้าย <code>for...in</code> แต่ค่าที่วนซ้ำเป็นค่าของคุณสมบัติอ็อบเจกต์, ไม่ใช่ตัวคุณสมบัติ</p>

<pre class="brush: js">var sum = 0;
var obj = {prop1: 5, prop2: 13, prop3: 8};
for each (var item in obj) {
  sum += item;
}
print(sum); // prints "26", which is 5+13+8</pre>

<h2 id="คำอธิบาย">คำอธิบาย</h2>

<p>คำอธิบาย คือข้อความที่ผู้แต่งเขียนไว้เพื่ออธิบายการทำงานของสคริปต์ ซึ่งไม่ถูกอ่านโดยตัวแปลภาษา โดยจาวาสคริปต์รองรับคำอธิบายในแบบภาษาจาวาและซีพลัสพลัสดังนี้:</p>

<ul>
 <li>คำอธิบายบรรทัดเดียว ให้เริ่มต้นด้วย <code>//</code></li>
 <li>คำอธิบายที่มีหลายบรรทัด ให้นำหน้าด้วย <code>/*</code> และปิดท้ายด้วย <code>*/</code></li>
</ul>

<p><strong>ตัวอย่าง</strong><br>
 ตัวอย่างต่อไปนี้ แสดงการเขียนคำอธิบายทั้งสองแบบ</p>

<pre class="brush: js">// This is a single-line comment.

/* This is a multiple-line comment. It can be of any length, and
you can put whatever you want here. */</pre>

<h2 id="คำสั่งจัดการข้อผิดพลาด">คำสั่งจัดการข้อผิดพลาด</h2>

<p>คุณสามารถสร้างข้อผิดพลาดในโปรแกรม ด้วยการใช้คำสั่ง <code>throw</code> และจัดการมันด้วยคำสั่ง <code>try...catch</code></p>

<p>คุณยังสามารถใช้ <code>try...catch</code> เพื่อจัดการข้อผิดพลาดของจาวาได้ (แม้ว่าจะมี {{ bug("391642") }} ก็ตาม) โดยดูข้อมูลเพิ่มเติมได้ที่ <a href="/en-US/docs/Web/JavaScript/Guide/LiveConnect_Overview#Handling_Java_Exceptions_in_JavaScript">Handling Java Exceptions in JavaScript</a> และ <a href="/en-US/docs/Web/JavaScript/Guide/LiveConnect_Overview#JavaScript_to_Java_Communication">JavaScript to Java Communication</a></p>

<ul>
 <li><a href="#throw_Statement">throw Statement</a></li>
 <li><a href="#try...catch_Statement">try...catch Statement</a></li>
</ul>

<h3 id="ชนิดของข้อผิดพลาด">ชนิดของข้อผิดพลาด</h3>

<p>เราสามารถสร้างข้อผิดพลาดจากอ็อบเจกต์ชนิดใดก็ได้ แต่อย่างไรก็ตาม, อ็อบเจกต์ทุกตัวไม่ได้ถูกสร้างมาให้เท่าเทียมกัน ในกรณีทั่วไปอาจใช้แค่ตัวเลขหรือสตริงแทนข้อผิดพลาดได้ แต่เพิ่อประสิทธิภาพที่ดีกว่า เรามักจะใช้รูปแบบข้อผิดพลาดที่สร้างขึ้นโดยเฉพาะดังนี้:</p>

<ul>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Global_Objects#Error_constructors">ECMAScript exceptions</a></li>
 <li>{{domxref("DOMException")}}</li>
 <li><a href="/en-US/docs/XPCOM_Interface_Reference/nsIXPCException">nsIXPCException</a> (<a href="/en-US/docs/XPConnect">XPConnect</a>)</li>
</ul>

<h3 id="คำสั่ง_throw">คำสั่ง throw</h3>

<p>ใช้คำสั่ง <code>throw</code> เพื่อสร้างข้อผิดพลาด โดยให้ระบุนิพจน์แทนข้อผิดพลาด คู่กับคำสั่งดังนี้:</p>

<pre class="brush: js">throw expression;
</pre>

<p>คุณอาจสร้างข้อผิดพลาดด้วยนิพจน์แบบใดก็ได้ ไม่ใช่แค่นิพจน์ของข้อมูลแบบใดแบบหนึ่งเท่านั้น ในโค้ดต่อไปนี้แสดงการสร้างข้อผิดพลาดด้วยข้อมูลที่แตกต่างชนิดกัน</p>

<pre class="brush: js">throw "Error2";   //String type
throw 42;         //Number type
throw true;       //Boolean type
throw {toString: function() { return "I'm an object!"; } };
</pre>

<div class="note"><strong>Note:</strong> คุณสามารถระบุอ็อบเจกต์เมื่อคุณสร้างข้อผิดพลาดขึ้น จากนั้นสามารถอ้างถึงคุณสมบัติของอ็อบเจกต์นั้นได้จากในบล็อกคำสั่ง <code>catch</code> โดยตัวอย่างต่อไปนี้ มีการสร้างอ็อบเจกต์ <code>myUserException</code> ที่มีชนิด <code>UserException</code> และใช้ในคำสั่ง <code>throw</code></div>

<pre class="brush: js">// Create an object type UserException
function UserException (message){
  this.message=message;
  this.name="UserException";
}

// Make the exception convert to a pretty string when used as a string (e.g. by the error console)
UserException.prototype.toString = function (){
  return this.name + ': "' + this.message + '"';
}

// Create an instance of the object type and throw it
throw new UserException("Value too high");</pre>

<h3 id="คำสั่ง_try...catch">คำสั่ง try...catch</h3>

<p>คำสั่ง <code>try...catch</code> กำหนดบล็อกของคำสั่งที่จะทำงาน และกำหนดการตอบสนองต่อข้อผิดพลาดหนึ่งชนิดขึ้นไป โดยเมื่อมีข้อผิดพลาดเกิดขึ้น, คำสั่ง <code>try...catch</code> ก็สามารถจัดการมันได้</p>

<p>คำสั่ง <code>try...catch</code> ประกอบด้วย บล็อก <code>try</code> ที่มีคำสั่งหนึ่งคำสั่งหรือมากกว่า และบล็อก <code>catch</code> มากกว่าหนึ่งหรือไม่มีเลย ในบล็อกนี้จะมีคำสั่งที่ระบุว่าให้ทำอะไรถ้ามีข้อผิดพลาดเกิดขึ้นในบล็อก try นั่นคือคุณต้องการให้คำสั่งในบล็อก <code>try</code> ทำงานสำเร็จ, แต่เมื่อทำไม่สำเร็จ คุณต้องการส่งต่อการทำงานไปที่บล๊อก <code>catch</code> โดยเมื่อคำสั่งใดๆในบล็อก <code>try</code> (หรือในการเรียกใช้ฟังก์ชันจากภายในบล็อก <code>try</code>) สร้างข้อผิดพลาดขึ้น การทำงานของโปรแกรมจะข้ามไปที่บล็อก <code>catch</code> ทันที แต่ถ้าไม่มีข้อผิดพลาดเกิดขึ้นในบล็อก <code>try</code>, โปรแกรมจะข้ามบล็อก <code>catch</code> ไป และจากนั้นบล๊อก <code>finally</code> จะทำงานหลังจากบล็อก <code>try</code> และ <code>catch</code> ทำงานจบแล้ว ก่อนที่จะทำงานในคำสั่งถัดจากคำสั่ง <code>try...catch</code> ต่อไป</p>

<p>ตัวอย่างต่อไปนี้ แสดงการใช้คำสั่ง <code>try...catch</code> โดยตัวอย่างเรียกใช้ฟังก์ชันซึ่งรับชื่อเดือนจากอาร์เรย์ตามค่าเดือนที่ส่งให้ฟังก์ชัน ถ้าค่านี้ไม่สอดคล้องกับจำนวนเดิอน (1-12), จะเกิดข้อผิดพลาดขึ้นเป็นข้อความ <code>"InvalidMonthNo"</code> และคำสั่งในบล็อก <code>catch</code> จะกำหนดค่าให้ ตัวแปร <code>monthName</code> เป็น <code>unknown</code></p>

<pre class="brush: js">function getMonthName (mo) {
    mo=mo-1; // Adjust month number for array index (1=Jan, 12=Dec)
    var months=new Array("Jan","Feb","Mar","Apr","May","Jun","Jul",
          "Aug","Sep","Oct","Nov","Dec");
    if (months[mo] != null) {
       return months[mo]
    } else {
       throw "InvalidMonthNo"          //throw keyword is used here
    }
}

try {// statements to try
    monthName=getMonthName(myMonth) // function could throw exception
}
catch (e) {
    monthName="unknown"
    logMyErrors(e) // pass exception object to error handler
}
</pre>

<h4 id="The_catch_Block" name="The_catch_Block">บล็อก catch</h4>

<p>คุณสามารถใช้บล็อก <code>catch</code> เพื่อจัดการข้อผิดพลาดที่อาจเกิดขึ้นในบล็อก <code>try</code> ได้</p>

<pre class="brush: js">catch (catchID) {
  statements
}
</pre>

<p>บล็อก <code>catch</code> กำหนดชื่อตัวแปร (<code>catchID</code> ในรูปแบบด้านบน) ซึ่งเก็บค่าที่มาจากคำสั่ง <code>throw</code> คุณสามารถใช้ตัวแปรนี้เพื่อดึงข้อมูลเกี่ยวกับข้อผิดพลาดที่เกิดขึ้นได้ โดยจาวาสคริปต์จะสร้างตัวแปรนี้เมื่อบล็อก <code>catch</code> เริ่มทำงาน  และหลังจากที่บล็อก <code>catch</code> ทำงานเสร็จแล้ว ตัวแปรนี้จะหายไป</p>

<p>ตัวอย่าง,  โค้ดต่อไปนี้ทำให้เกิดข้อผิดพลาดขึ้น เมื่อมีข้อผิดพลาดเกิดขึ้น การทำงานจะถูกโอนไปที่บล๊อก <code>catch</code></p>

<pre class="brush: js">try {
   throw "myException" // generates an exception
}
catch (e) {
// statements to handle any exceptions
   logMyErrors(e) // pass exception object to error handler
}
</pre>

<h4 id="บล็อก_finally">บล็อก finally</h4>

<p>บล็อก <code>finally</code> ประกอบด้วย ชุดคำสั่งที่ทำงานหลังจากบล็อก <code>try</code> และ <code>catch</code> ทำงานแล้ว ก่อนที่คำสั่งถัดจาก <code>try...catch</code> จะทำงาน โดยบล็อก <code>finally</code> จะทำงานไม่ว่าจะมีข้อผิดพลาดเกิดขึ้นหรือไม่ ซึ่งคำสั่งในบล็อก <code>finally</code> นี้จะทำงานแม้ว่าบล๊อก <code>catch</code> จะไม่ได้ทำงานก็ตาม</p>

<p>คุณสามารถใช้บล็อก <code>finally</code> เพื่อให้สคริปต์ทำงานจนจบได้แม้จะมีข้อผิดพลาดเกิดขึ้น ตัวอย่าง เช่น, คุณอาจจำเป็นต้องปลด <code>resource</code> เมื่อสคริปต์ทำงานจบ ในตัวอย่างต่อไปนี้ เมื่อเปิดไฟล์และทำงานกับไฟล์ (จาวาสคริปต์บน <code>server</code> ยอมให้คุณเข้าถึงไฟล์ได้) ถ้ามีข้อผิดพลาดเกิดขึ้นตอนเปิดไฟล์ บล็อก <code>finally</code> สามารถปิดไฟล์ได้ก่อนที่สคริปต์จะทำงานผิดพลาด</p>

<pre class="brush: js">openMyFile();
try {
    writeMyFile(theData); //This may throw a error
}catch(e){
    handleError(e); // If we got a error we handle it
}finally {
    closeMyFile(); // always close the resource
}
</pre>

<p>ถ้าบล็อก <code>finally</code> คืนค่ากลับมา, ค่านี้จะกลายเป็นผลลัพธ์จาก <code>try-catch-finally</code> โดยไม่สนใจว่าคำสั่ง <code>return</code> ในบล็อก <code>try</code> และ <code>catch</code> จะคืนค่าอะไร</p>

<pre class="brush: js">function f() {
    try {
        alert(0);
        throw "bogus";
    } catch(e) {
        alert(1);
        return true; // this return statement is suspended until finally block has completed
        alert(2); // not reachable
    } finally {
        alert(3);
        return false; // overwrites the previous "return"
        alert(4); // not reachable
    }
    // "return false" is executed now
    
    alert(5); // not reachable
}
f(); // alerts 0, 1, 3; returns false
</pre>

<h4 id="Nesting_try...catch_Statements" name="Nesting_try...catch_Statements">การซ้อนกันของคำสั่ง try...catch</h4>

<p>คุณอาจซ้อนคำสั่ง <code>try...catch</code> เข้าด้วยกันได้ ถ้าคำสั่ง <code>try...catch</code> ชั้นใน ไม่มีบล็อก <code>catch</code>, บล็อก <code>catch</code> ของคำสั่ง <code>try...catch</code> ข้างนอก จะตรวจหาข้อผิดพลาดแทน</p>

<h3 id="การใช้งานอ็อบเจกต์ข้อผิดพลาด">การใช้งานอ็อบเจกต์ข้อผิดพลาด</h3>

<p>ด้วยชนิดของข้อผิดพลาด, คุณอาจจะใช้คุณสมบัติ 'name' และ 'message' เพื่อให้ได้ข้อความที่สมบูรณ์ขึ้น โดยทั่วไป 'name' จะใช้ระบุชนิดของข้อผิดพลาด (เช่น 'DOMException' หรือ 'Error') และ 'message' จะใช้แสดงข้อความย่อ ที่สั้นกว่าการแปลงอ็อบเจกต์ข้อผิดพลาดให้เป็นสตริง</p>

<p>ถ้าคุณสร้างอ็อบเจกต์ข้อผิดพลาดเอง และต้องการใช้ประโยชน์จากคุณสมบัติต่างๆเหล่านี้ (เช่น บล็อก catch ของคุณไม่แยกแยะระหว่างข้อผิดพลาดของคุณเองกับของระบบ) คุณสามารถใช้ตัวสร้างอ็อบเจกต์ชนิด Error ได้ ดังตัวอย่าง:</p>

<pre class="brush: js">function doSomethingErrorProne () {
   if (ourCodeMakesAMistake()) {
      throw (new Error('The message'));
   }
   else {
      doSomethingToGetAJavascriptError();
   }
}
....
try {
   doSomethingErrorProne();
}
catch (e) {
   alert(e.name);// alerts 'Error'
   alert(e.message); // alerts 'The message' or a JavaScript error message)
}</pre>