<div>{{JSRef}}</div>

<div><span class="seoSummary">Створює примірник класу <strong><code>Date</code></strong>, що позначає певну мить у часі. В об'єктах <code>Date</code> час зберігається як число мілісекунд від 1 січня 1970 року (00:00:00 за UTC).</span></div>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="syntaxbox">new Date();
new Date(<var>value</var>);
new Date(<var>dateString</var>);
new Date(<var>year</var>, <var>month</var>[, <var>day</var>[, <var>hours</var>[, <var>minutes</var>[, <var>seconds</var>[, <var>milliseconds</var>]]]]]);
</pre>

<div class="note">
<p><strong>Заувага:</strong> Об'єкт <code>Date</code> можна створити лише викликом <code>Date</code> як конструктора (з використанням оператора {{jsxref("Operators/new", "new")}}). Натомість виклик <code>Date</code> як звичайної функції повертає рядок. На відміну від деяких інших типів, для <code>Date</code> літералів не існує.</p>
</div>

<h3 id="Параметри">Параметри</h3>

<div class="note">
<p><strong>Заувага:</strong> Якщо конструктор <code>Date</code> викликано з більш як одним аргументом, а значення одного чи декількох вказаних складників виходить за прийнятні межі (скажімо, вказано 13-й місяць чи 70 хвилин), буде скориговано суміжні складники. Себто виклик <code>new Date(2013, 13, 1)</code> є тотожним до <code>new Date(2014, 1, 1)</code> і так само відповідає даті <code>2014-02-01</code> (завважте, що лік місяців починається від нуля). Те саме стосується інших значень: виразам <code>new Date(2013, 2, 1, 0, 70)</code> та <code>new Date(2013, 2, 1, 1, 10)</code> однаково відповідає дата <code>2013-03-01T01:10:00</code>.</p>
</div>

<div class="note">
<p><strong>Заувага:</strong> Якщо конструктор <code>Date</code> викликано з більш як одним аргументом, передані аргументи позначатимуть місцевий час. Якщо треба вказати час за UTC, скористайтеся виразом <code>new Date({{jsxref("Date.UTC()", "Date.UTC(…)")}})</code>, передавши до <code>Date.UTC()</code> ті самі аргументи.</p>
</div>

<dl>
 <dt><code>value</code></dt>
 <dd>Ціле число, що вказує кількість мілісекунд з 1 січня 1970 року 00:00:00 за UTC без врахування високосних секунд. Це те саме, що <em>час Unix</em>, але зважайте на те, що більшість функцій часу й дати Unix рахують у секундах.</dd>
 <dt><code>dateString</code></dt>
 <dd>Рядок, що вказує дату й час. Має бути у форматі, що розпізнається методом {{jsxref("Date.parse()")}} (<a href="http://tools.ietf.org/html/rfc2822#page-14">IETF-compliant RFC 2822 timestamps</a>, і також <a href="http://www.ecma-international.org/ecma-262/5.1/#sec-15.9.1.15">різновид ISO8601</a>).</dd>
 <dd>
 <div class="note">
 <p><strong>Заувага:</strong> Розбір рядків з датою (часом) за допомогою конструктора <code>Date</code> (або метода <code>Date.parse</code>, що є одне й те саме) є рішуче небажаним через наявні розбіжності поміж переглядачами. Рядки формату RFC 2822 підтримуються лише за неформальною домовленістю. А розбіжність у підтримці рядків формату ISO 8601 полягає в тому, що запис дати без часу (як-от «1970-01-01») може тлумачитися як час за UTC, а не місцевий.</p>
 </div>
 </dd>
 <dt><code>year</code></dt>
 <dd>Ціле число, що позначає рік. Значення від 0 до 99 позначають роки з 1900 до 1999. Дивіться {{anch("Рік_менший_від_сотні_обертається_на_1900-1999", "приклад")}}.</dd>
 <dt><code>month</code> {{optional_inline}}</dt>
 <dd>Ціле число, що позначає місяць. Лік починається від нуля (січень — 0, а грудень — 11).</dd>
 <dt><code>day</code> {{optional_inline}}</dt>
 <dd>Ціле число, що позначає день місяця. Лік починається з одиниці.</dd>
 <dt><code>hours</code> {{optional_inline}}</dt>
 <dd>Ціле число, що позначає годину доби.</dd>
 <dt><code>minutes</code> {{optional_inline}}</dt>
 <dd>Ціле число, що позначає хвилини.</dd>
 <dt><code>seconds</code> {{optional_inline}}</dt>
 <dd>Ціле число, що позначає секунди.</dd>
 <dt><code>milliseconds</code> {{optional_inline}}</dt>
 <dd>Ціле число, що позначає мілісекунди.</dd>
</dl>

<h2 id="Опис">Опис</h2>

<ul>
 <li>Якщо конструктор викликано без аргументів, він створює об'єкт <code>Date</code> для поточної дати і часу відповідно до системних налаштувань.</li>
 <li>Якщо вказано принаймні два аргументи, кожен з відсутніх отримає значення 0 (або 1, якщо це день місяця).</li>
 <li>У JavaScript дата зберігається як числове значення — кількість мілісекунд між позначуваною миттю та північчю 1 січня 1970 року за UTC. День містить 86,400,000 мілісекунд. Межі для дат позначуваних об'єктом <code>Date</code> становлять 200 млн. днів — від -100,000,000 до +100,000,000 днів відносно півночі 1 січня 1970 року за UTC.</li>
 <li>Поведінка об'єкта <code>Date</code> не залежить від платформи. Значення часу можна передавати між системами, а створені з нього об'єкти дати позначатимуть одну й ту саму мить у часі.</li>
 <li>Об'єкт <code>Date</code> має окремі методи для підтримки UTC (всесвітній час) та місцевого часу. UTC (узгоджений всесвітній час) означає час встановлений світовим стандартом. Натомість місцевий час — це час того комп'ютера, на якому виконується код JavaScript.</li>
 <li>Виклик <code>Date</code> як функції (замість створення примірника класу <code>Date</code> за допомогою оператора {{jsxref("Operators/new", "new")}}) вертає рядок, що містить відповідну дату й час.</li>
</ul>

<div class="note">
<p><strong>Заувага:</strong> Досить поширеним є хибне ототожнення UTC (узгоджений всесвітній час) із GMT (середній час за Гринвічем). Але, на відміну від UTC, GMT є певним часовим поясом. Хоча слід також зазначити, що ані перший, ані другий не переходять на літній час (DST).</p>
</div>

<h2 id="Властивості">Властивості</h2>

<dl>
 <dt>{{jsxref("Date.prototype")}}</dt>
 <dd>Уможливлює додавання властивостей до об'єктів класу <code>Date</code>.</dd>
 <dt><code>Date.length</code></dt>
 <dd>Значення <code>Date.length</code> дорівнює 7. Це кількість параметрів конструктора.</dd>
</dl>

<h2 id="Методи">Методи</h2>

<dl>
 <dt>{{jsxref("Date.now()")}}</dt>
 <dd>Вертає ціле число, що позначає поточний час — кількість мілісекунд від 00:00:00 за UTC 1 січня 1970 року без врахування високосних секунд.</dd>
 <dt>{{jsxref("Date.parse()")}}</dt>
 <dd>Розбирає текстовий запис (рядок) із датою (часом) та повертає кількість мілісекунд між 00:00:00 за UTC 1 січня 1970 та зазначеною миттю у часі. Високосні секунди не враховуються.</dd>
 <dd>
 <div class="note">
 <p><strong>Заувага:</strong> Розбір рядків з датою (часом) за допомогою метода <code>Date.parse</code> є рішуче небажаним через наявні розбіжності поміж переглядачами.</p>
 </div>
 </dd>
 <dt>{{jsxref("Date.UTC()")}}</dt>
 <dd>Приймає ті самі параметри, що й найдовша форма конструктора (від 2 до 7), та вертає кількість мілісекунд між 00:00:00 за UTC 1 січня 1970 року та зазначеною миттю у часі без врахування високосних секунд.</dd>
</dl>

<h2 id="Примірники_Date_у_JavaScript">Примірники <code>Date</code> у JavaScript</h2>

<p>Всі примірники класу <code>Date</code> успадковують {{jsxref("Date.prototype")}}. Якщо змінити прототип конструктора, це вплине на всі примірники класу <code>Date</code>.</p>

<h3 id="Методи_Date.prototype">Методи <code>Date.prototype</code></h3>

<div>{{page('/uk/docs/Web/JavaScript/Reference/Global_Objects/Date/prototype', 'Methods')}}</div>

<h2 id="Приклади">Приклади</h2>

<h3 id="Кілька_шляхів_створення_примірника_Date">Кілька шляхів створення примірника <code>Date</code></h3>

<div class="note">
<p><strong>Заувага:</strong> Розбір рядків з датою (часом) за допомогою конструктора <code>Date</code> (або метода <code>Date.parse</code>, що є одне й те саме) є рішуче небажаним через наявні розбіжності поміж переглядачами.</p>
</div>

<p>Наведені приклади унаочнюють декілька шляхів створення об'єктів дати:</p>

<pre class="brush: js">var today = new Date();
var birthday = new Date('December 17, 1995 03:24:00');
var birthday = new Date('1995-12-17T03:24:00');
var birthday = new Date(1995, 11, 17);
var birthday = new Date(1995, 11, 17, 3, 24, 0);
</pre>

<h3 id="Рік_менший_від_сотні_обертається_на_1900-1999">Рік менший від сотні обертається на 1900-1999</h3>

<p>Методи {{jsxref("Date.prototype.getYear()", "getYear()")}} та {{jsxref("Date.prototype.setYear()", "setYear()")}} (як і конструктор) тлумачать одно- та двоцифрові значення (від 0 до 99 включно) як рік двадцятого сторіччя. Якщо ж ви маєте на меті встановити (чи отримати) рік першого сторіччя (від Різдва Христового), скористайтеся натомість методами {{jsxref("Date.prototype.getFullYear()", "getFullYear()")}} та {{jsxref("Date.prototype.setFullYear()", "setFullYear()")}}:</p>

<pre class="brush: js">var date = new Date(98, 1);  // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)

// Застарілий метод, тут 98 також обертається на 1998
date.setYear(98);            // Sun Feb 01 1998 00:00:00 GMT+0000 (GMT)

date.setFullYear(98);        // Sat Feb 01 0098 00:00:00 GMT+0000 (BST)
</pre>

<h3 id="Обчислення_тривалості">Обчислення тривалості</h3>

<p>У наведених прикладах показано, як з'ясувати час (в мілісекундах), що розділяє дві дати у JavaScript.</p>

<p>Через різну тривалість доби (внаслідок переходів між літнім та зимовим часом), місяця та року вираження обчисленої тривалості в одиницях більших за годину є дещо ускладненим і потребує вдумливого дослідження.</p>

<p>Найпростіший спосіб за допомогою метода <code>{{jsxref("Date.now()")}}</code>:</p>

<pre class="brush: js">// Запам'ятаймо початок
var start = Date.now();

// Тут якісь обчислення, тривалість яких слід з'ясувати
doSomethingForALongTime();

// Запам'ятаймо кінець
var end = Date.now();

// Обчислімо тривалість — різницю між кінцем та початком (у мілісекундах)
var elapsed = end - start;
</pre>

<p>Тут майже те саме, але з використанням об'єктів класу <code>Date</code> та метода <code>{{jsxref("Date.prototype.getTime()")}}</code>:</p>

<pre class="brush: js">// Запам'ятаймо початок
var start = new Date();

// Тут якісь обчислення, тривалість яких слід з'ясувати
doSomethingForALongTime();

// Запам'ятаймо кінець
var end = new Date();

// Обчислімо тривалість — різницю між кінцем та початком (у мілісекундах)
var elapsed = end.getTime() - start.getTime();
</pre>

<p>В цьому прикладі функція <code>evaluateFunctionDuration</code> є посередником. Вона викликає передану їй функцію <code>func</code>, обчислює тривалість її виконання (виводить у консоль) та вертає те, що повернула <code>func</code>:</p>

<pre class="brush: js">function evaluateFunctionDuration(func) {
  var begin = Date.now(),
      value = func(),
      end = Date.now();

  console.log('Тривалість: ' + (end - begin) + ' ms');
  return value;
}

var value = evaluateFunctionDuration(function() { … });
</pre>

<div class="note">
<p><strong>Заувага:</strong> В переглядачах з підтримкою часу високої роздільності {{domxref("window.performance", "Web Performance API", "", 1)}}, метод {{domxref("Performance.now()")}} може забезпечити вищу точність та надійність вимірювання тривалості, ніж {{jsxref("Date.now()")}}.</p>
</div>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
   <th scope="col">Статус</th>
   <th scope="col">Коментар</th>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-date-objects', 'Date')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-date-objects', 'Date')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.9', 'Date')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES1')}}</td>
   <td>{{Spec2('ES1')}}</td>
   <td>Первинне визначення. Запроваджено у JavaScript 1.1.</td>
  </tr>
 </tbody>
</table>

<h2 id="Підтримка_веб-переглядачами">Підтримка веб-переглядачами</h2>

<div class="hidden">Таблиця сумісності на цій сторінці створена зі структурованих даних. Якщо ви хочете долучитися до розробки цих даних, пропонуйте нам свої pull request до репозиторію <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a>.</div>

<div>{{Compat("javascript.builtins.Date.Date")}}</div>