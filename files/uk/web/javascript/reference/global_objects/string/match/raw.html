<div>{{JSRef}}</div>

<p>Метод <strong><code>match()</code></strong> шукає та повертає (якщо є) відповідності рядка до зазначеного регулярного виразу.</p>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="syntaxbox"><var>str</var>.match(<var>regexp</var>)</pre>

<h3 id="Параметри">Параметри</h3>

<dl>
 <dt><code>regexp</code></dt>
 <dd>Об'єкт регулярного виразу. Якщо передати значення <code>value</code> іншого типу, його буде зведено до {{jsxref("RegExp")}} за допомогою оператора <code>new RegExp(value)</code>. Якщо жодного параметра не вказано, метод поверне масив з одним елементом — порожнім рядком: <code>['']</code>.</dd>
</dl>

<h3 id="Вертає">Вертає</h3>

<p>Вертає масив, якщо знайдено збіги. Першим елементом масиву завжди буде ввесь підрядок, що відповідає регулярному виразові, а за ним — низка захоплених підрядків, які відповідають підвиразам у круглих дужках (якщо регулярний вираз містить такі).</p>

<p>Якщо збігів не знайдено, метод вертає значення {{jsxref("null")}}.</p>

<h2 id="Опис">Опис</h2>

<p>Якщо регулярний вираз не позначено прапорцем <code>g</code>, виклик <code>str.match()</code> повертає те саме значення, що й {{jsxref("RegExp.prototype.exec()", "RegExp.exec()")}}.</p>

<p>Повернений масив має дві додаткові властивості:</p>

<ul>
 <li><code>input</code>: містить цілком рядок, який порівнювали із регулярним виразом;</li>
 <li><code>index</code>: позначає зсув (лік від нуля) знайденого підрядка всередині рядка <code>input</code>;</li>
</ul>

<p>Якщо регулярний вираз позначено прапорцем <code>g</code>, метод вертає масив усіх знайдених підрядків. Захоплювані підвирази (в круглих дружках) буде знехтувано. Якщо збігів не знайдено, метод повертає значення {{jsxref("null")}}.</p>

<h3 id="Див._також_інші_методи_RegExp">Див. також інші методи <code>RegExp</code></h3>

<ul>
 <li>Якщо вам треба лише з'ясувати, чи відповідає рядок регулярному виразові {{jsxref("RegExp")}}, скористайтеся ліпше методом {{jsxref("RegExp.prototype.test()", "RegExp.test()")}}.</li>
 <li>Якщо вас цікавить лише перший збіг, можете натомість використати {{jsxref("RegExp.prototype.exec()", "RegExp.exec()")}}.</li>
 <li>Якщо ви хочете отримати захоплені підвирази, а прапорець <code>g</code> встановлено, вам потрібен метод {{jsxref("RegExp.prototype.exec()", "RegExp.exec()")}}.</li>
</ul>

<h2 id="Приклади">Приклади</h2>

<h3 id="Використання_match()">Використання <code>match()</code></h3>

<p>В прикладі нижче метод <code>match()</code> задіяно для пошуку слова <code>«розділ»</code> та однієї чи кількох цифр за ним, розділених крапкою. Регулярний вираз позначено прапорцем <code>i</code>, що означає відсутність розрізнювання великих та малих літер.</p>

<pre class="brush: js">var str = 'Докладніше див. розділ 3.4.5.1';
var re = /див\. (розділ \d+(\.\d)*)/i;
var found = str.match(re);

console.log(found);

// Виводить:
// [
//   0: "див. розділ 3.4.5.1"
//   1: "розділ 3.4.5.1"
//   2: ".1"
//   index: 11
//   input: "Докладніше див. розділ 3.4.5.1"
// ]

// Рядок "див. розділ 3.4.5.1" — це увесь підрядок, що відповідає регулярному виразові
// Рядок "розділ 3.4.5.1" — це підрядок, захоплений підвиразом '(розділ \d+(\.\d)*)'
// Рядок ".1" — це останній підрядок, захоплений підвиразом '(\.\d)'
// Властивість 'index' (11) — це зсув підрядка, що відповідає регулярному виразові
// Властивість 'input' — це повна копія досліджуваного рядка str
</pre>

<h3 id="Вживання_прапорців_i_та_g_із_методом_match()">Вживання прапорців <code>i</code> та <code>g</code> із методом <code>match()</code></h3>

<p>Приклад нижче засвідчує дію прапорців <code>i</code> (ignore case — регістронезалежний режим) та <code>g</code> (global — пошук усіх збігів, а не тільки першого-ліпшого) при використанні метода <code>match()</code>. Регулярний вираз шукатиме латинські літери від <strong>A</strong> до <strong>E</strong> (великі й малі):</p>

<pre class="brush: js">var str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
var regexp = /[A-E]/gi;
var matches_array = str.match(regexp);

console.log(matches_array);
// ['A', 'B', 'C', 'D', 'E', 'a', 'b', 'c', 'd', 'e']
</pre>

<h3 id="Використання_match()_без_параметрів">Використання <code>match()</code> без параметрів</h3>

<pre class="brush: js">var str = "Я — Дух одвічної стихії";

// вертає ["", index: 0, input: "Я — Дух одвічної стихії"]
str.match();</pre>

<h3 id="Параметр_відмінного_від_RegExp_типу">Параметр відмінного від <code>RegExp</code> типу</h3>

<p>Якщо переданий параметр являє собою рядок або число, його буде перетворено на об'єкт {{jsxref("RegExp")}} шляхом неявного виклику <code>new RegExp(obj)</code>. Якщо це додатнє число, його знак <code>+</code> буде знехтувано, проте для від'ємного числа знак <code>-</code> стане частиною регулярного виразу:</p>

<pre class="brush: js">var str1 = "NaN означає «не число». Нескінченність у JavaScript має дві форми: -Infinity та +Infinity.",
    str2 = "Моїй бабці 65 років, а дідусеві — 63.",
    str3 = "Незмінна величина null позначає відсутність очікуваного значення.";

str1.match("число");    // "число" є рядком; вертає ["число"]
str1.match(NaN);        // величина NaN є числом; вертає ["NaN"]
str1.match(Infinity);   // величина Infinity також є числом; вертає ["Infinity"]
str1.match(+Infinity);  // вертає ["Infinity"]
str1.match(-Infinity);  // вертає ["-Infinity"]
str2.match(65);         // вертає ["65"]
str2.match(+65);        // додатнє число; вертає ["65"]
str3.match(null);       // вертає ["null"]</pre>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
   <th scope="col">Статус</th>
   <th scope="col">Коментар</th>
  </tr>
  <tr>
   <td>{{SpecName('ES3')}}</td>
   <td>{{Spec2('ES3')}}</td>
   <td>Початкова виознака. Запроваджено у JavaScript 1.2.</td>
  </tr>
  <tr>
   <td>{{SpecName('ES5.1', '#sec-15.5.4.10', 'String.prototype.match')}}</td>
   <td>{{Spec2('ES5.1')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ES6', '#sec-string.prototype.match', 'String.prototype.match')}}</td>
   <td>{{Spec2('ES6')}}</td>
   <td> </td>
  </tr>
  <tr>
   <td>{{SpecName('ESDraft', '#sec-string.prototype.match', 'String.prototype.match')}}</td>
   <td>{{Spec2('ESDraft')}}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Підтримка_веб-переглядачами">Підтримка веб-переглядачами</h2>

<div class="hidden">Таблиця сумісності на цій сторінці створена зі структурованих даних. Якщо ви хочете долучитися до розробки цих даних, пропонуйте нам свої pull request до репозиторію <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a>.</div>

<p>{{Compat("javascript.builtins.String.match")}}</p>

<h2 id="Зауваги_щодо_Firefox">Зауваги щодо Firefox</h2>

<ul>
 <li>Лише рушій Gecko підтримував параметр <code>flags</code> — другий аргумент метода: <code>str.match(regexp, flags)</code>;</li>
 <li>З версії Gecko 27 {{geckoRelease(27)}} цей метод було узгоджено зі специфікацією ECMAScript. Коли <code>match()</code> викликано із регулярним виразом, що його позначено прапорцем <code>g</code>, властивість {{jsxref("RegExp.lastIndex")}} (якщо зазначено) скидається до <code>0</code> ({{bug(501739)}});</li>
 <li>З версії Gecko 39 {{geckoRelease(39)}} нестандартний параметр <code>flags</code> визнано застарілим і його використання спричиняє відповідне попередження в консолі ({{bug(1142351)}}).</li>
 <li>З версії Gecko 47 {{geckoRelease(47)}} нестандартний параметр <code>flags</code> у проміжних складаннях (не випусках) більше не підтримується й невдовзі його остаточно буде вилучено ({{bug(1245801)}}).</li>
 <li>З версії Gecko 49 {{geckoRelease(49)}} підтримка нестандартного параметра <code>flags</code> припинена ({{bug(1108382)}}).</li>
</ul>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li>{{jsxref("RegExp")}}</li>
 <li>{{jsxref("RegExp.prototype.exec()")}}</li>
 <li>{{jsxref("RegExp.prototype.test()")}}</li>
</ul>