<p>当前的执行上下文。在有{{glossary("value","具体值")}}的上下文中，<strong>表达式</strong>是可见也都能够被引用。如果一个 {{glossary("variable","变量")}}<strong> </strong>或者其他表达式不在 "当前的作用域"，那么JavaScript机制会继续沿着作用域链上查找直到全局作用域（global或浏览器中的window）如果找不到将不可被使用。 作用域也可以根据代码层次分层，以便子作用域可以访问父作用域，通常是指沿着链式的作用域链查找，而不能从父作用域引用子作用域中的变量和引用。</p>

<p>当然一个 {{glossary("variable","Function")}} 将生成一个闭包（通常是返回一个函数引用），这个函数引用从外部作用域（在当前环境下）可以访问闭包内部的作用域。例如，下面的代码是无效的，并不是闭包的形式）：</p>

<pre class="syntaxbox">function exampleFunction() {
    var x = "declared inside function";  // x只能在exampleFunction函数中使用
    console.log("Inside function");
    console.log(x);
}

console.log(x);  // 引发error</pre>

<p>但是，由于变量在函数外被声明为全局变量，因此下面的代码是有效的（当前作用域不存在的变量和引用，就沿着作用域链继续寻找）：</p>

<pre class="syntaxbox">var x = "declared outside function";

exampleFunction();

function exampleFunction() {
    console.log("Inside function");
    console.log(x);
}

console.log("Outside function");
console.log(x);</pre>

<p>文中只提到了闭包的简单特例，也就是父作用域引用子作用域的变量或者引用。这儿做一个补充，当一个函数（foo）执行返回一个内部函数(bar)引用时bar引用将会保存foo的作用域引用。例如：</p>

<p> </p>

<pre class="brush: js">function foo(){
    const obj = {name:"foo-va"};
    return function(){
        return obj;
    }
}

var fun = foo();
fun();//{name:"foo-va"}
</pre>

<p> </p>

<p> </p>

<h2 id="了解更多">了解更多</h2>

<h3 id="基础知识">基础知识</h3>

<ul>
 <li>{{Interwiki("wikipedia", "Scope (computer science)")}} on Wikipedia</li>
</ul>

<p> </p>