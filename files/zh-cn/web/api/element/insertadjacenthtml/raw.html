<div>{{APIRef("DOM")}}</div>

<h2 id="Summary" name="Summary">概述</h2>

<p><strong><code>insertAdjacentHTML()</code></strong> 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。</p>

<h2 id="语法">语法</h2>

<pre class="eval"><em>element</em>.insertAdjacentHTML(<em>position</em>, <em>text</em>);
</pre>

<p>position是相对于元素的位置，并且必须是以下字符串之一：</p>

<dl>
 <dt>'beforebegin'</dt>
 <dd>元素自身的前面。</dd>
 <dt>'afterbegin'</dt>
 <dd><code><font face="Open Sans, Arial, sans-serif">插入元素内部的第一个子节点之前</font>。</code></dd>
 <dt>'beforeend'</dt>
 <dd>插入元素内部的最后一个子节点之后。</dd>
 <dt>'afterend'</dt>
 <dd>元素自身的后面。</dd>
</dl>

<p>text是要被解析为HTML或XML,并插入到DOM树中的字符串。</p>

<h3 id="位置名称的可视化：">位置名称的可视化：</h3>

<pre>&lt;!-- <strong><code>beforebegin</code></strong> --&gt; 
<code>&lt;p&gt;</code> 
&lt;!-- <strong><code>afterbegin</code></strong> --&gt;
foo
&lt;!-- <strong><code>beforeend</code></strong> --&gt;
<code>&lt;/p&gt;
</code>&lt;!-- <strong><code>afterend</code></strong> --&gt;
</pre>

<div class="note"><strong>注意：</strong> beforebegin和afterend位置,仅在节点在树中且节点具有一个parent元素时工作.</div>

<h2 id="Example" name="Example">示例</h2>

<pre class="brush: js" dir="rtl">// &lt;div id="one"&gt;one&lt;/div&gt; 
var d1 = document.getElementById('one'); 
d1.insertAdjacentHTML('afterend', '&lt;div id="two"&gt;two&lt;/div&gt;');

// 此时，新结构变成： // &lt;div id="one"&gt;one&lt;/div&gt;&lt;div id="two"&gt;two&lt;/div&gt;


// ES6 version

// let html = `&lt;div id="two"&gt;two&lt;/div&gt;`;
// div.insertAdjacentHTML(`<strong><code>beforeend</code></strong>`, html);


</pre>

<h2 id="Specification" name="Specification">注意</h2>

<h3 id="安全问题">安全问题</h3>

<p>使用<code>insertAdjacentHTML</code>插入用户输入的HTML内容的时候, 需要转义之后才能使用.</p>

<p>如果只是为了插入文本内容(而不是HTML节点), 不建议使用这个方法, 建议使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent" title="The Node.textContent property represents the text content of a node and its descendants."><code>node.textContent</code></a> 或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/insertAdjacentText" title="The insertAdjacentText() method inserts a given text node at a given position relative to the element it is invoked upon."><code>node.insertAdjacentText()</code></a> . 因为这样不需要经过HTML解释器的转换, 性能会好一点.</p>

<h2 id="Specification" name="Specification" style="margin-bottom: 20px; line-height: 30px; font-size: 2.14285714285714rem;">规范</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('DOM Parsing', '#insertadjacenthtml()', 'Element.insertAdjacentHTML()')}}</td>
   <td>{{ Spec2('DOM Parsing') }}</td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_Compatibility" name="Browser_Compatibility" style="margin-bottom: 20px; line-height: 30px; font-size: 2.14285714285714rem;">浏览器兼容性</h2>

<p>{{ CompatibilityTable() }}</p>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Chrome</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari (WebKit)</th>
  </tr>
  <tr>
   <td>Basic support</td>
   <td>1.0</td>
   <td>{{ CompatGeckoDesktop("8.0") }}</td>
   <td>4.0</td>
   <td>7.0</td>
   <td>4.0 (527)</td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Android</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>IE Phone</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td>Basic support</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatGeckoMobile("8.0") }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>{{ CompatUnknown() }}</td>
   <td>
    <p>{{ CompatUnknown() }}</p>

    <p> </p>
   </td>
  </tr>
 </tbody>
</table>
</div>

<h2 id="Specification" name="Specification"> </h2>

<h2 id="相关链接">相关链接</h2>

<ul>
 <li><a class="external" href="http://hacks.mozilla.org/2011/11/insertadjacenthtml-enables-faster-html-snippet-injection/">hacks.mozilla.org guest post</a> by Henri Sivonen including benchmark showing that insertAdjacentHTML can be way faster in some cases.</li>
 <li>{{domxref("Element.insertAdjacentElement()")}}</li>
 <li>{{domxref("Element.insertAdjacentText()")}}</li>
</ul>