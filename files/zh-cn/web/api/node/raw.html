<p>{{APIRef("DOM")}}</p>

<p><span class="seoSummary"><strong><code>Node</code></strong> 是一个接口，许多 DOM API 对象的类型会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。</span></p>

<p>以下接口都从 <code>Node</code> 继承其方法和属性：</p>

<div>{{DOMxRef("Document")}}, {{DOMxRef("Element")}}, {{DOMxRef("Attr")}}, {{DOMxRef("CharacterData")}} (which {{DOMxRef("Text")}}, {{DOMxRef("Comment")}}, and {{DOMxRef("CDATASection")}} inherit), {{DOMxRef("ProcessingInstruction")}}, {{DOMxRef("DocumentFragment")}}, {{DOMxRef("DocumentType")}}, {{DOMxRef("Notation")}}, {{DOMxRef("Entity")}}, {{DOMxRef("EntityReference")}}</div>

<p> </p>

<p>在方法和属性不相关的特定情况下，这些接口可能返回 <code>null</code>。它们可能会抛出异常 - 例如，当将子节点添加到不允许子节点存在的节点时。</p>

<p>{{InheritanceDiagram}}</p>

<h2 id="属性">属性</h2>

<p>从其父类型 <em>{{DOMxRef("EventTarget")}}</em><sup>[1]</sup> 继承属性。</p>

<dl>
 <dt>{{DOMxRef("Node.baseURI")}}{{ReadOnlyInline}}</dt>
 <dd>返回一个表示base URL的{{DOMxRef("DOMString")}}。不同语言中的base URL的概念都不一样。 在HTML中，base URL表示协议和域名，以及一直到最后一个'/'之前的文件目录。</dd>
</dl>

<dl>
 <dt>{{DOMxRef("Node.baseURIObject")}} {{Non-standard_inline}}{{Fx_MinVersion_Inline("3")}}</dt>
 <dd>(不适用于网页内容) 只读的 {{ Interface("nsIURI") }} 对象表示元素的base URI.</dd>
 <dt>{{DOMxRef("Node.childNodes")}}{{ReadOnlyInline}}</dt>
 <dd>返回一个包含了该节点所有子节点的实时的{{DOMxRef("NodeList")}}。{{DOMxRef("NodeList")}} 是“实时的”意思是，如果该节点的子节点发生了变化，{{DOMxRef("NodeList")}}对象就会自动更新。 </dd>
 <dt>{{DOMxRef("Node.firstChild")}} {{ReadonlyInline}}</dt>
 <dd>返回该节点的第一个子节点{{DOMxRef("Node")}}，如果该节点没有子节点则返回<code>null</code>。</dd>
 <dt>{{DOMxRef("Node.isConnected")}}{{ReadOnlyInline}}</dt>
 <dd>返回一个布尔值用来检测该节点是否已连接(直接或者间接)到一个上下文对象上，比如通常DOM情况下的{{DOMxRef("Document")}}对象，或者在shadow DOM情况下的{{DOMxRef("ShadowRoot")}}对象。</dd>
 <dt>{{DOMxRef("Node.lastChild")}} {{ReadonlyInline}}</dt>
 <dd>返回该节点的最后一个子节点{{DOMxRef("Node")}}，如果该节点没有子节点则返回<code>null</code>。</dd>
 <dt>{{DOMxRef("Node.nextSibling")}} {{ReadonlyInline}}</dt>
 <dd>返回与该节点同级的下一个节点 {{DOMxRef("Node")}}，如果没有返回<code>null</code>。</dd>
 <dt>{{DOMxRef("Node.nodeName")}} {{ReadonlyInline}}</dt>
 <dd>返回一个包含该节点名字的{{DOMxRef("DOMString")}}。节点的名字的结构和节点类型不同。比如{{DOMxRef("HTMLElement")}}的名字跟它所关联的标签对应，就比如{{DOMxRef("HTMLAudioElement")}}的就是 <code>'audio'</code> ，{{DOMxRef("Text")}}节点对应的是 <code>'#text'</code> 还有{{DOMxRef("Document")}}节点对应的是 <code>'#document'</code>。</dd>
 <dt>{{DOMxRef("Node.nodeType")}}{{ReadonlyInline}}</dt>
 <dd>返回一个与该节点类型对应的<code>无符号短整型</code>的值，可能的值如下：
 <table class="standard-table">
  <tbody>
   <tr>
    <th scope="col">Name</th>
    <th scope="col">Value</th>
   </tr>
   <tr>
    <td><code>ELEMENT_NODE</code></td>
    <td><code>1</code></td>
   </tr>
   <tr>
    <td><code>ATTRIBUTE_NODE</code> {{Deprecated_Inline}}</td>
    <td><code>2</code></td>
   </tr>
   <tr>
    <td><code>TEXT_NODE</code></td>
    <td><code>3</code></td>
   </tr>
   <tr>
    <td><code>CDATA_SECTION_NODE</code></td>
    <td><code>4</code></td>
   </tr>
   <tr>
    <td><code>ENTITY_REFERENCE_NODE</code> {{Deprecated_Inline}}</td>
    <td><code>5</code></td>
   </tr>
   <tr>
    <td><code>ENTITY_NODE</code> {{Deprecated_Inline}}</td>
    <td><code>6</code></td>
   </tr>
   <tr>
    <td><code>PROCESSING_INSTRUCTION_NODE</code></td>
    <td><code>7</code></td>
   </tr>
   <tr>
    <td><code>COMMENT_NODE</code></td>
    <td><code>8</code></td>
   </tr>
   <tr>
    <td><code>DOCUMENT_NODE</code></td>
    <td><code>9</code></td>
   </tr>
   <tr>
    <td><code>DOCUMENT_TYPE_NODE</code></td>
    <td><code>10</code></td>
   </tr>
   <tr>
    <td><code>DOCUMENT_FRAGMENT_NODE</code></td>
    <td><code>11</code></td>
   </tr>
   <tr>
    <td><code>NOTATION_NODE</code> {{Deprecated_Inline}}</td>
    <td><code>12</code></td>
   </tr>
  </tbody>
 </table>
 </dd>
 <dt>{{DOMxRef("Node.nodeValue")}}</dt>
 <dd>返回或设置当前节点的值。</dd>
 <dt>{{DOMxRef("Node.ownerDocument")}} {{readonlyInline}}</dt>
 <dd>返回这个元素属于的 {{DOMxRef("Document")}}对象 。 如果没有Document对象与之关联，返回null。</dd>
 <dt>{{DOMxRef("Node.parentNode")}} {{readonlyInline}}</dt>
 <dd>返回一个当前结点 {{DOMxRef("Node")}}的父节点 。如果没有这样的结点,，比如说像这个节点是树结构的顶端或者没有插入一棵树中， 这个属性返回null。</dd>
 <dt>{{DOMxRef("Node.parentElement")}} {{readonlyInline}}</dt>
 <dd>返回一个当前节点的父节点 {{DOMxRef("Element")}} 。 如果当前节点没有父节点或者说父节点不是一个元素({{DOMxRef("Element")}}), 这个属性返回null。</dd>
 <dt>{{DOMxRef("Node.previousSibling")}} {{readonlyInline}}</dt>
 <dd>返回一个当前节点同辈的前一个结点( {{DOMxRef("Node")}}) ，或者返回null（如果不存在这样的一个节点的话）。</dd>
 <dt>{{DOMxRef("Node.textContent")}}</dt>
 <dd>返回或设置一个元素内所有子结点及其后代的文本内容。</dd>
</dl>

<h3 id="废弃的属性">废弃的属性</h3>

<dl>
 <dt>{{DOMxRef("Node.localName")}} {{obsolete_inline}}{{readonlyInline}}</dt>
 <dd>Returns a {{DOMxRef("DOMString")}} representing the local part of the qualified name of an element.
 <div class="blockIndicator note">
 <p><strong>Note:</strong> 在Firefox 3.5以及更早的版本中, the property upper-cases the local name for HTML elements (but not XHTML elements). In later versions, this does not happen, so the property is in lower case for both HTML and XHTML.</p>
 </div>
 </dd>
 <dt>{{DOMxRef("Node.namespaceURI")}} {{obsolete_inline}}{{readonlyInline}}</dt>
 <dd>该节点命名空间的<code>URL</code>，如果没有命名空间则为<code>null</code>。
 <div class="blockIndicator note">
 <p><strong>Note:</strong> 在Firefox 3.5以及更早的版本中, HTML 的元素都没有命名空间. 而在最新的版本中, 无论是 HTML 还是 XML 文档树 ，所有元素的命名空间统一为 <code><a class="linkification-ext external" href="https://www.w3.org/1999/xhtml/">http://www.w3.org/1999/xhtml/</a></code>。</p>
 </div>
 </dd>
 <dt>{{DOMxRef("Node.nodePrincipal")}} {{Non-standard_inline}}{{Obsolete_Inline("gecko46")}}{{Fx_MinVersion_Inline("3")}}</dt>
 <dd>A {{Interface("nsIPrincipal")}} representing the node principal.</dd>
 <dt>{{DOMxRef("Node.prefix")}} {{Obsolete_Inline}}{{ReadOnlyInline}}</dt>
 <dd>Is a {{DOMxRef("DOMString")}} representing the namespace prefix of the node, or <code>null</code> if no prefix is specified.</dd>
 <dt>{{DOMxRef("Node.rootNode")}} {{Obsolete_Inline}}{{ReadOnlyInline}}</dt>
 <dd>Returns a {{DOMxRef("Node")}} object representing the topmost node in the tree, or the current node if it's the topmost node in the tree. This has been replaced by {{DOMxRef("Node.getRootNode()")}}.</dd>
</dl>

<h2 id="方法">方法</h2>

<p>从其父类型 <em>{{DOMxRef("EventTarget")}}</em><sup>[1]</sup> 继承方法。</p>

<dl>
 <dt>{{DOMxRef("Node.appendChild()")}}</dt>
 <dd>将指定的 childNode 参数作为最后一个子节点添加到当前节点。<br>
 如果参数引用了 DOM 树上的现有节点，则节点将从当前位置分离，并附加到新位置。</dd>
 <dt>{{DOMxRef("Node.cloneNode()")}}</dt>
 <dd>克隆一个 {{DOMxRef("Node")}}，并且可以选择是否克隆这个节点下的所有内容。默认情况下，节点下的内容会被克隆。</dd>
 <dt>{{DOMxRef("Node.compareDocumentPosition()")}}</dt>
 <dd>比较当前节点与文档中的另一节点的位置。</dd>
 <dt>{{DOMxRef("Node.contains()")}}</dt>
 <dd>返回一个 {{jsxref("Boolean")}} 布尔值，来表示传入的节点是否为该节点的后代节点。</dd>
 <dt>{{DOMxRef("Node.getRootNode()")}}</dt>
 <dd>返回上下文对象的根结点。如果shadow root节点存在的话，也可以在返回的节点中包含它。</dd>
 <dt>{{DOMxRef("Node.hasChildNodes()")}}</dt>
 <dd>返回一个{{jsxref("Boolean")}} 布尔值，来表示该元素是否包含有子节点。</dd>
 <dt>{{DOMxRef("Node.insertBefore()")}}</dt>
 <dd>在当前节点下增加一个子节点 {{DOMxRef("Node")}}，并使该子节点位于参考节点的前面。</dd>
 <dt>{{DOMxRef("Node.isDefaultNamespace()")}}</dt>
 <dd>Accepts a namespace URI as an argument and returns a {{jsxref("Boolean")}} with a value of true if the namespace is the default namespace on the given node or false if not.</dd>
 <dt>{{DOMxRef("Node.isEqualNode()")}}</dt>
 <dd>Returns a {{jsxref("Boolean")}} which indicates whether or not two nodes are of the same type and all their defining data points match.</dd>
 <dt>{{DOMxRef("Node.isSameNode()")}}</dt>
 <dd>Returns a {{jsxref("Boolean")}} value indicating whether or not the two nodes are the same (that is, they reference the same object).</dd>
 <dt>{{DOMxRef("Node.lookupPrefix()")}}</dt>
 <dd>Returns a {{DOMxRef("DOMString")}} containing the prefix for a given namespace URI, if present, and <code>null</code> if not. When multiple prefixes are possible, the result is implementation-dependent.</dd>
 <dt>{{DOMxRef("Node.lookupNamespaceURI()")}}</dt>
 <dd>Accepts a prefix and returns the namespace URI associated with it on the given node if found (and null if not). Supplying null for the prefix will return the default namespace.</dd>
 <dt>{{DOMxRef("Node.normalize()")}}</dt>
 <dd>Clean up all the text nodes under this element (merge adjacent, remove empty).</dd>
 <dt>{{DOMxRef("Node.removeChild()")}}</dt>
 <dd>Removes a child node from the current element, which must be a child of the current node.</dd>
 <dt>{{DOMxRef("Node.replaceChild()")}}</dt>
 <dd>Replaces one child {{DOMxRef("Node")}} of the current one with the second one given in parameter.</dd>
</dl>

<h3 id="废弃的方法">废弃的方法</h3>

<dl>
 <dt>{{DOMxRef("Node.getFeature()")}} {{obsolete_inline}}</dt>
 <dd>x</dd>
 <dt>{{DOMxRef("Node.getUserData()")}} {{obsolete_inline}}</dt>
 <dd>Allows a user to get some {{DOMxRef("DOMUserData")}} from the node.</dd>
 <dt>{{DOMxRef("Node.hasAttributes()")}} {{obsolete_inline}}</dt>
 <dd>Returns a {{jsxref("Boolean")}} indicating if the element has any attributes, or not.</dd>
 <dt>{{DOMxRef("Node.isSupported()")}} {{obsolete_inline}}</dt>
 <dd>Returns a {{jsxref("Boolean")}} flag containing the result of a test whether the DOM implementation implements a specific feature and this feature is supported by the specific node.</dd>
 <dt>{{DOMxRef("Node.setUserData()")}} {{obsolete_inline}}</dt>
 <dd>Allows a user to attach, or remove, {{DOMxRef("DOMUserData")}} to the node.</dd>
</dl>

<h2 id="例子">例子</h2>

<h3 id="移除某个节点的所有子节点">移除某个节点的所有子节点</h3>

<pre class="brush: js">function removeAllChildren(element){
  while(element.firstChild){
    element.removeChild(element.firstChild);
  }
}</pre>

<h4 id="使用示例">使用示例</h4>

<pre class="brush: js;">/* ... an alternative to document.body.innerHTML = "" ... */
removeAllChildren(document.body);</pre>

<h3 id="遍历所有子节点">遍历所有子节点</h3>

<p>下面这个函数使用递归的方式遍历一个节点的所有子节点（包括这个根节点自身）。</p>

<pre class="brush: js;">function eachNode(rootNode, callback){
	if(!callback){
		var nodes = [];
		eachNode(rootNode, function(node){
			nodes.push(node);
		});
		return nodes;
	}

	if(false === callback(rootNode))
		return false;

	if(rootNode.hasChildNodes()){
		var nodes = rootNode.childNodes;
		for(var i = 0, l = nodes.length; i &lt; l; ++i)
			if(false === eachNode(nodes[i], callback))
				return;
	}
}</pre>

<h4 id="语法">语法</h4>

<pre class="syntaxbox">eachNode(rootNode, callback);</pre>

<h4 id="描述">描述</h4>

<p>使用递归的方式对 <code>rootNode</code> 的所有后代节点执行回调函数（包括 <code>rootNode</code> 自身）</p>

<p>如果没有设定 <code>callback</code>，这函数会返回一个{{jsxref("Array")}}，包含 <code>rootNode</code> 和它的所有后代节点。</p>

<p>如果设定了 <code>callback</code>（回调函数），如果回调函数在调用中返回 {{jsxref("Boolean")}} <code>false</code>，则当前层级的遍历会中止，同时恢复上一层级的遍历。这个可以用来在找到需要的节点之后中断循环（比如用来查找包含指定文本的文本节点）</p>

<h4 id="参数">参数</h4>

<dl>
 <dt><code>rootNode</code></dt>
 <dd>需要进行后代节点遍历的 <code>Node</code> 对象。</dd>
 <dt><code>callback</code></dt>
 <dd>一个可选的回调<a href="/en-US/docs/JavaScript/Reference/Global_Objects/Function">函数</a>，接受一个节点作为唯一参数。如果没有设定， <code>eachNode</code> 返回一个包含了 <code>rootNode</code> 所有后代节点以及 <code>rootNode</code> 自身的{{jsxref("Array")}}</dd>
</dl>

<h4 id="使用示例_2">使用示例</h4>

<p>下述例子会打印出ID为 <code>"box"</code> 的 <code>&lt;div&gt;</code> 标签内的所有 <code>&lt;span&gt;</code> 标签的 <a href="/en-US/docs/Web/API/Node/textContent"><code>textContent</code></a> 属性：</p>

<pre class="brush: html;">&lt;div id="box"&gt;
	&lt;span&gt;Foo&lt;/span&gt;
	&lt;span&gt;Bar&lt;/span&gt;
	&lt;span&gt;Baz&lt;/span&gt;
&lt;/div&gt;</pre>

<pre class="brush: js;">var box = document.getElementById("box");
eachNode(box, function(node){
	if(null != node.textContent){
		console.log(node.textContent);
	}
});</pre>

<p>用户终端上会显示如下字符：</p>

<pre class="brush: js;">"\n\t", "Foo", "\n\t", "Bar", "\n\t", "Baz"</pre>

<div class="blockIndicator note">
<p><strong>Note:</strong> 空格是构成 {{DOMxRef("Text")}}节点的一部分，意味着缩进和换行在 <code>Element</code> 节点之间形成单独的 <code>Text</code> 。</p>
</div>

<h4 id="真实案例">真实案例</h4>

<p>下述例子反应了 <code>eachNode</code> 函数是如何在真实场景中使用的：搜索网页中的文本。我们使用一个包装函数 <code>grep</code> 去执行搜索：</p>

<pre class="brush: js;">function grep(parentNode, pattern){
	var matches = [];
	var endScan = false;
	
	eachNode(parentNode, function(node){
		if(endScan)
			return false;
		
		// Ignore anything which isn't a text node
		if(node.nodeType !== Node.TEXT_NODE)
			return;

		if("string" === typeof pattern){
			if(-1 !== node.textContent.indexOf(pattern))
				matches.push(node);
		}
		else if(pattern.test(node.textContent)){
			if(!pattern.global){
				endScan = true;
				matches = node;
			}
			else matches.push(node);
		}
	});
	
	return matches;
}</pre>

<p>例如：找到所有包含错别字的 {{DOMxRef("Text")}}：</p>

<pre class="brush: js;">var typos = ["teh", "adn", "btu", "adress", "youre", "msitakes"];
var pattern = new RegExp("\\b(" + typos.join("|") + ")\\b", "gi");
var mistakes = grep(document.body, pattern);
console.log(mistakes);
</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">规范</th>
   <th scope="col">状态</th>
   <th scope="col">备注</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName("DOM WHATWG", "#interface-node", "Node")}}</td>
   <td>{{Spec2("DOM WHATWG")}}</td>
   <td>Added the following methods: <code>getRootNode()</code></td>
  </tr>
  <tr>
   <td>{{SpecName("DOM4", "#interface-node", "Node")}}</td>
   <td>{{Spec2("DOM4")}}</td>
   <td>Removed the following properties: <code>attributes</code>, <code>namespaceURI</code>, <code>prefix</code>, and <code>localName</code>.<br>
    Removed the following methods: <code>isSupported()</code>, <code>hasAttributes()</code>, <code>getFeature()</code>, <code>setUserData()</code>, and <code>getUserData()</code>.</td>
  </tr>
  <tr>
   <td>{{SpecName("DOM3 Core", "core.html#ID-1950641247", "Node")}}</td>
   <td>{{Spec2("DOM3 Core")}}</td>
   <td>The methods <code>insertBefore()</code>, <code>replaceChild()</code>, <code>removeChild()</code>, and <code>appendChild()</code> returns one more kind of error (<code>NOT_SUPPORTED_ERR</code>) if called on a {{DOMxRef("Document")}}.<br>
    The <code>normalize()</code> method has been modified so that {{DOMxRef("Text")}} node can also be normalized if the proper {{DOMxRef("DOMConfiguration")}} flag is set.<br>
    Added the following methods: <code>compareDocumentPosition()</code>, <code>isSameNode()</code>, <code>lookupPrefix()</code>, <code>isDefaultNamespace()</code>, <code>lookupNamespaceURI()</code>, <code>isEqualNode()</code>, <code>getFeature()</code>, <code>setUserData()</code>, and <code>getUserData().</code><br>
    Added the following properties: <code>baseURI</code> and <code>textContent</code>.</td>
  </tr>
  <tr>
   <td>{{SpecName("DOM2 Core", "core.html#ID-1950641247", "Node")}}</td>
   <td>{{Spec2("DOM2 Core")}}</td>
   <td>The <code>ownerDocument</code> property was slightly modified so that {{DOMxRef("DocumentFragment")}} also returns <code>null</code>.<br>
    Added the following properties: <code>namespaceURI</code>, <code>prefix</code>, and <code>localName</code>.<br>
    Added the following methods: <code>normalize()</code>, <code>isSupported()</code> and <code>hasAttributes()</code>.</td>
  </tr>
  <tr>
   <td>{{SpecName("DOM1", "level-one-core.html#ID-1950641247", "Node")}}</td>
   <td>{{Spec2("DOM1")}}</td>
   <td>Initial definition.</td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<div class="hidden">The compatibility table on this page is generated from structured data. If you'd like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<p>{{Compat("api.Node")}}</p>